/* $Header$ */
/* plannodes.c */
void RInitPlan ARGS((Pointer p ));
Plan MakePlan ARGS((Cost cost , Count plan_size , Count plan_width , int fragment , int parallel , EState state , List qptargetlist , List qpqual , Plan lefttree , Plan righttree ));
void OutPlan ARGS((StringInfo str , Plan node ));
bool EqualPlan ARGS((Plan a , Plan b ));
bool CopyPlan ARGS((Plan from , Plan *to , char *(*alloc )()));
Plan IMakePlan ARGS((Cost cost , Count plan_size , Count plan_width , int fragment , int parallel , EState state , List qptargetlist , List qpqual , Plan lefttree , Plan righttree ));
Plan RMakePlan ARGS((void ));
void RInitFragment ARGS((Pointer p ));
Fragment MakeFragment ARGS((Plan frag_root , Plan frag_parent_op , int frag_parallel , List frag_subtrees , Fragment frag_parent_frag , List frag_parsetree , bool frag_is_inprocess ));
void OutFragment ARGS((StringInfo str , Fragment node ));
bool EqualFragment ARGS((Fragment a , Fragment b ));
bool CopyFragment ARGS((Fragment from , Fragment *to , char *(*alloc )()));
Fragment IMakeFragment ARGS((Plan frag_root , Plan frag_parent_op , int frag_parallel , List frag_subtrees , Fragment frag_parent_frag , List frag_parsetree , bool frag_is_inprocess ));
Fragment RMakeFragment ARGS((void ));
void RInitExistential ARGS((Pointer p ));
Existential MakeExistential ARGS((int frag_root ));
void OutExistential ARGS((StringInfo str , Existential node ));
bool EqualExistential ARGS((Existential a , Existential b ));
bool CopyExistential ARGS((Existential from , Existential *to , char *(*alloc )()));
Existential IMakeExistential ARGS((void ));
Existential RMakeExistential ARGS((void ));
void RInitResult ARGS((Pointer p ));
Result MakeResult ARGS((List resrellevelqual , List resconstantqual , ResultState resstate ));
void OutResult ARGS((StringInfo str , Result node ));
bool EqualResult ARGS((Result a , Result b ));
bool CopyResult ARGS((Result from , Result *to , char *(*alloc )()));
Result IMakeResult ARGS((List resrellevelqual , List resconstantqual , ResultState resstate ));
Result RMakeResult ARGS((void ));
void RInitAppend ARGS((Pointer p ));
Append MakeAppend ARGS((List unionplans , Index unionrelid , List unionrtentries , AppendState unionstate ));
void OutAppend ARGS((StringInfo str , Append node ));
bool EqualAppend ARGS((Append a , Append b ));
bool CopyAppend ARGS((Append from , Append *to , char *(*alloc )()));
Append IMakeAppend ARGS((List unionplans , Index unionrelid , List unionrtentries , AppendState unionstate ));
Append RMakeAppend ARGS((void ));
void RInitScan ARGS((Pointer p ));
Scan MakeScan ARGS((Index scanrelid , ScanState scanstate ));
void OutScan ARGS((StringInfo str , Scan node ));
bool EqualScan ARGS((Scan a , Scan b ));
bool CopyScan ARGS((Scan from , Scan *to , char *(*alloc )()));
Scan IMakeScan ARGS((Index scanrelid , ScanState scanstate ));
Scan RMakeScan ARGS((void ));
void RInitSeqScan ARGS((Pointer p ));
SeqScan MakeSeqScan ARGS((int scanrelid ));
void OutSeqScan ARGS((StringInfo str , SeqScan node ));
bool EqualSeqScan ARGS((SeqScan a , SeqScan b ));
bool CopySeqScan ARGS((SeqScan from , SeqScan *to , char *(*alloc )()));
SeqScan IMakeSeqScan ARGS((void ));
SeqScan RMakeSeqScan ARGS((void ));
void RInitScanTemps ARGS((Pointer p ));
ScanTemps MakeScanTemps ARGS((List temprelDescs , ScanTempState scantempState ));
void OutScanTemps ARGS((StringInfo str , ScanTemps node ));
bool EqualScanTemps ARGS((ScanTemps a , ScanTemps b ));
bool CopyScanTemps ARGS((ScanTemps from , ScanTemps *to , char *(*alloc )()));
ScanTemps IMakeScanTemps ARGS((List temprelDescs , ScanTempState scantempState ));
ScanTemps RMakeScanTemps ARGS((void ));
void RInitIndexScan ARGS((Pointer p ));
IndexScan MakeIndexScan ARGS((List indxid , List indxqual , IndexScanState indxstate ));
void OutIndexScan ARGS((StringInfo str , IndexScan node ));
bool EqualIndexScan ARGS((IndexScan a , IndexScan b ));
bool CopyIndexScan ARGS((IndexScan from , IndexScan *to , char *(*alloc )()));
IndexScan IMakeIndexScan ARGS((List indxid , List indxqual , IndexScanState indxstate ));
IndexScan RMakeIndexScan ARGS((void ));
void RInitJoinRuleInfo ARGS((Pointer p ));
JoinRuleInfo MakeJoinRuleInfo ARGS((ObjectId jri_operator , AttributeNumber jri_inattrno , AttributeNumber jri_outattrno , RuleLock jri_lock , ObjectId jri_ruleid , Prs2StubId jri_stubid , Prs2OneStub jri_stub , Prs2StubStats jri_stats ));
void OutJoinRuleInfo ARGS((StringInfo str , JoinRuleInfo node ));
bool EqualJoinRuleInfo ARGS((JoinRuleInfo a , JoinRuleInfo b ));
bool CopyJoinRuleInfo ARGS((JoinRuleInfo from , JoinRuleInfo *to , char *(*alloc )()));
JoinRuleInfo IMakeJoinRuleInfo ARGS((ObjectId jri_operator , AttributeNumber jri_inattrno , AttributeNumber jri_outattrno , RuleLock jri_lock , ObjectId jri_ruleid , Prs2StubId jri_stubid , Prs2OneStub jri_stub , Prs2StubStats jri_stats ));
JoinRuleInfo RMakeJoinRuleInfo ARGS((void ));
void RInitJoin ARGS((Pointer p ));
Join MakeJoin ARGS((JoinRuleInfo ruleinfo ));
void OutJoin ARGS((StringInfo str , Join node ));
bool EqualJoin ARGS((Join a , Join b ));
bool CopyJoin ARGS((Join from , Join *to , char *(*alloc )()));
Join IMakeJoin ARGS((JoinRuleInfo ruleinfo ));
Join RMakeJoin ARGS((void ));
void RInitNestLoop ARGS((Pointer p ));
NestLoop MakeNestLoop ARGS((NestLoopState nlstate , JoinRuleInfo nlRuleInfo ));
void OutNestLoop ARGS((StringInfo str , NestLoop node ));
bool EqualNestLoop ARGS((NestLoop a , NestLoop b ));
bool CopyNestLoop ARGS((NestLoop from , NestLoop *to , char *(*alloc )()));
NestLoop IMakeNestLoop ARGS((NestLoopState nlstate , JoinRuleInfo nlRuleInfo ));
NestLoop RMakeNestLoop ARGS((void ));
void RInitMergeJoin ARGS((Pointer p ));
MergeJoin MakeMergeJoin ARGS((List mergeclauses , ObjectId mergesortop , List mergerightorder , List mergeleftorder , MergeJoinState mergestate ));
void OutMergeJoin ARGS((StringInfo str , MergeJoin node ));
bool EqualMergeJoin ARGS((MergeJoin a , MergeJoin b ));
bool CopyMergeJoin ARGS((MergeJoin from , MergeJoin *to , char *(*alloc )()));
MergeJoin IMakeMergeJoin ARGS((List mergeclauses , ObjectId mergesortop , List mergerightorder , List mergeleftorder , MergeJoinState mergestate ));
MergeJoin RMakeMergeJoin ARGS((void ));
void RInitHashJoin ARGS((Pointer p ));
HashJoin MakeHashJoin ARGS((List hashclauses , ObjectId hashjoinop , HashJoinState hashjoinstate , HashJoinTable hashjointable , IpcMemoryKey hashjointablekey , int hashjointablesize , bool hashdone ));
void OutHashJoin ARGS((StringInfo str , HashJoin node ));
bool EqualHashJoin ARGS((HashJoin a , HashJoin b ));
bool CopyHashJoin ARGS((HashJoin from , HashJoin *to , char *(*alloc )()));
HashJoin IMakeHashJoin ARGS((List hashclauses , ObjectId hashjoinop , HashJoinState hashjoinstate , HashJoinTable hashjointable , IpcMemoryKey hashjointablekey , int hashjointablesize , bool hashdone ));
HashJoin RMakeHashJoin ARGS((void ));
void RInitTemp ARGS((Pointer p ));
Temp MakeTemp ARGS((ObjectId tempid , Count keycount ));
void OutTemp ARGS((StringInfo str , Temp node ));
bool EqualTemp ARGS((Temp a , Temp b ));
bool CopyTemp ARGS((Temp from , Temp *to , char *(*alloc )()));
Temp IMakeTemp ARGS((ObjectId tempid , Count keycount ));
Temp RMakeTemp ARGS((void ));
void RInitMaterial ARGS((Pointer p ));
Material MakeMaterial ARGS((MaterialState matstate ));
void OutMaterial ARGS((StringInfo str , Material node ));
bool EqualMaterial ARGS((Material a , Material b ));
bool CopyMaterial ARGS((Material from , Material *to , char *(*alloc )()));
Material IMakeMaterial ARGS((MaterialState matstate ));
Material RMakeMaterial ARGS((void ));
void RInitSort ARGS((Pointer p ));
Sort MakeSort ARGS((SortState sortstate ));
void OutSort ARGS((StringInfo str , Sort node ));
bool EqualSort ARGS((Sort a , Sort b ));
bool CopySort ARGS((Sort from , Sort *to , char *(*alloc )()));
Sort IMakeSort ARGS((SortState sortstate ));
Sort RMakeSort ARGS((void ));
void RInitAgg ARGS((Pointer p ));
Agg MakeAgg ARGS((Name aggname , AggState aggstate ));
void OutAgg ARGS((StringInfo str , Agg node ));
bool EqualAgg ARGS((Agg a , Agg b ));
bool CopyAgg ARGS((Agg from , Agg *to , char *(*alloc )()));
Agg IMakeAgg ARGS((Name aggname , AggState aggstate ));
Agg RMakeAgg ARGS((void ));
void RInitUnique ARGS((Pointer p ));
Unique MakeUnique ARGS((UniqueState uniquestate ));
void OutUnique ARGS((StringInfo str , Unique node ));
bool EqualUnique ARGS((Unique a , Unique b ));
bool CopyUnique ARGS((Unique from , Unique *to , char *(*alloc )()));
Unique IMakeUnique ARGS((UniqueState uniquestate ));
Unique RMakeUnique ARGS((void ));
void RInitHash ARGS((Pointer p ));
Hash MakeHash ARGS((Var hashkey , HashState hashstate , HashJoinTable hashtable , IpcMemoryKey hashtablekey , int hashtablesize ));
void OutHash ARGS((StringInfo str , Hash node ));
bool EqualHash ARGS((Hash a , Hash b ));
bool CopyHash ARGS((Hash from , Hash *to , char *(*alloc )()));
Hash IMakeHash ARGS((Var hashkey , HashState hashstate , HashJoinTable hashtable , IpcMemoryKey hashtablekey , int hashtablesize ));
Hash RMakeHash ARGS((void ));
void RInitChoose ARGS((Pointer p ));
Choose MakeChoose ARGS((List chooseplanlist ));
void OutChoose ARGS((StringInfo str , Choose node ));
bool EqualChoose ARGS((Choose a , Choose b ));
bool CopyChoose ARGS((Choose from , Choose *to , char *(*alloc )()));
Choose IMakeChoose ARGS((List chooseplanlist ));
Choose RMakeChoose ARGS((void ));
