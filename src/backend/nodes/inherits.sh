#! /bin/sh
# ----------------------------------------------------------------
#   FILE
#	inherits.sh
#
#   DESCRIPTION
#       shell script which generates src/backend/obj/{tags.h,inh.c,slots}
#	which are used by Gen_creator.sh later on during the node function 
#	generation process.
#
#   NOTES
#
#   IDENTIFICATION
# 	$Header$
# ----------------------------------------------------------------
TMPDIR=${TMPDIR-/tmp}
INHFILE=$TMPDIR/inh.$$
TAGFILE=tags.h
TAGTEMP=tags.temp
SLOTFILE=slots
OUTFILE=inh.c

EGREP=egrep
SED=sed
CAT=cat
CMP=cmp
AWK=awk
RM=rm
MV=mv
EXPR=expr

# ----------------
# 	collect nodefiles
# ----------------
NODEFILES=''
x=1
numargs=$#
while [ $x -le $numargs ]; do
   NODEFILES="$NODEFILES $1"
   x=`$EXPR $x + 1`
   shift
done

# ----------------
# 	generate the initial inheritance graph
#
#	sed is used here instead of egrep because not all egreps
#	have a -h option (don't print out the filename)...
# ----------------
$SED -e '/^class/p' -e '/^/d' $NODEFILES | \
$SED \
 -e 's/^class (\([A-Za-z]*\))/\1/' \
 -e 's/ public (\([A-Za-z]*\))/ \1/' \
 -e 's/[ {}]*$//' > $INHFILE

# ----------------
#	generate tags.h from the inheritance graph
# ----------------
$CAT > $TAGTEMP << 'EOF'
/* ----------------------------------------------------------------
 *   FILE
 *	tags.h
 *	
 *   DESCRIPTION
 *	node tag header file - generated by the inherits.sh
 *	script from the contents of the nodes files.
 *
 *   NOTES
 *
 *   IDENTIFICATION
 *	$Header$
 * ----------------------------------------------------------------
 */

EOF
$AWK 'BEGIN { i = -1 }\
     { printf("#define T_%s %d\n", $1, ++i); }' $INHFILE >> $TAGTEMP

# ----------------
# 	now extract slot names from node files and generate slots.temp
# ----------------
$RM -f $SLOTFILE
$CAT $NODEFILES | \
$EGREP -v '(^#|typedef|extern|Defs)'  | \
$AWK '/\/\*/,/\*\// { next; } { print; }' | \
$SED -e 's/;//' \
     -e 's/	/ /g' \
     -e 's/  */ /g' \
     -e 's/\\//' | \
$AWK '
# ----------------
#	ORS and OFS are the output field and record separators
#	nc is the number of "class"es we have scanned
#	inside is a variable set to 1 when we are scanning the
#	   contents of a class definition.
# ----------------
BEGIN { 
	ORS = " "; 
	OFS = "";
	nc = 0;
	inside = 0;
}

# ----------------
#	first search for the "class" tag.  once found
#	extract class information into the classes[] array.
#	i is the slot number of the next slot we scan..
# ----------------
/class /,/\{/ 	{ 
	class = substr($2,2,length($2)-2); 
	classes[ nc++ ] = class;
        i = 1;
	inside = 1;
}

# ----------------
#	process the contents of the class definition
#
#	decl[ class 0 ] contains the number of slots + 1
#	decl[ class x ] contains the slot name for slot x
#	whole[ class x ] contains the entire declaration for slot x
#	parents[ class ] contains the parent class names
# ----------------
/\{/,/\}/ {
	if (inside == 0)
		next;

        if ($1 ~ /\{/)
		next;

	if ($1 ~ /\}/) {
		decl[ class 0 ] = i;
		i = 1;
		inside = 0;
		next;
	}

	if ($1 ~ /inherits/) {
		parent = substr($1,10,length($1)-10);
		parents[ class ] = parent;

		if (parent != "Node") {
			ndecs = decl[ parent 0 ];
			for (j=1; j<ndecs; j++) {
	  			whole[ class i] = whole[ parent j ];
				decl[ class i++ ] = decl[ parent j ];
			}
		}
		next;
	}

	if ($1 ~ /struct/) {
		whole[ class i ] = $0;
	   	decl[ class i++ ] = substr($3,2,length($3)-1);
		next;
	}

	if ($1 !~ /inherits/ && $1 !~ /struct/ && $1 !~ /class/) {
		whole[ class i ] = $0;
		decl[ class i++ ] = $2;
	}
}

# ----------------
#	all nodes have been scanned, now write node slot information.
#	the output format is:
#	
#	{
#	number-of-slots  class
#	slot-name: slot-declaration
#	slot-name: slot-declaration
#	   ...
#	}
#	
#	example:
#	
#	{
#	7 Plan
#	cost:  Cost cost
#	fragment:  Index fragment
#	state:  struct EState *state
#	qptargetlist:  List qptargetlist
#	qpqual:  List qpqual
#	lefttree:  struct Plan *lefttree
#	righttree:  struct Plan *righttree
#	}
#
# ----------------
END {
#	decl[ class 0 ] = i;
	
	for (j=0; j<nc; j++) {
		class = classes[ j ];
		ndecs = decl[ class 0 ];
		if (class != "Node") {
			print "\n{";
			print "\n" ndecs-1 " " class;
			for (i=1; i<ndecs; i++) {
				print "\n" decl[ class i ] ":" \
				           whole[ class i ];
			}
			print "\n}";
			print "\n";
		}
	}
        ORS="\n"
        print

}
' > $SLOTFILE

# ----------------
#	now generate inh.c
# ----------------
$CAT > $OUTFILE << 'EOF'
/* ----------------------------------------------------------------
 *   FILE
 *	inh.c
 *	
 *   DESCRIPTION
 *	node inheritance graph file - generated by the inherits.sh
 *	script from the contents of the nodes files.
 *
 *   NOTES
 *	NodeIsType() now uses a lookup table instead of doing a
 *	tree walk.  The first time you ask for a node's type, we
 *	walk the tree and initialize the corresponding entries in
 *	the table.  Subsequent calls go directly to the table.
 *
 *   IDENTIFICATION
 *	$Header$
 * ----------------------------------------------------------------
 */

#include "tmp/c.h"
#include "nodes/pg_lisp.h"
#include "nodes/nodes.h"
#include "nodes/primnodes.h"
#include "nodes/execnodes.h"
#include "nodes/relation.h"
#include "nodes/plannodes.h"
#include "nodes/mnodes.h"
EOF

echo '#include' \"$TAGFILE\" >> $OUTFILE
$CAT >> $OUTFILE << 'EOF'

struct nodeinfo {
	char	*ni_name;
	TypeId	ni_id;
	TypeId	ni_parent;
	Size	ni_size;
};
struct nodeinfo _NodeInfo[] = {
EOF

$AWK '{ c = $1; p = $2;\
	if (p == "") { p = "Node"; }\
	printf("	{ \"%s\", T_%s, T_%s, sizeof(struct _%s) },\n",\
	       c, c, p, c);\
}' < $INHFILE >> $OUTFILE
$CAT >> $OUTFILE << 'EOF'
	{ "INVALID", 0, 0, 0 }
};

#define _NClasses 	(lengthof(_NodeInfo) - 1)
#define _NClassBytes	((_NClasses / 8) + 1)

TypeId _InvalidTypeId = (TypeId) _NClasses;
bits8  _NodeClassArray[_NClasses][_NClassBytes];    
bits8  _NodeBitMask[] = { 1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7 };

bool   _NodeInfoTrace = false;

/* ----------------
 *	InitNodeArray initializes our node's inheritance table.
 * ----------------
 */
void
InitNodeArray(i)
    register TypeId i;
{
    register TypeId j;
    register int    q;
    register int    r;

    /* ----------------
     *	base clause for recursion: initializing the root node
     * ----------------
     */
    if (i == T_Node) {
	_NodeClassArray[i][0] = 1<<0;
	return;
    }

    /* ----------------
     *	recursive initialization: initialize our parent, if necessary
     * ----------------
     */
    j = _NodeInfo[i].ni_parent;
    if (_NodeClassArray[j][0] == 0)
	InitNodeArray(j);

    /* ----------------
     *	now initialize ourself by copying our parent's bitmask and
     *  setting our own bit.
     * ----------------
     */
    for (q=0; q<_NClassBytes; q++)
	_NodeClassArray[i][q] = _NodeClassArray[j][q];
    
    q = i / 8; r = i % 8;
    _NodeClassArray[i][q] |= _NodeBitMask[r];
}

/* ----------------
 *	NodeIsType
 *
 * 	determine if (thisNode) is of type (tag) or is a subclass
 *	of type (tag).  We do this by consulting the master
 *	node class array bitmap: look in the row corresponding
 *	to (thisNode)'s type.  Now look at the bit in the position
 *	indicated by (tag).  If this is set, then (thisNode) is
 *	of type (tag), otherwise it's not.
 *		     
 *	The table is initialized on demand.  If nobody ever asks
 *	about a given class, then we never initialize that class's
 *	information...
 * ----------------
 */
bool
NodeIsType(thisNode, tag)
    Node		thisNode;
    register TypeId 	tag;
{
    register TypeId i;
    register int    q;
    register int    r;
	
    Assert(NodeIsValid(thisNode));
    
    i = NodeType(thisNode);
    Assert(TypeIdIsValid(i));
    Assert(TypeIdIsValid(tag));

    if (_NodeClassArray[i][0] == 0)
	InitNodeArray(i);

    q = tag / 8; r = tag % 8;
    return (bool)
	(_NodeClassArray[i][q] & _NodeBitMask[r]);
}
    
void
Dump_NodeInfo()
{
    register TypeId	i;

    printf("%16.16s%16.16s%16.16s\n", 
	   "NODE NAME:", "NODE TAG:", "PARENT NODE:");

    for (i = 0; i < _InvalidTypeId; ++i)
	printf("%16.16s%16.1d%16.16s\n",
	       _NodeInfo[i].ni_name,
	       _NodeInfo[i].ni_id, 
	       _NodeInfo[_NodeInfo[i].ni_parent].ni_name);
}

EOF
$RM -f $INHFILE

# ----------------
#	finally, compare the new tagfile with the old.
#	this can potentially save some work in rebuilding stuff
#	in the case where tags.h may not have actually changed.
# ----------------
if [ -r $TAGFILE ]; then 
	if $CMP -s $TAGFILE $TAGTEMP ; then 
		echo "tags.h unchanged";
		$RM -f $TAGTEMP
	else
		$MV $TAGTEMP $TAGFILE; 
	fi
else
	$MV $TAGTEMP $TAGFILE;
fi

# ----------------
#	all done
# ----------------
exit 0
