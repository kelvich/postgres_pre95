#! /bin/sh
# ----------------------------------------------------------------
#   FILE
#	inherits.sh
#
#   DESCRIPTION
#       shell script which generates tags.h and inh.c
#	and $TREE/$OD/lib/H/slots, which is used by Gen_creator.sh
#	later on during the node function generation process.
#
#   NOTES
#
#   IDENTIFICATION
# 	$Header$
# ----------------------------------------------------------------
TMPDIR=${TMPDIR-/tmp}
INHFILE=$TMPDIR/inh.$$
TAGFILE=$TREE/$OD/lib/H/tags.h
TAGTEMP=$TREE/$OD/lib/H/tags.temp
SLOTFILE=$TREE/$OD/lib/H/slots
OUTFILE=inh.c

# ----------------
# 	collect nodefiles
# ----------------
# NODEFILES=''
# x=1
# numargs=$#
# while test $x -le $numargs ; do
#    NODEFILES="$NODEFILES $1"
#    x=`expr $x + 1`
#    shift
# done

NODEFILES="nodes.h plannodes.h primnodes.h relation.h execnodes.h mnodes.h pg_lisp.h"

# ----------------
# 	generate the initial inheritance graph
# ----------------
egrep -h '^class' $NODEFILES | \
sed \
 -e 's/^class (\([A-Za-z]*\))/\1/' \
 -e 's/ public (\([A-Za-z]*\))/ \1/' \
 -e 's/[ {}]*$//' > $INHFILE

# ----------------
#	generate tags.h from the inheritance graph
# ----------------
cat > $TAGTEMP << 'EOF'
/* ----------------------------------------------------------------
 *   FILE
 *	tags.h
 *	
 *   DESCRIPTION
 *	node tag header file - generated by the inherits.sh
 *	script from the contents of the nodes files.
 *
 *   NOTES
 *
 *   IDENTIFICATION
 *	$Header$
 * ----------------------------------------------------------------
 */

EOF
awk 'BEGIN { i = -1 }\
     { printf("#define T_%s %d\n", $1, ++i) }' $INHFILE >> $TAGTEMP

# ----------------
# 	now extract slot names from node files and generate slots.temp
# ----------------
rm -f $SLOTFILE
cat $NODEFILES | \
egrep -v '(^#|^[ 	/]*\*|typedef|extern|Defs)'  | \
sed -e 's/;//' \
    -e '/\/\*/,/\*\//D' \
    -e 's/	/ /g' \
    -e 's/  */ /g' \
    -e 's/\\//' | \
awk '
# ----------------
#	ORS and OFS are the output field and record separators
#	nc is the number of "class"es we have scanned
#	inside is a variable set to 1 when we are scanning the
#	   contents of a class definition.
# ----------------
BEGIN { 
	ORS = " "; 
	OFS = "";
	nc = 0;
	inside = 0;
}

# ----------------
#	first search for the "class" tag.  once found
#	extract class information into the classes[] array.
#	i is the slot number of the next slot we scan..
# ----------------
/class /,/{/ 	{ 
	class = substr($2,2,length($2)-2); 
	classes[ nc++ ] = class;
        i = 1;
	inside = 1;
}

# ----------------
#	process the contents of the class definition
#
#	decl[ class 0 ] contains the number of slots + 1
#	decl[ class x ] contains the slot name for slot x
#	whole[ class x ] contains the entire declaration for slot x
#	parents[ class ] contains the parent class names
# ----------------
/{/,/}/ {
	if (inside == 0)
		next;

        if ($1 ~ /{/)
		next;

	if ($1 ~ /}/) {
		decl[ class 0 ] = i;
		i = 1;
		inside = 0;
		next;
	}

	if ($1 ~ /inherits/) {
		parent = substr($1,10,length($1)-10);
		parents[ class ] = parent;

		if (parent != "Node") {
			ndecs = decl[ parent 0 ];
			for (j=1; j<ndecs; j++) {
	  			whole[ class i] = whole[ parent j ];
				decl[ class i++ ] = decl[ parent j ];
			}
		}
		next;
	}

	if ($1 ~ /struct/) {
		whole[ class i ] = $0;
	   	decl[ class i++ ] = substr($3,2,length($3)-1);
		next;
	}

	if ($1 !~ /inherits/ && $1 !~ /struct/ && $1 !~ /class/) {
		whole[ class i ] = $0;
		decl[ class i++ ] = $2;
	}
}

# ----------------
#	all nodes have been scanned, now write node slot information.
#	the output format is:
#	
#	{
#	number-of-slots  class
#	slot-name: slot-declaration
#	slot-name: slot-declaration
#	   ...
#	}
#	
#	example:
#	
#	{
#	7 Plan
#	cost:  Cost cost
#	fragment:  Index fragment
#	state:  struct EState *state
#	qptargetlist:  List qptargetlist
#	qpqual:  List qpqual
#	lefttree:  struct Plan *lefttree
#	righttree:  struct Plan *righttree
#	}
#
# ----------------
END {
	decl[ class 0 ] = i;
	
	for (j=0; j<nc; j++) {
		class = classes[ j ];
		ndecs = decl[ class 0 ];
		if (class != "Node") {
			print "\n{";
			print "\n" ndecs-1 " " class;
			for (i=1; i<ndecs; i++) {
				print "\n" decl[ class i ] ":" \
				           whole[ class i ];
			}
			print "\n}";
			print "\n";
		}
	}
	print "\n";
}
' > $SLOTFILE

# ----------------
#	now generate inh.c
# ----------------
cat > $OUTFILE << 'EOF'
/* ----------------------------------------------------------------
 *   FILE
 *	inh.c
 *	
 *   DESCRIPTION
 *	node inheritance graph file - generated by the inherits.sh
 *	script from the contents of the nodes files.
 *
 *   INTERFACE ROUTINES
 *	NodeIsType()
 *	NodeGetTag()
 *	NodeSetTag()
 *	NodeHasTag()
 *
 *   NOTES
 *
 *   IDENTIFICATION
 *	$Header$
 * ----------------------------------------------------------------
 */

#include "pg_lisp.h"
#include "c.h"
#include "nodes.h"
EOF

echo '#include' \"$TAGFILE\" >> $OUTFILE
cat >> $OUTFILE << 'EOF'

struct nodeinfo {
	char	*ni_name;
	TypeId	ni_id;
	TypeId	ni_parent;
};
static struct nodeinfo _NodeInfo[] = {
EOF

awk '{ if ($2 == "") { $2 = "Node" };\
       printf("	{ \"%s\", T_%s, T_%s },\n", $1, $1, $2) }' \
      $INHFILE >> $OUTFILE
cat >> $OUTFILE << 'EOF'
	{ "INVALID", 0, 0 }
};

TypeId	_InvalidTypeId = (TypeId) (lengthof(_NodeInfo) - 1);

bool	_NodeInfoTrace = false;

bool
NodeIsType(thisNode, tag)
	Node	thisNode;
	TypeId	tag;
{
	register TypeId	i;

	Assert(NodeIsValid(thisNode));
	Assert(TypeIdIsValid(NodeType(thisNode)));
	Assert(TypeIdIsValid(tag));

	for (i = NodeType(thisNode);
	     i != tag && i != T_Node;
	     i = _NodeInfo[i].ni_parent)
		if (_NodeInfoTrace)
			printf("NodeIsType: %s IsA %s?\n",
			       _NodeInfo[i].ni_name, _NodeInfo[tag].ni_name);
	if (_NodeInfoTrace) {
		printf("NodeIsType: %s IsA %s?\n",
		       _NodeInfo[i].ni_name, _NodeInfo[tag].ni_name);
		printf("NodeIsType: %s IsA %s returns %s\n",
		       _NodeInfo[NodeType(thisNode)].ni_name,
		       _NodeInfo[tag].ni_name,
		       (i == tag) ? "true" : "false");
	}
	return((bool) (i == tag));
}

void
Dump_NodeInfo()
{
	register TypeId	i;

	printf("%16.16s%16.16s%16.16s\n", 
	       "NODE NAME:", "NODE TAG:", "PARENT NODE:");
	for (i = 0; i < _InvalidTypeId; ++i)
		printf("%16.16s%16.1d%16.16s\n",
		       _NodeInfo[i].ni_name,
		       _NodeInfo[i].ni_id, 
		       _NodeInfo[_NodeInfo[i].ni_parent].ni_name);
}
bool
NodeTagIsValid(tag)
	NodeTag	tag;
{
	return ((bool)(tag < _InvalidTypeId));
}

NodeTag
NodeGetTag(node)
	Node	node;
{
	Assert(NodeIsValid(node));

	return (node->type);
}

void
NodeSetTag(node, tag)
	Node	node;
	NodeTag	tag;
{
	Assert(PointerIsValid(node));
	Assert(NodeTagIsValid(tag));

	node->type = tag;
}

bool
NodeHasTag(node, tag)
	Node	node;
	NodeTag	tag;
{
	return ((bool)(NodeGetTag(node) == tag));
}

EOF
rm -f $INHFILE

# ----------------
#	finally, compare the new tagfile with the old.
#
#	if the tagfile has changed, then it means that
#	cinterface.a has to be remade because its tag #defines
#	are different.
# ----------------
if [ -r $TAGFILE ]; then 
	if cmp -s $TAGFILE $TAGTEMP ; then 
		echo "tags.h unchanged";
	else
		mv $TAGTEMP $TAGFILE; 
		echo "tags.h has changed; remake cinterface.a";
	fi
else
	mv $TAGTEMP $TAGFILE;
fi

# ----------------
#	all done
# ----------------
exit 0
