/* $Header$ */

#include "nodes/pg_lisp.h"


/* relation.c */
void RInitRel ARGS((Pointer p ));
Rel MakeRel ARGS((Relid relids , bool indexed , Count pages , Count tuples , Count size , Count width , List targetlist , List pathlist , Path unorderedpath , Path cheapestpath , List classlist , List indexkeys , oid indproc , List ordering , List clauseinfo , List joininfo , List innerjoin , List superrels ));
void OutRel ARGS((StringInfo str , Rel node ));
bool EqualRel ARGS((Rel a , Rel b ));
bool CopyRel ARGS((Rel from , Rel *to , char *(*alloc )()));
Rel IMakeRel ARGS((Relid relids , bool indexed , Count pages , Count tuples , Count size , Count width , List targetlist , List pathlist , Path unorderedpath , Path cheapestpath , List classlist , List indexkeys , oid indproc , List ordering , List clauseinfo , List joininfo , List innerjoin , List superrels ));
Rel RMakeRel ARGS((void ));
void RInitSortKey ARGS((Pointer p ));
SortKey MakeSortKey ARGS((List varkeys , List sortkeys , Relid relid , List sortorder ));
void OutSortKey ARGS((StringInfo str , SortKey node ));
bool EqualSortKey ARGS((SortKey a , SortKey b ));
bool CopySortKey ARGS((SortKey from , SortKey *to , char *(*alloc )()));
SortKey IMakeSortKey ARGS((List varkeys , List sortkeys , Relid relid , List sortorder ));
SortKey RMakeSortKey ARGS((void ));
void RInitPath ARGS((Pointer p ));
Path MakePath ARGS((int32 pathtype , Rel parent , Cost path_cost , List p_ordering , List keys , SortKey pathsortkey , Cost outerjoincost , Relid joinid ));
void OutPath ARGS((StringInfo str , Path node ));
bool EqualPath ARGS((Path a , Path b ));
bool CopyPath ARGS((Path from , Path *to , char *(*alloc )()));
Path IMakePath ARGS((int32 pathtype , Rel parent , Cost path_cost , List p_ordering , List keys , SortKey pathsortkey , Cost outerjoincost , Relid joinid ));
Path RMakePath ARGS((void ));
void RInitIndexPath ARGS((Pointer p ));
IndexPath MakeIndexPath ARGS((List indexid , List indexqual ));
void OutIndexPath ARGS((StringInfo str , IndexPath node ));
bool EqualIndexPath ARGS((IndexPath a , IndexPath b ));
bool CopyIndexPath ARGS((IndexPath from , IndexPath *to , char *(*alloc )()));
IndexPath IMakeIndexPath ARGS((List indexid , List indexqual ));
IndexPath RMakeIndexPath ARGS((void ));
void RInitJoinPath ARGS((Pointer p ));
JoinPath MakeJoinPath ARGS((List pathclauseinfo , Path outerjoinpath , Path innerjoinpath ));
void OutJoinPath ARGS((StringInfo str , JoinPath node ));
bool EqualJoinPath ARGS((JoinPath a , JoinPath b ));
bool CopyJoinPath ARGS((JoinPath from , JoinPath *to , char *(*alloc )()));
JoinPath IMakeJoinPath ARGS((List pathclauseinfo , Path outerjoinpath , Path innerjoinpath ));
JoinPath RMakeJoinPath ARGS((void ));
void RInitMergePath ARGS((Pointer p ));
MergePath MakeMergePath ARGS((List path_mergeclauses , List outersortkeys , List innersortkeys ));
void OutMergePath ARGS((StringInfo str , MergePath node ));
bool EqualMergePath ARGS((MergePath a , MergePath b ));
bool CopyMergePath ARGS((MergePath from , MergePath *to , char *(*alloc )()));
MergePath IMakeMergePath ARGS((List path_mergeclauses , List outersortkeys , List innersortkeys ));
MergePath RMakeMergePath ARGS((void ));
void RInitHashPath ARGS((Pointer p ));
HashPath MakeHashPath ARGS((List path_hashclauses , List outerhashkeys , List innerhashkeys ));
void OutHashPath ARGS((StringInfo str , HashPath node ));
bool EqualHashPath ARGS((HashPath a , HashPath b ));
bool CopyHashPath ARGS((HashPath from , HashPath *to , char *(*alloc )()));
HashPath IMakeHashPath ARGS((List path_hashclauses , List outerhashkeys , List innerhashkeys ));
HashPath RMakeHashPath ARGS((void ));
void RInitOrderKey ARGS((Pointer p ));
OrderKey MakeOrderKey ARGS((int attribute_number , Index array_index ));
void OutOrderKey ARGS((StringInfo str , OrderKey node ));
bool EqualOrderKey ARGS((OrderKey a , OrderKey b ));
bool CopyOrderKey ARGS((OrderKey from , OrderKey *to , char *(*alloc )()));
OrderKey IMakeOrderKey ARGS((int attribute_number , Index array_index ));
OrderKey RMakeOrderKey ARGS((void ));
void RInitJoinKey ARGS((Pointer p ));
JoinKey MakeJoinKey ARGS((LispValue outer , LispValue inner ));
void OutJoinKey ARGS((StringInfo str , JoinKey node ));
bool EqualJoinKey ARGS((JoinKey a , JoinKey b ));
bool CopyJoinKey ARGS((JoinKey from , JoinKey *to , char *(*alloc )()));
JoinKey IMakeJoinKey ARGS((LispValue outer , LispValue inner ));
JoinKey RMakeJoinKey ARGS((void ));
void RInitMergeOrder ARGS((Pointer p ));
MergeOrder MakeMergeOrder ARGS((ObjectId join_operator , ObjectId left_operator , ObjectId right_operator , ObjectId left_type , ObjectId right_type ));
void OutMergeOrder ARGS((StringInfo str , MergeOrder node ));
bool EqualMergeOrder ARGS((MergeOrder a , MergeOrder b ));
bool CopyMergeOrder ARGS((MergeOrder from , MergeOrder *to , char *(*alloc )()));
MergeOrder IMakeMergeOrder ARGS((ObjectId join_operator , ObjectId left_operator , ObjectId right_operator , ObjectId left_type , ObjectId right_type ));
MergeOrder RMakeMergeOrder ARGS((void ));
void RInitCInfo ARGS((Pointer p ));
CInfo MakeCInfo ARGS((Expr clause , Cost selectivity , bool notclause , List indexids , MergeOrder mergesortorder , ObjectId hashjoinoperator , Relid cinfojoinid ));
void OutCInfo ARGS((StringInfo str , CInfo node ));
bool EqualCInfo ARGS((CInfo a , CInfo b ));
bool CopyCInfo ARGS((CInfo from , CInfo *to , char *(*alloc )()));
CInfo IMakeCInfo ARGS((Expr clause , Cost selectivity , bool notclause , List indexids , MergeOrder mergesortorder , ObjectId hashjoinoperator , Relid cinfojoinid ));
CInfo RMakeCInfo ARGS((void ));
void RInitJoinMethod ARGS((Pointer p ));
JoinMethod MakeJoinMethod ARGS((List jmkeys , List clauses ));
void OutJoinMethod ARGS((StringInfo str , JoinMethod node ));
bool EqualJoinMethod ARGS((JoinMethod a , JoinMethod b ));
bool CopyJoinMethod ARGS((JoinMethod from , JoinMethod *to , char *(*alloc )()));
JoinMethod IMakeJoinMethod ARGS((List jmkeys , List clauses ));
JoinMethod RMakeJoinMethod ARGS((void ));
void RInitHInfo ARGS((Pointer p ));
HInfo MakeHInfo ARGS((ObjectId hashop ));
void OutHInfo ARGS((StringInfo str , HInfo node ));
bool EqualHInfo ARGS((HInfo a , HInfo b ));
bool CopyHInfo ARGS((HInfo from , HInfo *to , char *(*alloc )()));
HInfo IMakeHInfo ARGS((ObjectId hashop ));
HInfo RMakeHInfo ARGS((void ));
void RInitMInfo ARGS((Pointer p ));
MInfo MakeMInfo ARGS((MergeOrder m_ordering ));
void OutMInfo ARGS((StringInfo str , MInfo node ));
bool EqualMInfo ARGS((MInfo a , MInfo b ));
bool CopyMInfo ARGS((MInfo from , MInfo *to , char *(*alloc )()));
MInfo IMakeMInfo ARGS((MergeOrder m_ordering ));
MInfo RMakeMInfo ARGS((void ));
void RInitJInfo ARGS((Pointer p ));
JInfo MakeJInfo ARGS((List otherrels , List jinfoclauseinfo , bool mergesortable , bool hashjoinable , bool inactive ));
void OutJInfo ARGS((StringInfo str , JInfo node ));
bool EqualJInfo ARGS((JInfo a , JInfo b ));
bool CopyJInfo ARGS((JInfo from , JInfo *to , char *(*alloc )()));
JInfo IMakeJInfo ARGS((List otherrels , List jinfoclauseinfo , bool mergesortable , bool hashjoinable , bool inactive ));
JInfo RMakeJInfo ARGS((void ));


