/*     
 *      FILE
 *     	storeplan
 *     
 *      DESCRIPTION
 *     	Routines to store and retrieve plans
 *
 *      IDENTIFICATION
 *      $Header$
 *     
 */

#include "tmp/postgres.h"

#include "rules/params.h"
#include "utils/log.h"
#include "utils/palloc.h"

#include "nodes/nodes.h"
#include "nodes/pg_lisp.h"

/*-------------------------------------------------
 *
 * StringToPlan
 *     given a string (generated by "PlanToString")
 *     reconstruct the plan (or any (?) other LispValue
 *     structure).
 */
LispValue
StringToPlan (string)
	char *string;
{
	extern LispValue lispReadString();
	return(lispReadString(string));

}

 
/*-------------------------------------------------
 *
 * StringToPlanWithParams
 *     Same as StringToPlan, but it also returns
 *     an array (of type ParamListInfo) of all the Param
 *     nodes
 */
LispValue
StringToPlanWithParams (string, paramListP)
	char *string;
	ParamListInfo * paramListP;
{
	extern LispValue lispReadStringWithParams();
	return(lispReadStringWithParams(string, paramListP));

}


/*--------------------------------------------------------------
 *
 * PlanToString
 *
 * Given a plan (a lisp list, i.e. a LispValue) transform it
 * into a string.
 */
char *
PlanToString(l)
LispValue l;
{
    char fileName[100];
    FILE *fp;
    int fd;
    Size count;
    int c;
    char *s;

    /*
     * generate a unique file name in /tmp
     */
    sprintf(fileName, "/tmp/rule.%d", getpid() );

    AllocateFile();
    fp = fopen(fileName, "w");
    if (fp==NULL) {
	perror("PlanToString");
	FreeFile();
	elog(WARN, "PlanToString: Could not open file %s\n", fileName);
    }

    /*
     * print the string representation of the plan in the temp file
     */
    lispDisplayFp(fp, l, 0);

    /*
     * Now read the filename and count the number of characters.
     */
    fclose(fp);
    fp = fopen(fileName, "r");
    count = 0;
    while (getc(fp) != EOF)
	count += 1;
    
    s = palloc(count+1);
    if (s==NULL) {
	FreeFile();
	elog(WARN, "string_to_plan: could no palloc(%d)\n", count);
    }

    /*
     * now read the plan & store it into the string
     */
    count = 0;
    rewind(fp);
    while ((c = getc(fp)) != EOF) {
	s[count] = c;
	count += 1;
    }
    s[count] = '\0';

    /*
     * Now close & remove the temp file
     */
    fclose(fp);
    FreeFile();
    unlink(fileName);

    return(s);

}
