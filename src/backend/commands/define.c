/* ----------------------------------------------------------------
 * define.c --
 *	POSTGRES define (function | type | operator) utility code.
 *
 * NOTES:
 *	These things must be defined and committed in the following order:
 *		input/output, recv/send procedures
 *		type
 *		operators
 * ----------------------------------------------------------------
 */

#include "c.h"

RcsId("$Header$");

#include <strings.h>	/* XXX style */
#include "cat.h"

#include "anum.h"
#include "catname.h"
#include "fmgr.h"	/* for fmgr */
#include "ftup.h"
#include "heapam.h"
#include "htup.h"
#include "log.h"
#include "manip.h"
#include "name.h"
#include "parse.h"	/* for ARG */
#include "pg_lisp.h"
#include "rproc.h"
#include "syscache.h"
#include "tqual.h"

#include "defrem.h"

/* ----------------
 *	external functions
 * ----------------
 */
extern	ObjectId TypeDefine();
extern	void	 ProcedureDefine();
extern	void	 OperatorDefine();

/* ----------------
 *	this is used by the DefineXXX functions below.
 * ----------------
 */
extern
String		/* XXX Datum */
FetchDefault ARGS((
	String	string,
	String	standard
));

/* ----------------------------------------------------------------
 *		Define Function / Operator / Type
 * ----------------------------------------------------------------
 */

/* --------------------------------
 *	DefineFunction
 * --------------------------------
 */
void
DefineFunction(name, parameters)
    Name	name;
    LispValue	parameters;
{
    String	returnTypeName;
    String	languageName;
    String	fileName;
    bool	canCache;
    LispValue	argList;
    LispValue	entry;
    
    /* ----------------
     * Note:
     * XXX	Checking of "name" validity (16 characters?) is needed.
     * ----------------
     */
    AssertArg(NameIsValid(name));
    AssertArg(listp(parameters));
    
    /* ----------------
     * handle "[ language = X ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "language");
    if (null(entry)) {
	languageName = FetchDefault("language", "C");
    } else {
	languageName = DefineEntryGetString(entry);
    }
    
    /* ----------------
     * handle "file = X"
     * ----------------
     */
    entry = DefineListRemoveRequiredAssignment(&parameters, "file");
    fileName = DefineEntryGetString(entry);
    
    /* ----------------
     * handle "[ iscachable ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalIndicator(&parameters, "iscachable");
    canCache = (bool)!null(entry);
    
    /* ----------------
     * handle "returntype = X"
     * ----------------
     */
    entry = DefineListRemoveRequiredAssignment(&parameters, "returntype");
    returnTypeName = DefineEntryGetString(entry);
    
    /* ----------------
     * handle "[ arg is (...) ]"
     * XXX fix optional arg handling below
     * ----------------
     */
    argList = LispRemoveMatchingSymbol(&parameters, ARG);
    
    if (!null(argList)) {
	LispValue	rest;
	
	/*
	 * first discard symbol 'arg from list
	 */
	argList = CDR(argList);
	AssertArg(length(argList) > 0);
	
	foreach (rest, argList) {
	    if (!lispStringp(CAR(rest))) {
		elog(WARN, "DefineFunction: arg type = ?");
	    }
	}
    }

    /* ----------------
     *	there should be nothing more
     * ----------------
     */
    DefineListAssertEmpty(parameters);

    /* ----------------
     *	now have ProcedureDefine do all the work..
     * ----------------
     */
    ProcedureDefine(name,
		    returnTypeName,
		    languageName,
		    fileName,
		    canCache,
		    argList);
}

/*
 *  Utility to handle definition of postquel procedures.
 */

void
DefinePFunction(pname,relname,qstring)
     Name  pname;
     Name  relname;
     char  *qstring;
{
  static char query_buf[1024];

  /*
   *  First we have to add a column to the relation.
   */

  /* XXX Fix this after catalogs fix to get relation type. */

  sprintf(query_buf, "addattr (%s = int4) to %s", pname, relname); 
  /*  printf( "Query is : %s\n", query_buf); */
  pg_eval(query_buf); 

  /*
   * Now we have to define the appropriate rule for the Postquel
   * function(procedure).
   */

  sprintf(query_buf, "define rule %s_rule is on retrieve to %s.%s do instead %s", pname, relname, pname, qstring);

  /*  printf("Rule defined is: %s\n", query_buf); */
  pg_eval(query_buf); 
}


/* --------------------------------
 *	DefineOperator
 *
 *	this function extracts all the information from the
 *	parameter list generated by the parser and then has
 *	OperatorDefine() do all the actual work.
 * --------------------------------
 */
void
DefineOperator(name, parameters)
    Name	name;
    LispValue	parameters;
{
    LispValue	entry;
    Name 	functionName;	 	/* function for operator */
    Name 	typeName1;	 	/* first type name */
    Name 	typeName2;	 	/* optional second type name */
    uint16 	precedence; 		/* operator precedence */
    bool	canHash; 		/* operator hashes */
    bool	isLeftAssociative; 	/* operator is left associative */
    Name 	commutatorName;	 	/* optional commutator operator name */
    Name 	negatorName;	 	/* optional negator operator name */
    Name 	restrictionName;	/* optional restrict. sel. procedure */
    Name 	joinName;	 	/* optional join sel. procedure name */
    Name 	sortName1;	 	/* optional first sort operator */
    Name 	sortName2;	 	/* optional second sort operator */
    
    /* ----------------
     *	sanity checks
     *
     * XXX	Checking of operator "name" validity
     *		(16 characters?) is needed.
     * ----------------
     */
    AssertArg(NameIsValid(name));
    AssertArg(listp(parameters));

    /* ----------------
     * handle "arg1 = typname"
     *	
     * XXX ( ... arg1 = typname [ , arg2 = typname ] ... )
     * XXX is undocumented in the reference manual source as of 89/8/22.
     * ----------------
     */
    entry = DefineListRemoveRequiredAssignment(&parameters, "arg1");
    typeName1 = DefineEntryGetName(entry);
    
    /* ----------------
     * handle "[ arg2 = typname ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "arg2");
    typeName2 = NULL;
    if (!null(entry)) {
	typeName2 = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "procedure = proname"
     * ----------------
     */
    entry = DefineListRemoveRequiredAssignment(&parameters, "procedure");
    functionName = DefineEntryGetName(entry);
    
    /* ----------------
     * handle "[ precedence = number ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "precedence");
    if (null(entry)) {
	precedence = 0;		/* FetchDefault? */
    } else {
	precedence = DefineEntryGetInteger(entry);
    }
    
    /* ----------------
     * handle "[ associativity = (left|right|none|any) ]"
     *	
     * XXX Associativity code below must be fixed when the catalogs and
     * XXX the planner/executor support proper associativity semantics.
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "associativity");
    if (null(entry)) {
	isLeftAssociative = true;	/* XXX FetchDefault */
    } else {
	String	string;
	
	string = DefineEntryGetString(entry);
	if (StringEquals(string, "right")) {
	    isLeftAssociative = false;
	} else if (!StringEquals(string, "left") &&
		   !StringEquals(string, "none") &&
		   !StringEquals(string, "any")) {
	    elog(WARN, "Define: precedence = what?");
	} else {
	    isLeftAssociative = true;
	}
    }
    
    /* ----------------
     * handle "[ commutator = oprname ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "commutator");
    commutatorName = NULL;
    if (!null(entry)) {
	commutatorName = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "[ negator = oprname ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "negator");
    negatorName = NULL;
    if (!null(entry)) {
	negatorName = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "[ restrict = proname ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "restrict");
    restrictionName = NULL;
    if (!null(entry)) {
	restrictionName = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "[ join = proname ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "join");
    joinName = NULL;
    if (!null(entry)) {
	joinName = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "[ hashes ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalIndicator(&parameters, "hashes");
    canHash = (bool)!null(entry);
    
    /* ----------------
     * handle "[ sort1 = oprname ]"
     *	
     * XXX ( ... [ , sort1 = oprname ] [ , sort2 = oprname ] ... )
     * XXX is undocumented in the reference manual source as of 89/8/22.
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "sort1");
    sortName1 = NULL;
    if (!null(entry)) {
	sortName1 = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "[ sort2 = oprname ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "sort2");
    sortName2 = NULL;
    if (!null(entry)) {
	sortName2 = DefineEntryGetName(entry);
    }

    /* ----------------
     *	there should be nothing more..
     * ----------------
     */
    DefineListAssertEmpty(parameters);

    /* ----------------
     *	now have OperatorDefine do all the work..
     * ----------------
     */
    OperatorDefine(name,		/* operator name */
		   typeName1,		/* first type name */
		   typeName2,		/* optional second type name */
		   functionName,	/* function for operator */
		   precedence,		/* operator precedence */
		   isLeftAssociative,	/* operator is left associative */
		   commutatorName,	/* optional commutator operator name */
		   negatorName,		/* optional negator operator name */
		   restrictionName,	/* optional restrict. sel. procedure */
		   joinName,		/* optional join sel. procedure name */
		   canHash,		/* operator hashes */
		   sortName1,		/* optional first sort operator */
		   sortName2);		/* optional second sort operator */
}

/* --------------------------------
 *	DefineType
 * --------------------------------
 */
void
DefineType(name, parameters)
    Name	name;
    LispValue	parameters;
{
    LispValue	entry;
    int16	internalLength;		/* int2 */
    int16	externalLength;		/* int2 */
    Name	inputName;
    Name	outputName;
    Name	sendName;
    Name	receiveName;
    char*	defaultValue;		/* Datum */
    bool	byValue;		/* Boolean */
    
    /* ----------------
     *	sanity checks
     *
     * XXX	Checking of operator "name" validity
     *		(16 characters?) is needed.
     * ----------------
     */
    AssertArg(NameIsValid(name));
    AssertArg(listp(parameters));
    
    /* ----------------
     * handle "internallength = (number | variable)"
     * ----------------
     */
    entry = DefineListRemoveRequiredAssignment(&parameters,
					       "internallength");
    internalLength = DefineEntryGetLength(entry);
    
    /* ----------------
     * handle "[ externallength = (number | variable) ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters,
					       "externallength");
    externalLength = 0;		/* FetchDefault? */
    if (!null(entry)) {
	externalLength = DefineEntryGetLength(entry);
    }
    
    /* ----------------
     * handle "input = procedure"
     * ----------------
     */
    entry = DefineListRemoveRequiredAssignment(&parameters, "input");
    inputName = DefineEntryGetName(entry);
    
    /* ----------------
     * handle "output = procedure"
     * ----------------
     */
    entry = DefineListRemoveRequiredAssignment(&parameters, "output");
    outputName = DefineEntryGetName(entry);
    
    /* ----------------
     * handle "[ send = procedure ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "send");
    sendName = NULL;
    if (!null(entry)) {
	sendName = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "[ receive = procedure ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "receive");
    receiveName = NULL;
    if (!null(entry)) {
	receiveName = DefineEntryGetName(entry);
    }
    
    /* ----------------
     * handle "[ default = `...' ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalAssignment(&parameters, "default");
    defaultValue = NULL;
    if (!null(entry)) {
	defaultValue = DefineEntryGetString(entry);
    }
    
    /* ----------------
     * handle "[ passedbyvalue ]"
     * ----------------
     */
    entry = DefineListRemoveOptionalIndicator(&parameters, "passedbyvalue");
    byValue = (bool)!null(entry);
    
    /* ----------------
     *	there should be nothing more..
     * ----------------
     */
    DefineListAssertEmpty(parameters);

    /* ----------------
     *	now have TypeDefine do all the real work.
     * ----------------
     */
    (void) TypeDefine(name,		/* type name */
		      InvalidObjectId,  /* relation oid (n/a here) */
		      internalLength,	/* internal size */
		      externalLength,	/* external size */
		      'b',		/* type-type (base type) */
		      inputName,	/* input procedure */
		      outputName,	/* output procedure */
		      sendName,		/* send procedure */
		      receiveName,	/* recieve procedure */
		      defaultValue,	/* default type value */
		      byValue);		/* passed by value */
}
