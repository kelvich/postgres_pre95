/*
 * Interface to Postgres 2.0
 *
 * $Header: /genome/src/postgres/src/contrib/pgperl/RCS/pg-libpq.mus,v 1.3 92/
01/30 16:50:35 hartzell Exp Locker: hartzell $
 *
 * Tue Aug 21 14:13:40 1990  Igor Metz <metz@iam.unibe.ch>
 *
 * $Id$
 * $Log$
 * Revision 1.3  1992/02/15 20:32:32  mer
 * updated by George Hartzell of the Stanford Genome project
 *
# Revision 1.3  92/01/30  16:50:35  hartzell
# added PQendcopy, PQgetline, and PQputline.  Don't trust
# PQgetline, since it expects a pointer to a buffer (a char *) and
# I don't really believe that perl is going to give it what it
# wants.
# 
# Revision 1.2  92/01/30  16:18:33  hartzell
# reworked to work with Postgres 3.1 and Perl 4.?.
# Made sure that all PQ functions were available,
# commented out all others, whether 'cuz they're out of date,
# renamed, or not part of the public interface as defined
# by Jeff Meredith (e.g. don't begin with PQ) varies.
# 
# Revision 1.1  1992/01/18  02:14:01  hartzell
# Initial revision
#
Revision 1.2  91/03/08  13:22:32  kemnitz
added RCS header.

Revision 1.1  90/10/24  20:31:11  cimarron
Initial revision

Revision 1.1  90/08/23  15:18:20  metz
Initial revision

 * 
 */

#include "tmp/libpq.h"
#include "tmp/libpq-fe.h"	/* superset of ones also in libpq-be.h */

#include "EXTERN.h"
#include "perl.h"

extern char *PQhost;
extern char *PQport;
extern char *PQtty;
extern char *PQoption;
extern char *PQdatabase;
extern int PQportset;
extern int PQxactid;
extern int PQtracep;

static enum uservars {
  UV_PQhost,
  UV_PQport,
  UV_PQtty,
  UV_PQoption,
  UV_PQdatabase,
  UV_PQportset,
  UV_PQxactid,
  UV_PQtracep
};

static enum usersubs {
  US_PQFlushI,
  US_PQclear,
  US_PQdb,
  US_PQendcopy,
  US_PQexec, 
  US_PQfinish,
  US_PQfn,
  US_PQfname,
  US_PQfnameGroup,
  US_PQfnumber,
  US_PQfnumberGroup,
  US_PQftype,
  US_PQgetgroup,
  US_PQgetline,
  US_PQgetvalue,
  US_PQgroup,
  US_PQnfields,
  US_PQnfieldsGroup,
  US_PQngroups,
  US_PQninstances,
  US_PQninstancesGroup,
  US_PQnportals,
  US_PQntuples,
  US_PQntuplesGroup,
  US_PQparray,
  US_PQpnames,
  US_PQputline,
  US_PQreset,
  US_PQrulep,
  US_PQsametype,
  US_PQsetdb,
  US_PQtrace,
  US_PQuntrace,
};

static
unsigned int
dbl2uint(d)
     double d;
{
  unsigned int i = d;
  return i;
}

static
double
uint2dbl(i)
     unsigned int i;
{
  double d = i;
  return d;
}


static int usersub();
static int userset();
static int userval();

extern void
init_postgres_stuff()
{	
  struct ufuncs uf;
  char *filename = "libpq.c";

  uf.uf_set = userset;
  uf.uf_val = userval;

#define MAGICVAR(name, ix) uf.uf_index = ix, magicname(name, &uf, sizeof uf)

  /* register PG variables */
  MAGICVAR("PQhost",		UV_PQhost);
  MAGICVAR("PQport",		UV_PQport);
  MAGICVAR("PQtty",		UV_PQtty);
  MAGICVAR("PQoption",		UV_PQoption);
  MAGICVAR("PQdatabase",	UV_PQdatabase);
  MAGICVAR("PQportset",		UV_PQportset);
  MAGICVAR("PQxactid",		UV_PQxactid);
  MAGICVAR("PQtracep",		UV_PQtracep);

  /* register PG functions */
  make_usub("PQFlushI",		US_PQFlushI,		usersub, filena
me);
  make_usub("PQclear",		US_PQclear,		usersub, filename);
  make_usub("PQdb",		US_PQdb,		usersub, filename);
  make_usub("PQendcopy",	US_PQendcopy,		usersub, filename);
  make_usub("PQexec",		US_PQexec,		usersub, filename);
  make_usub("PQfinish",		US_PQfinish,		usersub, filena
me);
  make_usub("PQfn",		US_PQfn,		usersub, filename);
  make_usub("PQfname",		US_PQfname,		usersub, filename);
  make_usub("PQfnameGroup",	US_PQfnameGroup,	usersub, filename);
  make_usub("PQfnumber",	US_PQfnumber,		usersub, filename);
  make_usub("PQfnumberGroup",	US_PQfnumberGroup,	usersub, filename);
  make_usub("PQftype",		US_PQftype,		usersub, filename);
  make_usub("PQgetgroup",	US_PQgetgroup,		usersub, filename);
  make_usub("PQgetline",	US_PQgetline,		usersub, filename);
  make_usub("PQgetvalue",	US_PQgetvalue,		usersub, filename);
  make_usub("PQgroup",		US_PQgroup,		usersub, filename);
  make_usub("PQnfields",	US_PQnfields,		usersub, filename);
  make_usub("PQnfieldsGroup",	US_PQnfieldsGroup,	usersub, filename);
  make_usub("PQngroups",	US_PQngroups,		usersub, filename);
  make_usub("PQninstances",	US_PQninstances,	usersub, filename);
  make_usub("PQninstancesGroup", US_PQninstancesGroup,  usersub, filename);
  make_usub("PQnportals",	US_PQnportals,		usersub, filename);
  make_usub("PQntuples",	US_PQntuples,		usersub, filename);
  make_usub("PQntuplesGroup",	US_PQntuplesGroup,	usersub, filename);
  make_usub("PQparray",		US_PQparray,		usersub, filena
me);
  make_usub("PQpnames",		US_PQpnames,		usersub, filena
me);
  make_usub("PQputline",	US_PQputline,		usersub, filename);
  make_usub("PQreset",		US_PQreset,		usersub, filename);
  make_usub("PQrulep",		US_PQrulep,		usersub, filename);
  make_usub("PQsametype",	US_PQsametype,		usersub, filename);
  make_usub("PQsetdb",		US_PQsetdb,		usersub, filename);
  make_usub("PQtrace",		US_PQtrace,		usersub, filename);
  make_usub("PQuntrace",	US_PQuntrace,		usersub, filename);
}

static int
usersub(ix, sp, items)
     int ix;
     register int sp;
     register int items;
{
  STR **st = stack->ary_array + sp;
  register int i;
  register char *tmps;
  register STR *Str;		/* used in str_get and str_gnum macros */

  switch (ix) {
/*
 * Used for flushing out "poll" queries by the monitor.
 */
CASE int PQFlushI
I int i_count
END

/*
 * free storage claimed by named portal.
 */
CASE void PQclear
I char* pname
END

/*
 * Return the current database being accessed.
 */
CASE char* PQdb
END

/*
 * returns 1 if all's well?
 */
CASE int PQendcopy
END

/*
 * Send a query to the POSTGRES backend.
 * The return value is a string.
 * If there is an error: return "E error-message".
 * If tuples are fetched from the backend, return "P portal-name".
 * If a query is executed successfully but no tuples fetched,
 * return "C query-command".
 */
CASE char* PQexec 
I  char* query
END

/*
 * Close communication ports with the backend.
 */
CASE void PQfinish 
END

/*
 * Send a function call to the POSTGRES backend.
 *
 * fnid         : function id
 * result_buf   : pointer to result buffer (&int if integer)
 * result_len   : length of return value.
 * result_is_int: If the result is an integer, this must be non-zero
 * args         : pointer to a NULL terminated arg array.
 *                      (length, if integer, and result-pointer)
 * nargs        : # of arguments in args array.
 */
CASE char* PQfn 
I int         fnid
I void*       result_buf
I int         result_len
I int         result_is_int
I PQArgBlock* args
I int         nargs
END

/*
 * Return the name of a field.
 */
CASE char* PQfname
I PortalBuffer* portal
I int           tuple_index
I int 		field_number
END

/* Return the field (attribute) name given the group index
 * and field index.
 */
CASE char* PQfnameGroup
I PortalBuffer* portal
I int           group_index
I int           field_number
END

/*
 * Return the field index of a given field name within a tuple.
 */
CASE int PQfnumber
I PortalBuffer* portal
I int           tuple_index
I char*         field_name
END

/* Return the field number (index) given the group index and
 * the field name.
 */
CASE int PQfnumberGroup
I  PortalBuffer* portal
I int            group_index
I char*          field_name
END

/*
 * Return the type of a field.
 */
CASE int PQftype
I PortalBuffer* portal
I int           tuple_index
I int 		field_number
END

/*
 * Return the index of the group that a particular tuple is in.
 */
CASE int PQgetgroup
I PortalBuffer* portal
I int           tuple_index
END

/* 
 * USER FUNCTION - gets a newline-terminated string from the backend.
 */
CASE int PQgetline
IO char* s
I int    maxlen
END

/* 
 * Return an attribute (field) value.
 */
CASE char* PQgetvalue
I PortalBuffer* portal
I int           tuple_index
I int 		field_number
END

/*
 * Return the tuple group that a particular tuple is in.
 */
CASE GroupBuffer* PQgroup
I PortalBuffer* portal
I int           tuple_index
END

/*
 * Return the number of fields in a tuple.
 */
CASE int PQnfields
I PortalBuffer* portal
I int           tuple_index
END

/*
 * Return the number of fields in a tuple group.
 */
CASE int PQnfieldsGroup
I  PortalBuffer* portal
I int            group_index
END

/*
 * Return the number of tuple groups in a portal buffer.
 */
CASE int PQngroups
I  PortalBuffer* portal
END

/*
 *
 */
CASE int PQninstances
I PortalBuffer* portal
END

/*
 *
 */
CASE int PQninstancesGroup
I PortalBuffer* portal
I int           group_index
END

/* 
 * Return the number of open portals. 
 * If rule_p, only return asynchronized portals. 
 */
CASE int PQnportals
I int rule_p
END

/*
 * Return the number of tuples in a portal buffer.
 */
CASE int PQntuples
I  PortalBuffer* portal
END

/*
 * Return the number of tuples in a tuple group.
 */
CASE int PQntuplesGroup
I  PortalBuffer* portal
I int            group_index
END

/*
 * Return the portal buffer given a portal name.
 */
CASE PortalBuffer* PQparray
I char* pname
END

/* 
 * Return all the portal names.
 * If rule_p, only return asynchronized portals. 
 */
CASE void PQpnames
I char** pnames
I int    rule_p
END

/*
 * USER FUNCTION - sends a string to the backend.
 */
CASE int PQputline
I char* s
END

/*
 * Reset the communication port with the backend.
 */
CASE void PQreset 
END

/*
 * Return 1 if an asynchronized portal.
 */
CASE int PQrulep
I  PortalBuffer* portal
END

/* Return 1 if the two tuples have the same type (in the
 * same group).
 */
CASE int PQsametype
I PortalBuffer* portal
I int           tuple_index1
I int           tuple_index2
END

/*
 * Make the specified database the current database.
 */
CASE void PQsetdb 
I  char* dbname
END

/*
 * turn on pqdebug() tracing.
 */
CASE void PQtrace 
END

/*
 * turn off pqdebug() tracing.
 */
CASE void PQuntrace 
END

  default:
    fatal("Unimplemented user-defined subroutine");
  }
  return sp;
}

static int
userval(ix, str)
     int ix;
     STR *str;
{
  switch (ix) {
  case UV_PQhost:
    str_set(str, PQhost);
    break;
  case UV_PQport:
    str_set(str, PQport);
    break;
  case UV_PQtty:
    str_set(str, PQtty);
    break;
  case UV_PQoption:
    str_set(str, PQoption);
    break;
  case UV_PQdatabase:
    str_set(str, PQdatabase);
    break;
  case UV_PQportset:
    str_numset(str, PQportset);
    break;
  case UV_PQxactid:
    str_numset(str, PQxactid);
    break;
  case UV_PQtracep:
    str_numset(str, PQtracep);
    break;
  }
  return 0;
}

static int
userset(ix, str)
     int ix;
     STR *str;
{
  switch (ix) {
  case UV_PQhost:
    strcpy(PQhost, str_get(str));		/* hope it fits */
    break;
  case UV_PQport:
    strcpy(PQport, str_get(str));		/* hope it fits */
    break;
  case UV_PQtty:
    strcpy(PQtty, str_get(str));		/* hope it fits */
    break;
  case UV_PQoption:
    strcpy(PQoption, str_get(str));		/* hope it fits */
    break;
  case UV_PQdatabase:
    strcpy(PQdatabase, str_get(str));		/* hope it fits */
    break;
  case UV_PQportset:
    PQportset = dbl2uint(str_gnum(str));
    break;
  case UV_PQxactid:
    PQxactid = dbl2uint(str_gnum(str));
    break;
  case UV_PQtracep:
    PQtracep = dbl2uint(str_gnum(str));
    break;
  }
  return 0;
}
