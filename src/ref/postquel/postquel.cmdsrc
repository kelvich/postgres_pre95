.\" XXX standard disclaimer belongs here....
.\" $Header$
.SP POSTQUEL POSTQUEL 6/14/90
.XA 0 "Section 4 \*- \*(PQ Commands (\*(PQ)" _
.XA 1 "General Information"
.uh DESCRIPTION
.lp
The following is a description of the general syntax
of \*(PQ.
Individual 
\*(PQ
statements and commands
are treated separately in the document;
this section describes the syntactic classes from which the constituent
parts of 
\*(PQ
statements are drawn.
.uh Comments
.lp
A
.i comment
is an arbitrary sequence of characters
bounded on the left by
``/*''
and on the right by
``*/'', e.g:
.(l
/* This is a comment */
.)l
.uh "Names"
.lp
.i Names
in \*(PQ
are sequences of not more than 16 alphanumeric
characters, starting with an alphabetic.
Underscore (\^_\^) is considered
an alphabetic.
.uh "Keywords"
.lp
The following identifiers are reserved for use as
.i keywords
and may not be used otherwise:
.lp
.s3
.ft B
.if n .ta 5 18 31 44
.if t .ta 0.5i 1.8i 3.1i 4.4i
.de xx
\t\\$1\t\\$2\t\\$3\t\\$4
.br
..
.xx abort define is relation 
.xx addattr delete key remove 
.xx after demand leftouter rename 
.xx all descending light replace 
.xx always destroy load retrieve 
.xx and destroydb merge returns 
.xx append do move rewrite 
.xx arch_store empty never rightouter 
.xx archive end new rule 
.xx arg execute none sort 
.xx ascending fetch nonulls stdin 
.xx attachas forward not stdout 
.xx backward from NULL store 
.xx before function on to 
.xx begin heavy once transaction 
.xx binary in operator type 
.xx by index or union 
.xx c indexable output_proc unique 
.xx cfunction inherits parallel using 
.xx close input_proc pfunction vacuum 
.xx cluster instance portal version 
.xx copy instead postquel view 
.xx create intersect priority where 
.xx createdb into purge with 
.xx current intotemp quel
.ft
.dt
.lp
In addition,
all \*(PP classes have several predefined attributes used
by the system.
For a list of these,
see the section
.b Fields ,
below.
.lp
.uh "Constants"
.lp
There are six types of
.i constants
for use in \*(PQ.
They are described below.
.uh  "Character Constants"
.lp
Single
.i "character constants"
may be used in \*(PQ by 
surrounding them by single
quotes, e.g., `n'.
.uh "String Constants"
.lp
.i Strings
in \*(PQ
are arbitrary sequences of 
ASCII characters bounded by
double quotes (\*(lq \*(rq)
Upper case alphabetics within strings
are accepted literally.
Non-printing characters may be embedded within strings by prepending them
with a backslash, e.g., `\en'.
Also, in order to embed quotes
within strings, it is necessary to prefix them with `\e' .
The same convention applies to `\e' itself.
Because of the current limitations on tuple sizes, string constants
are currently limited to a length of a little less than 8K bytes.
These size constraints will be removed when large-object support
becomes stable (this is one of the goals of POSTGRES version 3).
.uh "Integer Constants"
.lp
.i "Integer constants"
in \*(PQ are collection of ASCII digits with no decimal point.
Legal
values 
range from \(mi2147483647
to +2147483647.
This will vary depending on the operating system and host machine.
.uh  "Floating Point Constants"
.lp
.i "Floating point constants"
consist of an integer part, a decimal point, and
a fraction part or scientific notation
of the following format:
.(l
{<dig>} .{<dig>} [e [+-] {<dig>}]
.)l
.lp
Where <dig> is a digit.
You must include at least one <dig> after the period and after the
[+-] if you use those options.
An exponent with a missing mantissa has a mantissa
of 1 inserted.
There may be no extra characters embedded in the string.
Floating constants
are taken to be double-precision quantities with a range of
approximately
.if n -10**38 to +10**38
.if t \(mi10\x'-0.2v'\u\s-3\&38\s0\d to 10\u\x'-0.2v'\s-3\&38\s0\d
and a precision of 17 decimal digits.
This will vary depending on the operating system and host machine.
.uh "Constants of Postgres User Defined Types"
.lp
A constant of an
.i arbitrary
type can be entered using the notation:
.(l
\*(lqstring\*(rq  :: type-name
.)l
In this case the value inside the string is passed to the input conversion
routine for the type called type-name. The result is a constant of the
indicated type.
.lp
.uh "Array constants"
.lp
.i "Array constants"
are arrays of any Postgres type, including other arrays, string constants,
etc.  The general format of an array constant is the following:
.(l
"{<val1><delim><val2<delim>}"
.)l
.lp
An example of an array constant is
.lp
.(l
"{{1,2,3},{4,5},{6,7,8,9}}"
.)l
.lp
This constant is an array consisting of three sub-arrays of integers.
.lp
.uh "Fields"
.lp
A 
.i field
is one of the following:
.(l
attribute name in a given class
all
oid
tmin
tmax
xmin
xmax
cmin
cmax
vtype
.)l
As in \*(II, 
.i all
is a shorthand for all normal attributes in a class, and may be used
profitably in the target list of a retrieve statement.  
.i Oid
stands for the unique identifier of an instance which is added by \*(PP to
all instances automatically. Oids are not reused and are 32 bit quantities.
.lp
.i "Tmin, tmax, xmin, cmin, xmax"
and
.i cmax
stand respectively for the time that the instance was inserted, the time
the instance was deleted, the identity of the inserting transaction, 
the command identifier within the transaction,
the identity of the deleting transaction and
its associated deleting command.  For further information
on these fields consult [STON87].  Times are represented internally
as instances of the 
.q "abstime"
data type.  Transaction identifiers are
40 bit quantities which are assigned sequentially
starting at 1.  Command identifiers are 8 bit objects;
hence, it is an error
to have more than 256 \*(PQ commands within one transaction.
.uh "Attributes"
.lp
An
.i attribute
is a construct of the form:
.(l
Instance-variable{.composite_field}.field `['number`]'
.)l
.i Instance-variable 
identifies a particular class and can be thought of
as standing for the instances of that class.
An instance variable is either a class name, a
surrogate for a class defined by means of a
.i from
clause, or the keyword 
.b new
or 
.b current.
New and current can only appear in the action portion of a rule, while other instance
variables can be used in any POSTQUEL command. 
.i Composite_field
is a field of of one of the POSTGRES composite types indicated in the 
.b information
(POSTQUEL) section,
while successive
composite fields address attributes
in the class(s) to which the composite field evaluates.
Lastly, 
.i field
is a normal (base type) field in the class(s) last addressed.
If
.i field 
is of type array, then the optional
.i number 
designator indicates a specific element in the array.  If no
number is indicated, then all array elements are returned.
.uh "Operators"
.lp
Any built-in system, or user defined operator
may be used in \*(PQ.  For the
list of built-in and system operators consult
.b built-in types 
(postquel) and
b. system types
(postquel).
For a list of user defined
operators consult your system administrator or run a query on the
OPERATOR class.
Parentheses may be used for arbitrary grouping of operators.
.uh "Expressions (a_expr)"
.lp
An
.i expression
is one of the following:
.(l
( a_expr )
constant
attribute
a_expr binary_operator a_expr
.\" a_expr right_unary_operator
left_unary_operator a_expr

parameter
functional expressions 
aggregate expression  (not in Version 3.0)
class expression (not in Version 3.0)
.)l
We have already discussed constants and attributes.
The two kinds
of operator expressions indicate respectively binary and
left_unary expressions.
The following sections discuss the remaining
options.
.uh "Parameters"
.lp
A 
.i parameter
is used to indicate a parameter in a \*(PQ command.  Typically this
is used in \*(PQ function definition statement.
The form of a parameter is:
.(l
\'$' number
.)l
.lp
For example, consider the definition of a function, DEPT, as
.(l
define \*(PQ function DEPT (char16) returning (dept) as
   retrieve (dept.all) where dept.dname = $1
.)l
.uh "Functional Expressions"
.lp
A
.i functional
.i expression
is the name of a legal \*(PQ function,
followed by its argument list enclosed in parentheses, e.g.:
.(l 
fn-name (a_expr{ , a_expr})
.)l	
For example, the following computes the square root of an employee salary.
.(l
sqrt(emp.salary)
.)l
.uh "Aggregate Expression"
.lp
.b
Aggregate expressions are not supported in Version 3.0.
.r
.lp
An
.i aggregate
.i expression
represents a simple aggregate (i.e one which
computes a single value) or an aggregate function (i.e. one which 
computes a set
of values).
The syntax is the following:
.(l
aggregate_name `{' [unique [using] opr] a_expr [from from_list]
[where qualification]`}'
.)l
Here, 
.i aggregate_name 
must be a previously defined aggregate.  The 
.i from_list 
indicates the class to be aggregated over while
.i qualification
gives restrictions which must be satisfied by the instances to be aggregated.
Next, the a_expr gives the expression to be aggregated while
the 
.i unique
tag indicates whether all values should be aggregated or just the
unique values of a_expr.
Two expressions, a_expr1 and a_expr2 are the same if
a_expr1 opr a_expr2 evaluates to true.
.lp
In the case that all instance variables used in the aggregate expression
are defined in the from list, a simple aggregate has been defined.  For
example, to sum employee salaries whose age is greater than 30, one would
write:
.(l
sum {e.salary from e in emp where e.age > 30}
.)l
or
.(l
sum {emp.salary where emp.age > 30}
.)l
In either case, \*(PP is instructed to find 
the instances in the from_list which
satisfy the qualification and then compute the aggregate of the a_expr
indicated.  
.lp
On the other hand, if there are variables used in the aggregate expression that
are not defined in the from list, e.g:
.(l
avg {emp.salary where emp.age = e.age}
.)l
then this aggregate has a value for each possible value taken on by 
e.age.  For example, the following complete query finds the
average salary of each possible employee age over 18:
.(l
retrieve (e.age, avg {emp.salary where emp.age = e.age})
   from e in emp 
   where e.age > 18
.)l
.uh "Set Expressions"
.lp
.b
Set expressions are not supported in Version 3.0.
.r
.lp
A
.i set
.i expression
defines a collection of instances from some class
and uses the following syntax:
.(l
 {target_list from from_list where qualification}
.)l
For example, the set of all employee names over 40 is:
.(l
{emp.name where emp.age > 40}
.)l
.fi
In addition, it is legal to construct set expressions which
have an instance variable which is defined outside the scope of
the expression.  For example, the following expression is the
set of employees in each department:
.(l
{emp.name where emp.dept = dept.dname}
.)l
.in .5i
Set expressions can be used in class expressions which
are defined below.
.uh "Class Expression"
.lp
.b
Class expressions are not supported in Version 3.0.
.r
.lp
A 
.i class
.i expression 
is an expression of the form:
.(l
class_constructor binary_class_operator class_constructor
unary_class_operator class_constructor
.)l
where binary_class_operator is one of the following:
.(l
union		union of two classes
intersect	intersection of two classes
\-		difference of two classes
>>		left class contains right class
<<		right class contains left class
==		right class equals left class 
.)l
and unary_class_operator can be:
.in .5i
.(l
empty		right class is empty
.)l
.fi
A 
.i class_constructor 
is either an instance variable, 
a class name, the value of a composite field or a set expression.
.lp
An example of a query with a class expression is
one to find all the departments with no employees:
.in .5i
.(l
retrieve (dept.dname)
   where empty {emp.name where emp.dept = dept.dname}
.)l  
.uh "Target_list"
.lp
A
.i "target list"
is a parenthesized, comma-separated list of one
or more elements, each of which must be of the form:
.(l
[result_attname  =] a_expr
.)l
Here, result_attname 
is the name of the attribute to be created (or an
already existing attribute name in the case of update statements.)
If result_attname is not present, then a_expr must 
contain only one attribute name
which is assumed to be the name of the result field.
In Version 3.0 default naming is only used if the a_expr is an attribute.
.uh "Qualification"
.lp
A 
.i qualification 
consists of any number of clauses connected
by the logical operators:
.(l
and
and not
or
or not
.)l
A clause is an a_expr that evaluates to a Boolean over a set of instances.
.ul
Not
followed by a qualification is a legal qualification.
.uh "From List"
.lp
The 
.i from
.i list
is a comma-separated list of 
.i from
.i expressions.
.lp
Each 
.i from
.i expression
is of the form:
.(l
instance_variable-1 {, instance_variable-2} in class_reference
.)l
where 
.i class_reference
is of the form
.(l
class_name [time_expression] [*]
.)l
The 
.i from
.i expression
defines one or more instance variables to range over the class indicated
in class_reference.  
Adding
a time_expression will indicate that
a historical class is desired.  Additionally, one can request the instance variable to range over all
classes that are beneath the indicated class in the inheritance
hierarchy by postpending the designator `*'.
.uh "Time Expressions"
.lp
A
.i time
.i expression
is in one of two forms:
.(l
 [date]
 [date-1, date-2]
.)l
The first case requires instances that are valid
at the indicated time.
The second case requires instances that are valid at some time within
the date range specified.
If no time expression is indicated, the
default is \*(lqnow\*(rq.  
.lp
In each case,
the date is a character string
of the form
.(b
``MMM DD [HH:MM:SS] YYYY''
.)b
where MMM is the month (Jan \- Dec),
DD is a legal day number in the specified month,
HH:MM:SS is an optional time in that day (24-hour clock),
and YYYY is the year.
If the time of day HH:MM:SS is not specified,
it defaults to midnight at the start of the specified day.
In addition,
all times are interpreted as GMT.
.lp
For example,
.(b
[``Jan 1 1990'']
[``Mar 3 00:00:00 1940'', ``Mar 3 23:59:59 1941'']
.)b
are valid time specifications.
.uh "SEE ALSO"
.lp
append(commands),
delete(commands),
execute(commands),
replace(commands),
retrieve(commands),
monitor(unix).
.uh BUGS
.lp
The following constructs are not available in Version 3.0:
.(l
aggregates and aggregate expressions
class expressions
set expressions
.)l
