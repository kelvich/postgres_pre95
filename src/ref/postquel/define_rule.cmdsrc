.\" XXX standard disclaimer belongs here....
.\" $Header$
.SP "DEFINE RULE" COMMANDS 6/14/90
.XA 2 "Define Rule"
.uh NAME
.lp
define rule \*(- Define a new rule
.uh SYNOPSIS
.lp
.b "define [tuple | rewrite] rule"
rule_name
[as exception to rule_name_2]
.br
.b on
event
.b to
object [[
.b from
clause]
.b where
clause]
.br
.b "do"
[
.b instead ]
.br
action
.uh DESCRIPTION
.lp
.b Define
.b rule
is used to define a new rule.
There are two implementations of the rules
system, one 
based on 
.b query
.b rewrite
and the other based on 
.b tuple-level
processing.  In general, the tuple system is more efficient
if there are many rules on a single table, each covering a small
subset of the tuples.  The rewrite system is more
efficient if large scope rules are being defined.  In version 2, the user
can optionally choose which rule system to use by specifying 
.i rewrite
or
.i tuple
in the command.  If the user does not specify which system to use, POSTGRES
defaults to using the tuple level system.  In the long run
POSTGRES will automatically decide which rules system to use and the possibility
of user selection will be removed.
.lp
Here, event is one of:
.(l
retrieve 
replace 
delete
append
.)l
Moreover, object is either:
.(l
a relation name
or
relation.column, ...., relation.column
.)l
The FROM clause, the WHERE clause, and the
action are respectively normal POSTQUEL 
FROM clauses, WHERE clauses 
and collections of POSTQUEL commands
with the following change:
.in+6
.ll-6

NEW or CURRENT can appear instead of 
a tuple variable whenever a tuple
variable is permissible in POSTQUEL.
.in-6
.ll+6
.lp
The semantics of a rule is that at the time an individual tuple is
accessed, updated, inserted or deleted, there is a CURRENT tuple (for
retrieves, replaces and deletes) and a NEW tuple (for replaces and appends).
If the event specified in the ON clause and the condition specified
in the WHERE clause are true 
for the CURRENT tuple,
then the action part of the rule is executed.  First, however, values
from fields in the CURRENT tuple and/or the NEW tuple are substituted 
for:
.(l
CURRENT.column-name
NEW.column-name
.)l
The action part of the rule executes with same command and
transaction identifier
as the user command that caused activation.  
.lp
A note of caution about POSTQUEL rules is in order.  If the same relation
name or tuple variable appears in the event, where clause 
and the action parts of a rule, they are 
all considered different tuple variables.  
More accurately, NEW and CURRENT are the only
tuple variables that are shared between these clauses.
For example the following two rules have the
same semantics: 
.(l
on replace to EMP.salary where EMP.name = "Joe"
then do replace EMP ( ...) where ...

on replace to EMP-1.salary where EMP-2.name = "Joe"
then do replace EMP-3 ( ...) where ...
.)l
.lp
Each rule can have the optional tag "instead".  Without this tag the
action will be performed in addition to the user command 
when the event 
in the condition part of the rule occurs. 
Alternately, the action part will be done instead of the user command.
.uh EXAMPLES
/* Make Sam get the same salary adjustment as Joe */
.(l
define rule example_1
on replace to EMP.salary where CURRENT.name = ``Joe''
then replace EMP (salary = NEW.salary) where EMP.name = ``Sam''
.)l
At the time Joe receives a salary adjustment, the event will become
true and Joe's current tuple and proposed new tuple are available
to the execution routines.  Hence, his new salary is substituted into the 
action part of the rule which is subsequently executed.  This 
propagates Joe's salary on to Sam.
.lp
/* Make Bill get Joe's salary when it is accessed */
.(l
define rule example_2
on retrieve to EMP.salary where CURRENT.name = ``Joe''
then replace EMP (salary = CURRENT.salary) where EMP.name = ``Bill''
.)l
.lp
/* Deny Joe access to the salary of employees in the shoe department */
.(l
define rule example_3
on retrieve to EMP.salary where CURRENT.dept = ``shoe'' and user() = ``Joe''
then do instead retrieve (salary = null)
.)l
/* The following also does the same task, somewhat more obscurely */
.(l
define rule example_4
on retrieve to EMP.salary where CURRENT.dept = ``shoe'' and user() = ``Joe''
then do replace CURRENT (salary = null)
.)l
.uh "SEE ALSO"
.lp
postquel(postquel).
.uh BUGS
.lp
Exceptions are not implemented in Version 2
.lp
The object in a POSTQUEL rule cannot be an array reference and cannot have parameters.
.lp
The rewrite system currently processes only a subset of the rule set.  Specifically, it
can only accept rules of the form:
.(l
on retrieve ...
then do [instead] retrieve ...

or
on retrieve ....
then do replace current ...
.)l

At present, 
it is not currently possible to reference the tuple variable ``NEW''
in the WHERE clause of the rule, so ``CURRENT'' is really the only
tuple-variable shared between the event and action parts of the rule.


