.\" This is -*-nroff-*-
.\" XXX standard disclaimer belongs here....
.\" $Header$
.TH "DEFINE INDEX" COMMANDS 03/12/94
.XA 2 "Define Index"
.SH NAME
define index \(em construct a secondary index
.SH SYNOPSIS
.(l M
\fBdefine\fR [\fBarchive\fR] \fBindex\fR index-name
	\fBon\fR classname \fBusing\fR am-name
	\fB(\fR attname type_class \fB)\fR
	[\fBwhere\fR qual]

\fBdefine\fR [\fBarchive\fR] \fBindex\fR index-name
	\fBon\fR classname \fBusing\fR am-name
	\fB(\fR funcname \fB(\fR attname\-1 { , attname\-i } \fB)\fR type_class \fB)\fR
.)l
.SH DESCRIPTION
This command constructs an index called
.IR index-name.
If the
.BR archive
keyword is absent,
the
.IR classname
class is indexed.  When
.BR archive
is present, an index is created on the archive class associated with
the
.IR classname
class.
.PP
.IR Am-name
is the name of the access method which is used for the index.
.PP
In the first syntax shown above, the key field for the index is
specified as an attribute name and an associated
.IR "operator class" .
An operator class is used to specify the operators to be used for a
particular index.  For example, a btree index on four-byte integers
would use the
.IR int4_ops
class; this operator class includes comparison functions for four-byte
integers.
.PP
If a
.IR qual
is given, the index will be a
.IR "partial index" ,
which will index only those instances in
.IR classname
for which the predicate specified by
.IR qual
is true.  Note that the predicate may only refer to attributes
of the indexed class,
.IR classname .
\*(PG may use a partial index as an access path only for
queries that include a restriction that implies that the predicate is true.
For example, if the index predicate is
.(C
emp.age < 30
.)C
then the index can be used for a query with the restriction
.(C
where emp.age < 25
.)C
but not for a query with the restriction
.(C
where emp.age < 40
.)C
and so forth.  Although partial indexes cannot be used to satisfy as wide
a range of queries as complete indexes, they can be constructed more quickly
and extended incrementally (see 
.IR "extend index" (commands)).
.PP
In the second syntax shown above, an index can be defined on the
result of a user-defined function
.IR funcname
applied to one or more attributes of a single class.  These
.IR "functional indices"
are primarily useful in two situations.  First, functional indices can
be used to simulate multi-key indices.  That is, the user can define a
new base type (a simple combination of, say, \*(lqoid\*(rq and
\*(lqint2\*(rq) and the associated functions and operators on this new
type such that the access method can use it.  Once this has been done,
the standard techniques for interfacing new types to access methods
(described in the \*(PG user manual) can be applied.  Second,
functional indices can be used to obtain fast access to data based on
operators that would normally require some transformation to be
applied to the base data.  For example, say you have an attribute in
class \*(lqmyclass\*(rq called \*(lqpt\*(rq that consists of a 2D
point type.  Now, suppose that you would like to index this attribute
but you only have index operator classes for 2D polygon types.  You
can define an index on the point attribute using a function that you
write (call it \*(lqpoint_to_polygon\*(rq) and your existing polygon
operator class; after that, queries using existing polygon operators
that reference \*(lqpoint_to_polygon(myclass.pt)\*(rq on one side will
use the precomputed polygons stored in the functional index instead of
computing a polygon for each and every instance in \*(lqmyclass\*(rq
and then comparing it to the value on the other side of the operator.
Obviously, the decision to build a functional index represents a
tradeoff between space (for the index) and execution time.
.PP
\*(PG Version \*(PV provides btree, rtree and hash access methods for
secondary indices.  The btree access method is an implementation of
the Lehman-Yao high-concurrency btrees.  The rtree access method
implements standard rtrees using Guttman's quadratic split algorithm.
The hash access method is an implementation of Litwin's linear
hashing.  We mention the algorithms used solely to indicate that all
of these access methods are fully dynamic and do not have to be
optimized periodically (as is the case with, for example, static hash
access methods).
.PP
The operator classes defined on btrees are
.(C
int2_ops	char2_ops	oidint2_ops
int4_ops	char4_ops	oidint4_ops
int24_ops	char8_ops	oidchar16_ops
int42_ops	char16_ops
float4_ops 	oid_ops
float8_ops 	text_ops
char_ops 	abstime_ops
.)C
The
.IR int24_ops
operator class is useful for constructing indices on int2 data, and
doing comparisons against int4 data in query qualifications.
Similarly,
.IR int42_ops
support indices on int4 data that is to be compared against int2 data
in queries.
.PP
The operator classes
.IR oidint2_ops ,
.IR oidint4_ops ,
and
.IR oidchar16_ops
represent the use of 
.IR "functional indices"
to simulate multi-key indices.
.PP
The \*(PG query optimizer will consider using btree indices in a scan
whenever an indexed attribute is involved in a comparison using one of
.(C
<    <=    =    >=    >
.)C
.PP
The operator classes defined on rtrees are
.(C
box_ops
bigbox_ops
poly_ops
.)C
Both box classes support indices on the \*(lqbox\*(rq datatype in
\*(PG.  The difference between them is that
.IR bigbox_ops
scales box coordinates down, to avoid floating point exceptions from
doing multiplication, addition, and subtraction on very large
floating-point coordinates.  If the field on which your rectangles lie
is about 20,000 units square or larger, you should use
.IR bigbox_ops .
The
.IR poly_ops
operator class supports rtree indices on \*(lqpolygon\*(rq data.
.PP
The \*(PG query optimizer will consider using an rtree index whenever
an indexed attribute is involved in a comparison using one of
.(C
<<    &<    &>    >>    @    ~=    &&
.)C
.PP
The operator classes defined on the hash access method are
.(C
char_ops	int2_ops
char2_ops	int4_ops
char4_ops	float4_ops
char8_ops	float8_ops
char16_ops	oid_ops
text_ops
.)C
.PP
The \*(PG query optimizer will consider using a hash index whenever
an indexed attribute is involved in a comparison using the
.(C
=
.)C
operator.
.SH EXAMPLES
.(C
/*
 * Create a btree index on the emp class using the age attribute.
 */
define index empindex on emp using btree (age int4_ops)
.)C
.(C
/*
 * Create a btree index on employee name.
 */
define index empname
	on emp using btree (name char16_ops)
.)C
.(C
/*
 * Create an rtree index on the bounding rectangle of cities.
 */
define index cityrect
	on city using rtree (boundbox box_ops)
.)C
.(C
/*
 * Create a rtree index on a point attribute such that we
 * can efficiently use box operators on the result of the 
 * conversion function.  Such a qualification might look 
 * like "where point2box(points.pointloc) = boxes.box".
 */
define index pointloc
	on points using rtree (point2box(location) box_ops)
.(C
/*
 * Create a partial btree index on employee salaries for
 *   employees over age 50
 */
define index empsal
	on emp using btree (salary int4_ops) where emp.age > 49
.)C
Note: if the partial-index predicate refers to an attribute of a
discrete-valued type (such as integers), it is slightly preferable to
express the predicate as, e.g., "emp.age > 49" rather than as "emp.age >= 50",
because even though both indexes would, in theory, be equally usable, \*(PG
would only be able to use a partial index with the former predicate in the
event of a query that had the exact restriction "emp.age > 49".
.SH BUGS
Archive indices are not supported in Version \*(PV.
.PP
There should be an access method designer's guide.
.PP
Indices may only be defined on a single key.  This can be hacked
around by defining special types and using the \*(PG support for
indices on functional values of attributes.
.PP
The only kind of partial index predicates \*(PG Version \*(PV
understands are those made up of boolean combinations of simple
clauses of the form
.(C
ATTR OP CONST
.)C
where ATTR is a single attribute of the indexed class, and OP is
an operator in a btree operator class defined on the types of
ATTR and CONST.  If some other form of predicate is specified,
Version \*(PV will never use the resulting partial index.
