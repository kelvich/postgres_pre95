.\" XXX standard disclaimer belongs here....
.\" $Header$
.SP "DEFINE AGGREGATE" COMMANDS 6/14/90
.XA 2 "Define Aggregate"
.uh NAME
.lp
define aggregate \*- define a new aggregate
.uh SYNOPSIS
.lp
.b "define aggregate"
agg-name [
.b as
]
.b ( sfunc1 = state-transition-function1, sfunc2 = state-transition-func2,
 finalfunc =  final-function, initcond1 = initial-condition1, 
 initcond2 = initial-condition2
.b )
.uh DESCRIPTION
.lp
An aggregate requires three functions, two
.i "state transition"
functions, T:
.(l
T( internal-state, next-data_item) ---> next-internal-state
.)l
.lp
and a
.b "final calculation"
function, C:
.(l
C(internal-state) ---> aggregate-value
.)l
.lp
These functions are required to have the following three properties:
.np
The output of each state-transition-function and the input 
of final-calculation-function must be the same type, S.
.np
The output of final-calculation-function can be of arbitrary type.
.np
The input to state-transition-function must include as its first 
argument a value of type S.  The other arguments must match the 
data types of the object being aggregated.  Therefore, aggregates 
also require two initial conditions, one for each transition 
function.
.uh EXAMPLE
.lp
The
.i average
aggregate would consist of two state
transition functions, a summer and an incrementer.  These would
hold the internal state of the aggregate through a 
running sum and and the number of values seen so far.
It might accept a new employee salary,
increment the count, and add the new salary to
produce the next state.  The state transition functions must be
passed correct initialization values.  The final calculation 
then divides the sum by the count to produce the final
answer.
.lp
/* Define an aggregate for average */
.lp
define aggregate avg ( sfunc1 = add-new-value-function,  sfunc2 =incrementer-function,
finalfunc = divide-by-total-function, initcond1 =  initial-condition-for-sum,
initcond2 = initial-condition-for-incrementer)
