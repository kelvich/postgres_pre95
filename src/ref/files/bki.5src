.\" XXX standard disclaimer belongs here....
.\" $Header$
.SP BKI FILES 6/14/90
.XA 1 "Backend Interface (BKI)"
.uh NAME
.lp
 .../src/support/{dbdb,local}.bki \*- template script
.uh DESCRIPTION
.lp
Backend Interface (BKI)
template script files are used to describe
the construction of databases.
The backend interface is a stripped-down version of postgres
intended for setting up the first database,
and other administrative tasks.
It is
.i not
intended for use by humans.
.lp
This stripped-down backend reads special ``.bki'' files.
.q XXX.bki
represents any arbitrary file name.
.i Createdb
uses this type of file to
direct the construction of the system catalogs.
(In addition,
the \*(PP super-user may run scripts directly
by running
.b backend
with commands that follow in the next section.)
.b Bakcend
interprets the sequence
of commands and macro definitions
found in template files in the manner
similar to what is described below.
In particular,
this description will be easier to understand
if the example in  .../files/global1.bki.
.lp
Commands are composed of a command
name followed by space separated arguments.
Arguments to a command which begin with
a
.q $
are treated specially.
If
.q $$
are the first two characters, then
the first
.q $
is ignored and the argument
is then processed normally.
If the
.q $
is followed by space,
then it is treated as a
.A NULL
value.
Otherwise, the characters following the
.q $
are interpreted as the name of a macro
causing the argument to be replaced with the macro's value.
It is an error for this macro to be undefined.
.lp
Macros are defined using
"define macro macro_name = macro_value"
and are undefined using 
"undefine macro macro_name"
and redefined using the same syntax as define.
.sp
Lists of general commands and macro commands
follow.
.uh "GENERAL COMMANDS"
.lp
open relname
.sp
Open the relation called relname for further manipulation.
.sp
close [relname]
.sp
Close the open relation called relname.  It is an error if 
relname is not already opened.   If no relname is given, then the 
currently open relation is closed.
.sp
print
.sp
Print the currently open relation.
.sp
insert [ oid= oid_value ] '(' value1 value2 ...')'
.sp
Insert a new tuple to the open
relation using
.ul
value1,
.ul
value2,
etc. for its attribute values and oid_value for it's OID.
If
.ul
oid
is not \*(lq0\*(rq, then this value
will be used as the tuple's
object identifier.
Otherwise, it is an error.
To let the system generate a unique object identifier (as opposed to the
"well-known" object identifiers which we specify) use 
insert '(' value1, value2, ... valuen ')' .

.sp
\&create relname '(' name1 = type1, name2 = type2,...name n = type n ')'
.sp
Create a relation named
.ul
relname
with the attributes given in parentheses.
.sp
open '('name1 = type1, name2 = type2,...name n = type n ')'
as relname
.sp
Open a relation named
.ul
relname
for writing 
but do not record its existence
in the system catalogs.  (This is primarily to aid in bootstrapping.)
.sp
\&destroy relname
.sp
Destroy the relation named
.ul
relname.
.sp
\&define index <index-name> on <relation-name> using <amname>
.br
\0\0\0with ( name_1 class_1 { , name_2 class_2 ,  ... } )
.sp
Create an index named
.ul
index_name
on the relation named
.ul
relname
using the
.ul
amname
access method.
The fields to index are called
.ul
name1,
.ul
name2,
etc. and the operator
classes to use are
.ul
class1,
.ul
class2,
etc., respectively.
.uh "MACRO COMMANDS"
.lp
define function macro_name as rettype function_name ( args )
.sp
Define a function prototype for a function named
.ul
macro_name
which has its value of type
.ul
rettype
computed from the
execution
.ul
function_name
with the
.ul
arguments
.ul
args 
declared in a C-like manner
etc.
.sp
define macro macro_name from file filename
.sp
Define a macro named
.ul
macname
which has its value 
read from the file called
.ul
filename.
.sp

.\" .uh "DEBUGGING COMMANDS"
.\" .sp
.\" .in .5i
.\" r
.\" .br
.\" Randomly print the open relation.
.\" .sp
.\" m	-1
.\" .br
.\" Toggle display of time information.
.\" .sp
.\" m	0
.\" .br
.\" Set retrievals to now.
.\" .sp
.\" m	1 Jan 1 01:00:00 1988
.\" .br
.\" Set retrievals to snapshots of the specfied time.
.\" .sp
.\" m	2 Jan 1 01:00:00 1988, Feb 1 01:00:00 1988
.\" .br
.\" Set retrievals to ranges of the specified times.
.\" Either time may be replaced with space
.\" if an unbounded time range is desired.
.\" .sp
.\" \&.A	relname natts name1 type1 name2 type2 ...
.\" .br
.\" Add attributes named
.\" .ul
.\" name1,
.\" .ul
.\" name2,
.\" etc. of
.\" types
.\" .ul
.\" type1,
.\" .ul
.\" type2,
.\" etc. to the
.\" .ul
.\" relname
.\" relation.
.\" .sp
.\" \&.RR	oldrelname newrelname
.\" .br
.\" Rename the
.\" .ul
.\" oldrelname
.\" relation to
.\" .ul
.\" newrelname.
.\" .sp
.\" \&.RA	relname oldattname newattname
.\" .br
.\" Rename the
.\" .ul
.\" oldattname
.\" attribute in the relation named
.\" .ul
.\" relname
.\" to
.\" .ul
.\" newattname.
.uh EXAMPLE
.lp
The following set of commands will create the
OPCLASS relation containing
the
.i int_ops
class as object
.i 421,
print out the relation, and then close it.
.sp
.nf
create pg_opclass (opcname=char16)
open pg_opclass
insert oid=421 (int_ops)
print
close pg_opclass

.fi
.uh "SEE ALSO"
.lp
createdb(unix),
template(files), .../src/support/backend.c
