.\" XXX standard disclaimer belongs here....
.\" $Header$
.SP BKI FILES 6/14/90
.XA 1 "Backend Interface (BKI)"
.uh NAME
.lp
 .../src/support/{dbdb,local}.bki \*- template script
.uh DESCRIPTION
.lp
Backend Interface (BKI)
template script files are used to describe
the construction of databases.
The backend interface is a stripped-down version of postgres
intended for setting up the first database,
and other administrative tasks.
It is
.i not
intended for use by humans.
.lp
This stripped-down backend reads special ``.bki'' files.
.q XXX.bki
represents any arbitrary file name.
.i Createdb
uses this type of file to
direct the construction of the system catalogs.
(In addition,
the \*(PP super-user may run scripts directly
by running
.b backend
with commands that follow in the next section.)
.b Backend
interprets the sequence
of commands and macro definitions
found in template files in the manner
similar to what is described below.
In particular,
this description will be easier to understand
if the example in  .../files/global1.bki.
.lp
Commands are composed of a command
name followed by space separated arguments.
Arguments to a command which begin with
a
.q $
are treated specially.
If
.q $$
are the first two characters, then
the first
.q $
is ignored and the argument
is then processed normally.
If the
.q $
is followed by space,
then it is treated as a
.A NULL
value.
Otherwise, the characters following the
.q $
are interpreted as the name of a macro
causing the argument to be replaced with the macro's value.
It is an error for this macro to be undefined.
.lp
Macros are defined using
"define macro macro_name = macro_value"
and are undefined using 
"undefine macro macro_name"
and redefined using the same syntax as define.
.sp
Lists of general commands and macro commands
follow.
.uh "GENERAL COMMANDS"
.lp
open classname
.sp
Open the class called
.i classname
for further manipulation.
.sp
close [classname]
.sp
Close the open class called
.i classname.
It is an error if 
.i classname
is not already opened.   If no
.i classname
is given, then the 
currently open class is closed.
.sp
print
.sp
Print the currently open class.
.sp
insert [ oid= oid_value ] '(' value1 value2 ...')'
.sp
Insert a new instance to the open
class using
.ul
value1,
.ul
value2,
etc. for its attribute values and oid_value for it's OID.
If
.ul
oid
is not \*(lq0\*(rq, then this value
will be used as the instance's
object identifier.
Otherwise, it is an error.
To let the system generate a unique object identifier (as opposed to the
"well-known" object identifiers which we specify) use 
insert '(' value1, value2, ... valuen ')' .

.sp
\&create classname '(' name1 = type1, name2 = type2,...name n = type n ')'
.sp
Create a class named
.ul
classname
with the attributes given in parentheses.
.sp
open '('name1 = type1, name2 = type2,...name n = type n ')'
as classname
.sp
Open a class named
.ul
classname
for writing 
but do not record its existence
in the system catalogs.  (This is primarily to aid in bootstrapping.)
.sp
\&destroy classname
.sp
Destroy the class named
.ul
classname.
.sp
\&define index <index-name> on <class-name> using <amname>
.br
\0\0\0with ( name_1 collection_1 { , name_2 collection_2 ,  ... } )
.sp
Create an index named
.ul
index_name
on the class named
.ul
classname
using the
.ul
amname
access method.
The fields to index are called
.ul
name1,
.ul
name2,
etc. and the operator
collections to use are
.ul
collection_1,
.ul
collection_2,
etc., respectively.
.uh "MACRO COMMANDS"
.lp
define function macro_name as rettype function_name ( args )
.sp
Define a function prototype for a function named
.ul
macro_name
which has its value of type
.ul
rettype
computed from the
execution
.ul
function_name
with the
.ul
arguments
.ul
args 
declared in a C-like manner
etc.
.sp
define macro macro_name from file filename
.sp
Define a macro named
.ul
macname
which has its value 
read from the file called
.ul
filename.
.sp

.\" .uh "DEBUGGING COMMANDS"
.\" .sp
.\" .in .5i
.\" r
.\" .br
.\" Randomly print the open class.
.\" .sp
.\" m	-1
.\" .br
.\" Toggle display of time information.
.\" .sp
.\" m	0
.\" .br
.\" Set retrievals to now.
.\" .sp
.\" m	1 Jan 1 01:00:00 1988
.\" .br
.\" Set retrievals to snapshots of the specfied time.
.\" .sp
.\" m	2 Jan 1 01:00:00 1988, Feb 1 01:00:00 1988
.\" .br
.\" Set retrievals to ranges of the specified times.
.\" Either time may be replaced with space
.\" if an unbounded time range is desired.
.\" .sp
.\" \&.A	classname natts name1 type1 name2 type2 ...
.\" .br
.\" Add attributes named
.\" .ul
.\" name1,
.\" .ul
.\" name2,
.\" etc. of
.\" types
.\" .ul
.\" type1,
.\" .ul
.\" type2,
.\" etc. to the
.\" .ul
.\" class
.\" classname.
.\" .sp
.\" \&.RR	oldclassname newclassname
.\" .br
.\" Rename the
.\" .ul
.\" oldclassname
.\" class to
.\" .ul
.\" newclassname.
.\" .sp
.\" \&.RA	classname oldattname newattname
.\" .br
.\" Rename the
.\" .ul
.\" oldattname
.\" attribute in the class named
.\" .ul
.\" classname
.\" to
.\" .ul
.\" newattname.
.uh EXAMPLE
.lp
The following set of commands will create the
OPCLASS class containing
the
.i int_ops
collection as object
.i 421,
print out the class, and then close it.
.sp
.nf
create pg_opclass (opcname=char16)
open pg_opclass
insert oid=421 (int_ops)
print
close pg_opclass

.fi
.uh "SEE ALSO"
.lp
createdb(unix),
template(files), .../src/support/backend.c
