.\" This is -*-nroff-*- with tbl and -me macros
.\" 
.\" POSTGRES Data Base Management System
.\" 
.\" Copyright (c) 1988 Regents of the University of California
.\" 
.\" Permission to use, copy, modify, and distribute this software and its
.\" documentation for educational, research, and non-profit purposes and
.\" without fee is hereby granted, provided that the above copyright
.\" notice appear in all copies and that both that copyright notice and
.\" this permission notice appear in supporting documentation, and that
.\" the name of the University of California not be used in advertising
.\" or publicity pertaining to distribution of the software without
.\" specific, written prior permission.  Permission to incorporate this
.\" software into commercial products can be obtained from the Campus
.\" Software Office, 295 Evans Hall, University of California, Berkeley,
.\" Ca., 94720.  The University of California makes no representations
.\" about the suitability of this software for any purpose.  It is
.\" provided "as is" without express or implied warranty.
.\" 
.\" ----------------------------------------------------------------
.\" 
.\" The POSTGRES User Manual
.\" 
.\" $Header$
.\" 
.\" ----------------------------------------------------------------
.\".he '\*(dA'DRAFT'\*(tI'		\" comment out in production version
.\"------------------------------------
.de cW					\" arg3arg1arg2, constant-width arg1
\&\\$3\\fC\\$1\\fP\\$2
.\"\&\\$3\\fC\\s-1\\$1\\s0\\fP\\$2
..
.\"------------------------------------
.de xP					\" ip for references
.ip \\$1 \\w'[STON90B]'u+2n
..
.\"------------------------------------
.de (P					\" prologue for constant-width block
.ft C
.ps -1
.vs -1
..
.\"-----------------
.de )P					\" epilogue for constant-width block
.vs +1
.ps +1
.ft P
..
.\"------------------------------------
.de (T					\" prologue for constant-width table
.(P
.in +\\n(biu
..
.\"-----------------
.de )T					\" epilogue for constant-width table
.in -\\n(biu
.)P
..
.\"------------------------------------
.de (C					\" begin constant-width list
.(l
.(P
..
.\"-----------------
.de )C					\" end constant-width list
.)P
.)l
..
.\"---------------------------------------------------------------------------
.    ds II \s-1INGRES\s0
.    ds PP \s-1POSTGRES\s0
.    ds UU \s-1UNIX\s0
.    ds PQ \s-1POSTQUEL\s0
.    ds LP \s-1LIBPQ\s0
.    ds PV \s-14.2\s0
.    ds OF \s-1PICASSO\s0
.\"------------------------------------
.ps 11
.vs 13
.\"-----------------
.nr pp \n(.s
.nr sp \n(.s+1				\" +1-pt section headers
.\"-----------------
.nr bs 1v
.nr ps 0.3v
.nr ss 1v
.\"-----------------
.fo ''\\s+2%\\s0''			\" +2-pt page numbers in center footers
.\"-----------------
.nr $i .5i				\" main text indented
.nr so -\n($i				\" section headers un-indented
.\"------------------------------------
.rm xX					\" scratch register
.\"------------------------------------
.\"!Gexpand
.\"---------------------------------------------------------------------------
.(l C
.b
\s+3The \*(PP User Manual\s0
.sp 2
.i
Edited by Paul M. Aoki, Jim Frew and The \*(PP Group
Computer Science Div., Dept. of EECS
University of California at Berkeley
.r
.)l
.sp 3
.\"---------------------------------------------------------------------------
.sh 1 "INTRODUCTION"
.lp
This document is the user manual for the \*(PP database system under
development at the University of California at Berkeley.  This
project, led by Professor Michael Stonebraker, is sponsored by the
Defense Advanced Research Projects Agency (DARPA), the Army Research
Office (ARO), the National Science Foundation (NSF), and ESL, Inc.
.\"------------------------------------
.sh 2 "An Overview of \*(PP"
.lp
Traditional relational database management systems (DBMSs) support a
data model consisting of a collection of named relations, each
attribute of which has a specific type.  In current commercial
systems, possible types including floating point numbers, integers,
character strings, money, and dates.  It is commonly recognized that
this model is inadequate for future data processing applications.
.lp
The relational model succeeded in replacing previous models in part
because of its simplicity.  However, as mentioned, the 
.q "Spartan simplicity"
of the relational model often makes the implementation of certain
applications very difficult.  The \*(PP data model offers
substantial additional power by incorporating the following four
additional basic constructs:
.(l
classes
inheritance
types
functions
.)l
in such a way that users can easily extend the system.  In addition,
\*(PP supports a powerful production rule system.
.\"------------------------------------
.sh 2 "Status of the \*(PP Project"
.lp
The \*(PP DBMS has been under construction since 1986.  The initial
concepts for the system were presented in [STON86] and the definition
of the initial data model appeared in [ROWE87].  The first rule system
that was implemented is discussed in [STON87a] and the storage manager
concepts are detailed in [STON87b].  The first
.q demo-ware
was operational in 1987, and we released Version 1 of \*(PP to a few
external users in June 1989.  A critique of the first rule system
followed in [STON89].  A detailed description of Version 1 of \*(PP
appeared in [STON90a].  Version 2 was released in June 1990 and
included the new rule system documented in [STON90b].  Version \*(PV,
the current version of \*(PP, is about 200,000 lines of code in the C
programming language.  \*(PP is available free of charge, and is being
used by approximately 500 sites around the world.
.lp
This manual describes Version \*(PV of \*(PP.  The \*(PP Group has
compiled and tested Version \*(PV on the following platforms:
.TS
center tab(|);
c | c
l | l .
architecture (processor)|operating system
=
DECstation 3000 (Alpha AXP)|OSF/1 1.3
DECstation 3100 and 5000 (MIPS)|ULTRIX 4.2, 4.3a
Sun4 (SPARC)|SunOS 4.1.2, 4.1.3
H-P 9000/700 (PA-RISC)|HP-UX 9.01
IBM RS/6000 (POWER)|AIX 3.2.3
.TE
.(f
\*(UU is a trademark of Unix Systems Laboratories, Inc..  SPARC, SunOS
and Solaris are trademarks of Sun Microsystems, Inc.  DECstation,
Alpha AXP and ULTRIX are trademarks of Digital Equipment Corp.
PA-RISC and HP-UX are trademarks of Hewlett-Packard Co.  RS/6000,
POWER and AIX are trademarks of International Business Machines.
.)f
Previous versions of \*(PP ran on Sun Microsystems Sun3 and Sequent
Symmetry machines.  \*(PP no longer runs on these systems, nor does it
run on Sun Microsystems computers running the Solaris 2 (SunOS 5)
operating system.
.lp
Version \*(PV has been tuned modestly.  On the Wisconsin benchmark,
one should expect performance about twice that of the public domain,
University of California version of \*(II, a relational prototype from
the late 1970s.
.\"------------------------------------
.sh 2 "Acknowledgements"
.lp
\*(PP has been constructed by a team of undergraduate,
graduate, and staff programmers.
The contributors (in alphabetical order) include:
Jeff Anton,
Paul Aoki,
James Bell,
Jennifer Caetta,
Philip Chang,
Jolly Chen,
Ron Choi,
Bob Devine,
Matt Dillon,
Zelaine Fong,
Adam Glass,
Jeffrey Goh,
Steven Grady,
Serge Granik,
Marti Hearst,
Joey Hellerstein,
Michael Hirohama,
Chin-heng Hong,
Wei Hong,
Anant Jhingran,
Greg Kemnitz,
Case Larsen,
Boris Livshitz,
Jeff Meredith,
Michael Olson,
Nels Olson,
Lay-Peng Ong,
Carol Paxson,
Avi Pfeffer,
Spyros Potamianos,
Sunita Sarawagi,
David Muir Sharnoff,
Cimarron Taylor,
Marc Teitelbaum,
Yongdong Wang,
Kristin Wright
and
Andrew Yu.
The HP-UX port is courtesy of Richard Turnbull (University of
Liverpool) and Sebastian Fernandez (University of California at
Berkeley).  The initial AIX port was performed by Rafael Morales
Gamboa (ITESM Campus Morelos, Cuernavaca).
.lp
For version \*(PV, Marc Teitelbaum served as chief programmer and was
responsible for overall coordination of the project.
.lp
This manual is a substantial rewrite of a previous version edited by
Jon Rhein and Greg Kemnitz.  The above implementation team contributed
significantly to this manual and its predecessor, as did Michael
Stonebraker, Chandra Ghosh and Claire Mosher.
.\"---------------------------------------------------------------------------
.sh 1 "WHAT YOU SHOULD READ"
.lp
This manual is primarily intended to provide a broad overview of the
system, as well as to illustrate how programmers would use functions
to interact with the \*(PP database server (commonly referred to as
the
.q backend ).
.lp
In addition to this manual, there is another document, the \*(PP
Reference Manual.  The Reference Manual fully describes the syntax and
options for each command in a format similar to that used in \*(UU
.q "man pages."
The Reference Manual is designed as a complete reference for the
experienced \*(PP user and contains few tutorial examples.  This
manual does not attempt to provide all of the information that the
Reference Manual provides.  Instead, this manual describes the major
.i concepts
of the system, gives
.i examples
of the use of the major constructs, and then provides
.i pointers
to the appropriate place in the Reference Manual in which you can find
more information if you so desire.
.lp
If you are new to \*(PP, you should probably read this manual first,
followed by the parts of the \*(PP Reference Manual necessary to build
your application.  In particular, you should read the Reference Manual
section on \*(LP if you intend to build a client application around
\*(PP, as this is not discussed at all in this manual.
.\"---------------------------------------------------------------------------
.sh 1 "ORGANIZATION"
.lp
The first part of this manual goes over some basic system concepts and
procedures for starting the \*(PP system.  We then turn to an overview
of the \*(PQ query language.  Next, we describe user extensions such
as user-defined types, operators, aggregates, and both query language
and programming language functions.  This is followed by an extremely
brief overview of the \*(PP rule system.  The manual concludes with a
series of detailed appendices that discuss some of the more involved
procedures involved in extending the system, such as adding an
operator class to \*(PP for use in access methods.
.\"---------------------------------------------------------------------------
.sh 1 "GETTING STARTED WITH \*(PP"
.lp
In the discussion that follows, examples that begin with the character
.cW "%" '' ``
are commands that should be typed at the \*(UU shell prompt.  Examples
that begin with the character
.cW "*" '' ``
are commands in the \*(PP query language, \*(PQ.
.\"------------------------------------
.sh 2 "Installing \*(PP"
.lp
Installation instructions can be found in the \*(PP source code
distribution.  The 
.cW troff
source is located in the file
.cW src/doc/postgres-setup.me .
Those instructions vary from release to release and will not be
duplicated here.  However, if you are installing \*(PP now, you 
.i must
read these instructions and carry them out before going any further.
.\"------------------------------------
.sh 2 "Setting Up Your Environment"
.lp
In the examples that follow, we will assume that \*(PP has been
installed in the directory
.cW /usr/local/postgres
with the default settings.  In practice, \*(PP can be installed
anywhere you like.  Throughout this document, wherever you see
.cW /usr/local/postgres
you should substitute the name of the directory where \*(PP is
actually installed.
.lp
All \*(PP commands are installed in the directory
.cW /usr/local/postgres/bin .
Therefore, you should add this directory to your shell 
.i "command path" .
If you use a variant of the Berkeley C shell, such as
.cW csh
or
.cW tcsh ,
you would put
.(C
set path = ( /usr/local/postgres/bin $path )
.)C
in the
.cW .login
file in your home directory.  If you use a variant of the Bourne
shell, such as
.cW sh ,
.cW ksh
or 
.cW bash ,
then you would put
.(C
PATH=/usr/local/postgres/bin:$PATH
export PATH
.)C
in the
.cW .profile 
file in your home directory.
.lp
From now on, we will assume that you have put the \*(PP 
.cW bin
directory in your path.  In addition, we will make frequent reference
to 
.q "setting a shell variable"
or 
.q "setting an environment variable"
throughout this document.  If you did not fully understand the last
paragraph on modifying your search path, you should consult the \*(UU
manual pages that describe your user shell before going any further.
.\"------------------------------------
.sh 2 "Starting the Postmaster"
.lp
Before we continue, you should understand the basic \*(PP system
architecture.  A \*(PP session consists of three cooperating \*(UU
processes:
.bu
the postmaster
.cW postmaster ), (
.bu
the frontend application, such as the terminal monitor
.cW monitor ), (
and
.bu
the backend database server
.cW postgres ). (
.lp
A single
.cW postmaster
process manages a given collection of 
.i databases .
Such a collection of databases is called an
.i installation .
Frontend applications that wish to access a given database within an
installation send their requests over the network to the 
.cW postmaster ,
which in turn connects each frontend application to a backend server
that responds to its queries.  Hence, the
.cW postmaster
runs all the time, waiting for requests, while the frontend and
backend processes come and go.  Another implication of this
architecture is that the
.cW postmaster
and the backend always run on the same machine (the database server),
while the frontend application may or may not be running on a
separate machine (e.g., a client workstation).
.lp
It should be clear from the preceding paragraph that nothing can
happen to a database unless the
.cW postmaster
process is running.  If you get the following error message from a
\*(PP command (such as
.cW monitor
or
.cW createdb ):
.(C
FATAL: StreamOpen: connect() failed: errno=61
FATAL: Failed to connect to postmaster (host=xxx, port=4321)
        Is the postmaster running?
.)C
it is usually because the
.cW postmaster
is not running.  Therefore, your local \*(PP site administrator should
ensure that the
.cW postmaster
is running at all times.
.lp
If you are the site administrator, there are a number of things you
should remember before starting the
.cW postmaster .
These are discussed in the section of this manual titled,
.q "Administering \*(PP."
However, if \*(PP has been installed by following the installation
instructions exactly as written, the following simple command is all
you should need to start the
.cW postmaster :
.(C
% postmaster &
.)C
If the 
.cW postmaster
does not start, but instead prints a series of cryptic error messages,
you should consult the Reference Manual under the heading
.b postmaster .
This manual page contains troubleshooting tips.
.\"------------------------------------
.sh 2 "Starting Applications"
.lp
Assuming that your site administrator has properly started the 
.cW postmaster
process, you (as a user) may begin to start up applications.  As
previously mentioned, you should add 
.cW /usr/local/postgres/bin 
to your shell search path.  In most cases, this is all you should have
to do in terms of preparation.\**
.(f
\** If your site administrator has not set things up in the default
way, you may have some more work to do.  For example, if the database
server machine is a remote machine, you will need to set the
.cW PGHOST 
environment variable to the name of the database server machine.
The environment variable
.cW PGPORT
may also have to be set.  The bottom line is this: if you try to start
an application program and it complains that it cannot connect to the
.cW postmaster ,
you should immediately consult your site administrator to make sure
that your environment is properly set up.
.)f
.\"---------------------------------------------------------------------------
.sh 1 "USING THE \*(PQ QUERY LANGUAGE"
.lp
\*(PQ is the query language used for interacting with \*(PP.  In this
section, we give an overview of how to use \*(PQ to access data.  The
next section will discuss ways in which ordinary users can extend
\*(PQ.
.\"------------------------------------
.sh 2 "Managing a Database"
.lp
Here, we describe a few basic commands for managing a database.
.\"------------------------------------
.sh 3 "Creating a Database"
.lp
Let's say you want to create a database named
.cW foo .
You can do this with the following command:
.(C
% createdb foo
.)C
\*(PP allows you to create any number of databases at a given site and
you automatically become the database administrator of the database
just created.  Database names must have an alphabetic first character
and are limited to 16 characters in length.
.lp
If \*(PP refuses to create databases for you, then the site
administrator needs to grant you permission to create databases.
Consult your site administrator if this occurs.
.\"------------------------------------
.sh 3 "Accessing a Database"
.lp
Once you have constructed a database, there are three ways to access
it:
.bu
You can run the \*(PP terminal monitor (the
.cW monitor
program) which allows you to interactively enter, edit, and execute
commands in the \*(PQ query language.
.bu
You can interact with \*(PP from a C program by using the \*(LP
subroutine library.  This allows you to submit \*(PQ commands from C
and get answers and status messages back to your program.  This
interface is discussed further in the \*(LP section of the Reference
Manual.
.bu
You can use the
.i "fast path"
facility, which allows you to directly execute functions stored in the
This facility is (minimally) described in the Reference Manual under
.q "Fast Path."
.lp
This manual will only discuss access through the terminal monitor.
.lp
The terminal monitor can be activated for the
.cW foo
database by typing the command:
.(C
% monitor foo
.)C
You will be greeted with the following message:
.(C
Welcome to the POSTGRES terminal monitor

Go
*
.)C
This prompt indicates that the terminal monitor is listening to you
and that you can type \*(PQ queries into a workspace maintained by the
terminal monitor.  White space (i.e., spaces, tabs and newlines) may
be used freely in \*(PQ queries.  You may view the current contents of
the workspace by typing:
.(C
* \\p
.)C
Once you have finished entering your queries into the workspace, you
can pass the contents of the workspace to the \*(PP server by typing:
.(C
* \\g
.)C
If you make a typing mistake, you can invoke the
.cW vi
text editor by typing:
.(C
* \\e
.)C
The workspace will be passed to the editor, and once you exit
.cW vi ,
your edited query will placed in the terminal monitor workspace.  You
can then submit the contents of the workspace to \*(PP by using the
.cW \eg
command as described above.
.lp
To get out of the monitor and return to \*(UU, type
.(C
* \\q
.)C
and 
.cW monitor
will return you to your command shell.
.lp
For a complete description of the
.cW monitor
commands and its options, see the Reference Manual under the heading
.b monitor .
.\"------------------------------------
.sh 3 "Destroying a Database"
.lp
If you are the database administrator for the database
.cW foo ,
you can destroy it using the following \*(UU command:
.(C
% destroydb foo
.)C
This action physically removes all of the \*(UU files associated with
the database and cannot be undone, so this should only be done with a
great deal of forethought.
.\"------------------------------------
.sh 2 "Basic Use of the \*(PQ Query Language"
.\"-----------------
.sh 3 "Concepts"
.lp
The fundamental notion in \*(PP is that of a
.i class,
which is a named collection of object
.i instances .
Each instance has the same collection of named
.i attributes ,
and each attribute is of a specific
.i type .
Furthermore, each instance has an installation-wide unique, permanent
.i "object identifier"
(OID).
.lp
As previously discussed, classes are grouped into databases, and a
collection of databases managed by a single
.cW postmaster
process constitutes an installation.
.\"-----------------
.sh 3 "Creating a New Class"
.lp
In the examples that follow, we assume that you have created the
.cW foo
database as described in the previous subsection and have started the
terminal monitor.
.lp
A user can create a new class by specifying the class name, along with
all attribute names and their types:
.(C
* create EMP (name = text, salary = int4,
              age = int4, dept = char16) \\g

* create DEPT (dname = char16, floor = int4,
               manager = text) \\g
.)C
The \*(PQ base types used above are a variable-length array of
printable characters
.cW text ), (
a 4-byte signed integer
.cW int4 ), (
and a fixed-length array of 16 characters
.cW char16 .) (
.lp
So far, the \*(PP
.b create
command looks exactly like the command used to create a table in a
traditional relational system.  However, we will presently see that
classes have properties that are extensions of the relational model,
so we use a different word to describe them.
.\"-----------------
.sh 3 "Populating a Class with Instances"
.\" we refer to this later
.ds xX \n($1.\n($2.\n($3
.lp
To populate a class with instances, one can use the
.b append
command:
.(C
* append EMP (name = "Joe", salary = 1400,
              age = 40, dept = "shoe") \\g

* append EMP (name = "Sam", salary = 1200,
              age = 29, dept = "toy") \\g

* append EMP (name = "Bill", salary = 1600,
              age = 36, dept = "candy") \\g
.)C
This will add 3 instances to the
.cW EMP 
class,
one for each
.b append
command.
.\"-----------------
.sh 3 "Querying a Class"
.lp
The
.cW EMP
class can be queried with normal selection and projection queries.
For example, to find the employees under 35 years of age, one would
type:
.(C
* retrieve (EMP.name) where EMP.age < 35 \\g
.)C
and the output would be:
.(T
.TS
allbox;
l.
name
Sam
.TE
.)T
Notice that parentheses are required around the
.i "target list"
of returned attributes
(e.g.,
.cW EMP.name .)
.lp
\*(PQ allows you to return arbitrary computations in the target list
as long as they are given a name (e.g.,
.cW result ):
.(C
* retrieve (result = EMP.salary / EMP.age)
      where EMP.name = "Bill" \\g
.)C
.\"-----------------
.sh 3 "Redirecting Retrieve Queries"
.lp
Any 
.b retrieve
query can be redirected to a new class in the database, and arbitrary
Boolean operators
.b and , (
.b or
and
.b not )
are allowed in the qualification of any query:
.(C
* retrieve into temp (EMP.name)
      where EMP.age < 35 and EMP.salary > 1000 \\g
.)C
.\"-----------------
.sh 3 "Joins Between Classes"
.lp
Thus far, our queries have only accessed one class at a time.  Queries
can access multiple classes at once, or access the same class in such
a way that multiple instances of the class are being processed at the
same time.  A query that accesses multiple instances of the same or
different classes at one time is called a 
.i "join query" .
.lp
As an example, say we wish to find the names of employees which are
the same age.  In effect, we need to compare the 
.cW age
attribute of each 
.cW EMP
instance to the 
.cW age
attribute of all other 
.cW EMP
instances.\**
.(f
\** This is only a conceptual model.  The actual join may be performed
in a more efficient manner, but this is invisible to the user.
.)f
We can do this with the following query:
.(C
* retrieve (E1.name, E2.name)
      from E1 in EMP, E2 in EMP
      where E1.age = E2.age and E1.name != E2.name \\g
.)C
In this case both 
.cW E1
and
.cW E2
are
.i surrogates
for an instance of the class
.cW EMP ,
and both range over all instances of the class.  (In the terminology
of most database systems, 
.cW E1
and
.cW E2
are known as
.q "range variables." )
A \*(PQ query can contain an arbitrary number of class names and
surrogates.\**
.(f
\** The semantics of such a join are that the qualification is a truth
expression defined for the Cartesian product of the classes indicated
in the query.  For those instances in the Cartesian product for which
the qualification is true, \*(PP computes and returns the values
specified in the target list.
.sp
\*(PQ does not assign any meaning to duplicate values in such
expressions.  This means that \*(PP sometimes recomputes the same
target list several times \(em this frequently happens when Boolean
expressions are connected with an
.b or .
To remove such duplicates, you must use the
.b "retrieve unique"
statement.  See the Reference Manual under
.b retrieve
for more details. 
.)f
.\"-----------------
.sh 3 "Updates"
.lp
Updates are accomplished in \*(PQ using the
.b replace
command:
.(C
* replace EMP (salary = E.salary)
      from E in EMP
      where EMP.name = "Joe" and E.name = "Sam" \\g
.)C
This command replaces the salary of Joe by that of Sam.
.lp
Notice that this example is actually another join query.  Here, we are
using the actual class name
.cW EMP '') (``
as one range variable and a surrogate name for 
.cW EMP
.cW E '') (``
as another range variable.
.\"-----------------
.sh 3 "Deletions"
.lp
Deletions are done using the
.b delete
command:
.(C
* delete EMP where EMP.salary > 0 \\g
.)C
Since all employees have positive salaries, this command will leave
the
.cW EMP
class empty.
.lp
One should be wary of queries of the form
.(C
* delete \fIclassname\fP \\g
.)C
Without a qualification, the 
.b delete
command will simply delete all instances of the given class, leaving
it empty.  The system will not request confirmation before doing this.
.\"-----------------
.sh 3 "Arrays"
.lp
.(l C
.hl
FIX ME
multidimensional
flags
other new behavior
.hl
.)l
\*(PP allows attributes of an instance to be defined as fixed-length or
variable-length multi-dimensional arrays.  To illustrate their use, we
first create a class with an array type.
.(C
* create SAL_EMP (name = char[],
                  pay_by_quarter = int4[4]) \\g
.)C
The above query will create a class named
.cW SAL_EMP
with a variable-length one-dimensional array of
.cW text
strings
.cW name ), (
and a one-dimensional array of 4
.cW int4
integers
.cW pay_by_quarter ), (
which represents the employee's salary by quarter.  Now we do some
.cW append s;
note that when appending to a non-character array, we enclose the
values within braces and separate them by commas.
.(C
* append SAL_EMP (name = "bill",
      pay_by_quarter = "{10000, 10000, 10000, 10000}") \\g

* append SAL_EMP (name = "jack",
      pay_by_quarter = "{10000, 15000, 15000, 15000}") \\g

* append SAL_EMP (name = "joe",
      pay_by_quarter = "{20000, 25000, 25000, 25000}") \\g
.)C
By default, \*(PP uses the 
.q one-based
numbering convention for arrays \(em that is, \*(PP arrays start with
array[1] and end with array[n].  (This is the same convention used in
Pascal and FORTRAN.)
.lp
Now, we can run some queries on
.cW SAL_EMP .
This query retrieves the names of the employees whose pay changed in
the second quarter:
.(C
* retrieve (SAL_EMP.name)
      where SAL_EMP.pay_by_quarter[1] !=
            SAL_EMP.pay_by_quarter[2] \\g
.)C
This query retrieves the third quarter pay of all employees:
.(C
* retrieve (SAL_EMP.pay_by_quarter[3]) \\g
.)C
This query deletes everyone from
.cW SAL_EMP
whose name begins with the letter
.q j.
.cW SAL_EMP
should now contain only the employee named
.q bill :
.(C
* delete SAL_EMP where SAL_EMP.name[1] = 'j' \\g
.)C
Let's make sure (note that the attribute
.cW all
may be used as a shorthand for all attributes of a class):
.(C
* retrieve (SAL_EMP.all) \\g
.TS
allbox tab(|);
l l.
name|pay_by_quarter
bill|{10000,10000,10000,10000}
.TE
.)C
\*(PP supports arrays of base and user-defined types, as well as
.q "arrays of arrays,"
as in the following example:
.(C
* create manager (name = char16, employees = text[]) \\g

* append manager (name = "mike",
                  employees = "{"wei", "greg", "jeff"}") \\g

* append manager (name = "alice",
                  employees = "{"bill", "joe"}") \\g

* append manager (name = "marge",
                  employees = "{"mike", "alice"}") \\g
.)C
This creates a class
.cW manager ,
and provides a list of employees.
.\"-----------------
.sh 3 "Aggregate Functions"
.lp
Like relational query languages such as SQL, \*(PP supports aggregate
functions.  However, the current implementation of \*(PP aggregate
functions is very limited.  Specifically, while there are aggregates
to compute such functions as the count, sum, average, maximum and
minimum over a set of instances, aggregates can only appear in the
target list of a query and not in the qualification (also known as the
.cW where
clause).  As an example, 
.(C
* retrieve (how_many = count{EMP.name}) \\g
.)C
counts all employees, and 
.(C
* retrieve (avg_salary = 
      int4ave{EMP.salary
              where EMP.dept = "toy"}) \\g
.)C
computes the average salary of all employees in the toy department.
However, the following query (to find out who makes more money than
any of the toy department employees) will
.i not
work:
.(C
* retrieve (EMP.name) where
      EMP.salary > int4max{EMP.salary 
                           where EMP.dept = "toy"} \\g
.)C
because the aggregate is not in the target list.  In addition, if the
qualification of the aggregate expression contains any join clauses
(references to other classes), the aggregate may or may not return the
right result.  (In other words, aggregates with join clauses are
neither disallowed nor are they supported.)
.\"-----------------
.sh 3 "Help!  What Are the Valid Types, Operators, Etc.??"
.lp
So far, we have been rather cavalier in our use of types (such as 
.cW char16 ),
operators (such as
.cW < ),
and aggregate functions (such as 
.cW count ).
A large number of pre-defined types, operators and aggregates are
available by default in \*(PP, and these are listed in Section 3 of
the Reference Manual.  This would be a good time to go ahead and take
a peek at that section.
.lp
In a later section of this manual, we will describe how to query the
system to find out the current list of
.i all
valid types, operators, functions, etc. known to the system.
.\"------------------------------------
.sh 2 "Advanced \*(PQ"
.lp
Now we have covered the basics of using \*(PQ to access your data.  In
this section we will discuss those features of \*(PP which distinguish
it from other data managers, such as inheritance and time travel.  In
the next section we will cover how the user can extend the query
language via query language functions and composite objects, as well
as additional extensions to \*(PP using user-defined types, operators,
and programming language functions.
.\"-----------------
.sh 3 "Inheritance"
.lp
First, re-populate the
.cW EMP
class by repeating the
.b append
commands in section \*(xX.  Then, create a second class
.cW STUD_EMP ,
and populate it as follows:
.(C
* create STUD_EMP (location = point) inherits (EMP) \\g

* append STUD_EMP (name = "Sunita", salary = 4000,
                   age = 23, dept = "electronics",
                   location = "(3, 5)") \\g
.)C
In this case, an instance of
.cW STUD_EMP
.i inherits
all data fields
.cW name , (
.cW salary ,
.cW age ,
and
.cW dept )
from its parent,
.cW EMP .
Furthermore, student employees have an extra field,
.cW location ,
that shows their address as a coordinate pair.  In \*(PP, a class can
inherit from zero or more other classes,\**
.(f
\** I.e., the inheritance hierarchy is a directed acyclic graph.
.)f
and a query can reference either all instances of a class or all
instances of a class plus all of its descendants.  For example, the
following query finds the employees over 20:
.(C
* retrieve (E.name) from E in EMP where E.age > 20 \\g
.)C
On the other hand, to find the names of all employees, including
student employees, over age 20, the query is:
.(C
* retrieve (E.name) from E in EMP* where E.age > 20 \\g
.)C
which returns:
.(T
.TS
allbox;
l.
name
Joe
Sam
Bill
Sunita
.TE
.)T
Here the
.cW *
after
.cW EMP
indicates that the query should be run over
.cW EMP
and all classes below
.cW EMP
in the inheritance hierarchy.
.lp
Note that
.cW location
in
.cW STUD_EMP
is not a traditional relational data type.  As we will see later,
\*(PP can be customized with an arbitrary number of user-defined data
types.
.\"-----------------
.sh 3 "Time Travel"
.lp
\*(PP supports the notion of
.i "time travel" .
This feature allows a user to run historical queries.  For example, to
find Sam's current salary, one would query:
.(C
* retrieve (E.salary) from E in EMP["now"]
      where E.name = "Sam" \\g
.)C
\*(PP will automatically find the version of Sam's record valid at the
correct time and get the appropriate salary.
.lp
One can also give a time
.i range .
For example to see all the salaries that Sam has ever earned, one
would query:
.(C
* retrieve (E.salary)
      from E in EMP["epoch", "now"]
      where E.name = "Sam" \\g
.)C
where 
.q epoch
indicates the beginning of the \*(UU system clock.  If you have
executed all of the examples so far, then the above query returns:
.(T
.TS
allbox;
l.
salary
1200
1200
.TE
.)T
Notice that there are two salaries for Sam because he was deleted from
and then re-appended to the
.cW EMP
class.
.lp
The default beginning of a time range is the earliest time
representable by the system and the default end is the current time;
thus, the above time range can be abbreviated as
.cW [,] .'' ``
See Section 3 of the Reference Manual,
.b Built-Ins ,
and the introduction to Section 4,
.b \*(PQ ,
for a full description of the time types (absolute time, relative time
and time ranges).
.\"---------------------------------------------------------------------------
.sh 1 "USER EXTENSIONS TO \*(PQ"
.lp
Here, we will discuss user extensions to the \*(PQ query language,
such as:
.bu
query language functions
.bu
composite types
.bu
user-defined types, operators, functions and aggregates
.\"------------------------------------
.sh 2 "Query Language (\*(PQ) Functions"
.lp
\*(PQ provides two types of functions:
.i "query language functions"
(functions written in \*(PQ) and
.i "programming language functions"
(functions written in a separately-compiled programming language such
as C.)  In this section we will cover \*(PQ functions; programming
language functions will be covered below with the discussion on
user-defined types.
.lp
Any collection of commands in the \*(PQ query language can be packaged
together and defined as a function, usually returning either a set of
instances or a set of base types.  For example, the following function
.cW high_pay
returns all employees in class
.cW EMP
whose salaries exceed 50,000:
.(C
* define function high_pay
      (language = "postquel", returntype = setof EMP)
      as "retrieve (EMP.all) where EMP.salary > 50000" \\g
.)C
\*(PQ functions can also have parameters.  The following function
.cW large_pay
allows the threshold salary to be specified as an argument:
.(C
* define function large_pay
      (language = "postquel", returntype = setof EMP)
      arg is (int4)
      as "retrieve (EMP.all) where EMP.salary > $1" \\g
.)C
In addition to their obvious utility as
.q aliases
for commonly-used queries, \*(PQ functions are useful for creating
composite types, as described below.
.\"------------------------------------
.sh 2 "Composite Types"
.lp
Since \*(PQ functions return instances or sets of instances, they are
the mechanism used to assign values to composite types.  For example,
consider extending the
.cW EMP
class with a
.cW manager
field.
That is, for each instance of
.cW EMP ,
we want to associate another instance of
.cW EMP 
corresponding to the manager of the first instance.  Specifically, we
will define a \*(PQ function
.cW manager :
.(C
* define function manager
      (language = "postquel", returntype = EMP)
      arg is (EMP)
      as "retrieve (E.all) from E in EMP
              where E.name = DEPT.manager
              and DEPT.dname = $1.dept" \\g
.)C
The function
.cW manager
takes an instance as its only argument, so \*(PQ allows referencing
into it with the use of the nested dot notation.  Whenever such a
function is defined over a class, a user can utilize the cascaded dot
notation to reference into (i.e. access the fields of) the objects
returned by the function.
.lp
The following query finds all the employees who work for Joe:
.(C
* retrieve (EMP.name) where EMP.manager.name = "Joe" \\g
.)C
This is exactly equivalent to:
.(C
* retrieve (EMP.name)
      where name(manager(EMP)) = "Joe" \\g
.)C
Here, we have essentially added an attribute to the
.cW EMP
class which is of type
.cW EMP ,
i.e., it has a value which is an instance of the class
.cW EMP .
Since the value of
.cW manager
has a record-oriented structure, we call it a
.i "composite object" .
Consequently, the user can think of the function
.cW manager
as an attribute of
.cW EMP
and can reference it just like any other attribute, with the following
two exceptions.  First, one cannot do direct
.b append s
\(em that is,
.(C
* append emp (emp.manager.name = "Smith") \\g
.)C
.i won't
work.  Non-projected retrieves will also be rejected.  For example,
.(C
* retrieve (emp.manager) \\g
.)C
will result in a warning from the \*(PQ language parser.
.lp
Note that 
.cW manager
is defined as returning a single instance of
.cW EMP.
We can also write a \*(PQ function that returns sets of instances.
For example, consider the function
.(C
* define function children
      (language = "postquel", returntype = setof KIDS)
      arg is (EMP)
      as "retrieve (KIDS.all)
              where $1.name = KIDS.dad
              or $1.name = KIDS.mom"\\g
.)C
The
.cW children
function is defined as returning a set of instances, rather than a
single instance.  Given the query:
.(C
* retrieve(emp.name, emp.children.name)
.)C
if the query in the body of the
.cW children
function returns many instances, the
.b retrieve
query will return all of them, in a
.q flattened
form.  If the query in the body of
.cW manager
returns more than one instance, the
.cW manager
function will return only one instance, arbitrarily chosen from the
set returned by the query in the function's body.  See the \*(PP
Reference Manual's entry on the
.b "define function"
command for further details and examples.
.\"---------------------------------------------------------------------------
.sh 2 "User-Defined Types, Operators, Functions and Aggregates"
.lp
The central concept of extending \*(PP lies in \*(PP's ability to
.i "dynamically load"
an object code file (e.g., a
.cW .o
file or shared library) created by the user.  This allows \*(PP to
call arbitrary user-defined functions which can be written in a
standard programming language, such as C.  These functions can then be
used:
.bu
to convert between
.i internal
(binary) and
.i external
(C character string) representations of user-defined types;
.bu
as operators; and
.bu
to define ordering for indices on user-defined types.
.lp
\*(PP's concept of types includes
.i built-in
types and
.i user-defined
types.  Built-in types are those required by the system to bootstrap
itself.  User-defined types are those created by the user in the
manner described below.  There is no intrinsic performance difference
between using a system type or user-defined type, other than the
overhead due to the complexity of the type itself.
.\"------------------------------------
.sh 3 "Internal Storage of Types"
.lp
.(l C
.hl
FIX ME
need examples of by-value, by-ref-fixed, by-ref-varlena
.hl
.)l
Internally,
\*(PP regards a user-defined type as a
.q "blob of memory"
upon which user-defined functions impose structure and meaning.  \*(PP
will store and retrieve the data from disk and use user-defined
functions to input, process, and output the data.
.\"------------------------------------
.sh 3 "Functions Needed for a User-Defined Type"
.lp
A completely defined user type requires the following user-defined
functions:
.bu
.i input
and
.i output
functions for the type: These functions determine how the type appears
in strings (for input by the user and output to the user) and how the
type is organized in memory.  These at least are necessary to define
the type.
.bu
.i operator
functions for the type: These functions define the meanings of 
.q "equal to,"
.q "less than,"
.q "greater than,"
etc., for your type.
.\"------------------------------------
.sh 3 "An Example User-Defined Type"
.lp
In this discussion, we will be defining a
.cW circle
type, using functions written in the C programming language.
.\"-----------------
.sh 4 "Data Structures for Our Type"
.lp
Before we do anything, we have to decide on what a circle looks like,
both in string format and internally in memory.  Circles have a center
and a radius, so a reasonable string representation of a circle would
be an ordered triple:
.(l
(center_x, center_y, radius)
.)l
where each element is a real number with arbitrary units, e.g.:
.(C
(5.0, 10.3, 3)
.)C
This is what the input to the circle input function looks like, and
what the output from the circle output function looks like.
.lp
Now we have to come up with an internal representation for a circle in
memory.  The following declarations are legal and reasonable given the
format we chose above:
.(C
typedef struct {
    double x, y;
} POINT;

typedef struct {
    POINT center;
    double r;
} CIRCLE;
.)C
Memory containing values of type
.cW CIRCLE
will be written to disk and read from disk, so
.cW CIRCLE
must be both
.i complete
and
.i contiguous ;
that is, it cannot contain any pointers.  The type definition
.(C
typedef struct {
    POINT *center   /* NO! */
    double r;
} CIRCLE;
.)C
will
.i NOT
work, because the virtual memory
.i address 
stored in
.cW center
would be written to disk instead of the contents of the
.cW POINT
structure to which
.cW center
presumably points.  \*(PP cannot detect this kind of coding error; you
must guard against it yourself.
.\"-----------------
.sh 4 "Defining the Input and Output Functions for Our Type"
.lp
Suppose in defining our type
.q circle,
we have a C source file called
.cW circle.c ,
and a corresponding object code file
.cW /usr/local/postgres/circle.o .
(All functions related to our
.cW circle
type must be in the same object file.)  For the purposes of this
discussion, suppose our platform is a MIPS DECstation, where 
.cW sizeof(double)
is 8 bytes.  This assumption will be important later.
.lp
We will create source file
.cW circle.c ,
containing C source code for the functions that support our
.cW CIRCLE
type.
.cW circle.c
contains three functions:
.bu
.cW circle_in ,
which is the input function for circles.  It takes a C string as an 
argument and returns a pointer to a
.cW CIRCLE .
.bu
.cW circle_out ,
which is the output function for circles.  It is takes a pointer to a
.cW CIRCLE
as input and returns a C string.  The return value of
.cW circle_in
must be a legal argument to
.cW circle_out ,
and vice versa.
.bu
.cW eq_area_circle ,
which is the equality function for circles.  For the purposes of this
discussion, circles are equal if their areas are equal.
.lp
The contents of
.cW circle.c
are:
.(C
#include <math.h>
#include <stdio.h>
#include <string.h>

#include "tmp/c.h"           /* (always)                 */
#include "utils/geo-decls.h" /* for POINT declaration    */
#include "utils/palloc.h"    /* for palloc() declaration */

typedef struct {
    POINT  center;
    double radius;
} CIRCLE;

#define LDELIM '('
#define RDELIM ')'
#define NARGS  3

CIRCLE *
circle_in(str)
    char   *str;
{
    char   *p, *coord[NARGS];
    int    i;
    CIRCLE *result;

    if (str == (char *) NULL) 
	return((CIRCLE *) NULL);

    for (i = 0, p = str;
         *p && i < NARGS && *p != RDELIM;
         p++)
    {
        if (*p == ',' || (*p == LDELIM && !i))
            coord[i++] = p + 1;
    }

    if (i < NARGS - 1) 
	return((CIRCLE *) NULL);

    result = (CIRCLE *) palloc(sizeof(CIRCLE));

    result->center.x = atof(coord[0]);
    result->center.y = atof(coord[1]);
    result->radius = atof(coord[2]);

    return(result);
}

char *
circle_out(circle)
    CIRCLE *circle;
{
    char   *result;

    if (circle == (CIRCLE *) NULL)
	return((char *) NULL);

    result = (char *) palloc(60);

    sprintf(result, "(%g, %g, %g)",
            circle->center.x, circle->center.y,
            circle->radius);

    return(result);
}

int
eq_area_circle(circle1, circle2)
    CIRCLE *circle1, *circle2;
{
    if (circle1 == (CIRCLE *) NULL)
	return(circle2 == (CIRCLE *) NULL);
    if (circle2 == (CIRCLE *) NULL)
	return(0);
    return(circle1->radius == circle2->radius);
}
.)C
.lp
Now that we have written these functions and compiled the source
file,\**
.(f
\** You will need to supply an option like
.cW -I/usr/local/postgres/src/backend
to your C compiler so it can find the \*(PP header
.cW .h ) (
files.  Also, various platform-specific compiler options may be
required to support \*(PP dynamic linking (for example, the DECstation
ULTRIX compiler requires the
.cW "-G 0" '' ``
option.)  See Appendix B of this manual and the
.b "define function"
section of the \*(PP Reference Manual for details.
.)f
we have to let \*(PP know that they exist.  First, we run the
following queries to define the input and output functions.  These
functions must be defined
.i before
we define the type.  \*(PP will notify you that return type circle is
not defined yet, but this is OK.  Notice that we use the keyword
.b any
to indicate that the input and/or output of the function is not a
\*(PP type (e.g., a simple C string).
.(C
* define function circle_in
      (language = "c", returntype = circle)
      arg is (any)
      as "/usr/local/postgres/circle.o" \\g

* define function circle_out
      (language = "c", returntype = any)
      arg is (any)
      as "/usr/local/postgres/circle.o" \\g
.)C
Note that the full pathname of the object code file must be specified,
so you would change
.cW /usr/local/postgres
to whatever is appropriate for your installation.
.lp
Now we can define the
.cW circle
type:
.(C
* define type circle
      (internallength = 24,
       input = circle_in, output = circle_out) \\g
.)C
where
.cW internallength
is the size of the
.cW CIRCLE
structure in bytes.  For circles, the type members are three
.cW double s,
which on most platforms are 8 bytes each, with no additional alignment
constraints.  However, when defining your own types, you should
.i not
make assumptions about structure sizes, but instead write a test
program that does a
.(C
printf("size is %d\en", sizeof(MYTYPE));
.)C
on your type.
.lp
If
.cW internallength
is defined incorrectly, you will encounter strange errors which may
crash the data manager itself.  If this were to happen with our
.cW CIRCLE
type, we would have to do a
.(C
* remove type circle \\g
.)C
and then redefine the
.cW circle
type correctly.  Note that we would
.i not
have to redefine our functions, since their behavior would not have
changed.
.\"-----------------
.sh 4 "Defining an Operator for a New Type"
.lp
Now that we have finished defining the
.cW circle
type, we can
.b create
classes with circles in them,
.b append
records to them with circles defined, and
.b retrieve
the values of the entire list of records.  But we can do nothing else
until we have some circle operators.  To do this, we make use of the
concept of
.i "operator overloading" ,
and in this case we will set the \*(PP equality operator
.cW = '' ``
to work for circles.  First we have to tell \*(PP that our circle
equality function exists:
.(C
* define function eq_area_circle
      (language = "c", returntype = bool)
      arg is (circle, circle)
      as "/usr/local/postgres/circle.o" \\g
.)C
We will now bind this function to the equality symbol with the
following query:
.(C
* define operator =
      (arg1 = circle, arg2 = circle,
       procedure = eq_area_circle) \\g
.)C
.\"-----------------
.sh 4 "Using a New Type"
.lp
Let's create a class
.cW tutorial
that contains a
.cW circle
attribute, and run some queries against it:
.(C
* create tutorial(a = circle) \\g

* append tutorial (a = "(1.0, 1.0, 10.0)"::circle) \\g

* append tutorial (a = "(2.0, 2.0, 5.0)"::circle) \\g

* append tutorial (a = "(0.0, 1.8, 10.0)"::circle) \\g

* retrieve (tutorial.all)
      where tutorial.a = "(0.0, 0.0, 10.0)"::circle \\g
.)C
which returns:
.(T
.TS
allbox;
l.
a
(1.0, 1.0, 10.0)
(0.0, 1.8, 10.0)
.TE
.)T
Recall that we defined circles as being equal if their areas were
equal.
.lp
Other operators (less than, greater than, etc.) can be defined in a
similar way.  Note that the
.cW = '' ``
symbol will still work for other types \(em it has merely had a new
type added to the list of types it works on.  Any string of
.q "punctuation characters"
other than brackets, braces, or parentheses can be used in defining an
operator.
.lp
If you wish to place indices on attributes that are of the new type,
you must first tell the index access method the properties of the new
type.  This is a relatively complicated process and is described in a
separate section of this manual \(em see Appendix A.
.\"------------------------------------
.sh 3 "Additional Information on Creating a User-Defined Function"
.\"-----------------
.sh 4 "Use palloc and not malloc"
.lp
In order for \*(PP to correctly manage memory associated with
processing your type, you must use the memory allocator
.cW palloc
and avoid standard \*(UU memory managers such as
.cW malloc .
If you do not, \*(PP will chew up ever increasing amounts of memory.
Worse yet, \*(PP may attempt to free a chunk of memory allocated by 
.cW malloc
in an incorrect way, causing the server to crash.
.cW palloc
has the same arguments as
.cW malloc ,
that is
.(C
char *palloc(size)
unsigned long size;
.)C
To free memory allocated with
.cW palloc ,
use
.cW pfree ,
which is analogous to the \*(UU library function
.cW free :
.(C
void pfree(ptr)
char *ptr;
.)C
.\"-----------------
.sh 4 "Re-loading User Functions"
.lp
In the process of creating a user-defined type, you may find it
necessary to re-load a function in the course of debugging.  This is
.i not
done automatically when you edit or re-compile the file, but
.i is
done if you quit and restart the data manager.
.lp
We would re-load our example functions by using the following command:
.(C
* load "/usr/local/postgres/circle.o" \\g
.)C
.\"-----------------
.sh 4 "Writing a Function of an Instance"
.lp
We've already discussed user functions which take \*(PP base or
user-defined types as arguments; in this section, we will discuss
inheritable C functions or methods.
.lp
C language methods are useful particularly when we want to make a
function
.i inheritable ;
that is, to have the function process every instance in an inheritance
hierarchy of classes.
.lp
In using a function of an instance in qualifying an instance,
\*(PP defines the
.q "current instance"
to be the instance being qualified at the moment your function is
called.  The instance itself will be passed in your function's
parameter list as an opaque structure of type TUPLE, and you will use
\*(PP library routines to access the data in the object as described
below.\**
.(f
\** In \*(PP \*(PV,
.cW TUPLE
is defined as
.cW "void *" .
.)f
.lp
Suppose we want to write a function to answer the query
.(C
* retrieve (EMP.all) where overpaid(EMP) \\g
.)C
In the query above, a reasonable
.cW overpaid
function might be:
.(C
bool
overpaid(t) 
TUPLE t;   /* the current instance */
{
    extern char *GetAttributeByName();
    short salary, seniority, performance;

    salary = (short) GetAttributeByName(t, "salary");
    seniority = (short) GetAttributeByName(t, "seniority");
    performance = (short) GetAttributeByName(t, "performance");

    return (salary > (seniority * performance));
}
.)C
.cW GetAttributeByName
is the \*(PP system function that returns attributes out of the
current instance.  It has two arguments: the argument of type TUPLE
passed into the function, and the name of the desired attribute.
.cW GetAttributeByName
will align data properly so you can cast its return value to the
desired type.  For example, if you have an attribute
.cW name
which is of the \*(PQ type
.cW char16 ,
the
.cW GetAttributeByName
call would look like:
.(C
char *str;
\&...
str = (char *) GetAttributeByName(t, "name")
.)C
.lp
To let \*(PP know about the
.cW overpaid
function,
do:
.(C
* define function overpaid
      (language = "c", returntype = bool)
      arg is (EMP)
      as "/usr/local/postgres/overpaid.o" \\g
.)C
.lp
You can have additional complex, base or user-defined types as
arguments to the inheritable function.  Thus,
.(C
* retrieve (EMP.all)
      where overpaid2(EMP, DEPT, "bill", 8) \\g
.)C
could be written, and
.cW overpaid2
would be declared:
.(C
bool
overpaid2(emp, dept, name, number)
    TUPLE emp, dept;
    char *name;
    long number;
.)C
.\"------------------------------------
.sh 3 "Arrays of Types"
.lp
As discussed above, \*(PP fully supports arrays of base types.
Additionally, \*(PP supports arrays of user-defined types as well.
When you define a type, \*(PP
.i automatically
provides support for arrays of that type.
.\"-----------------
.sh 4 "Arrays of User-Defined Types"
.lp
Using the
.q circle
example discussed above, we will create a class containing an array of
circles:
.(C
* create circles (list = circle[]) \\g
.)C
and do some 
.b append s:
.(C
* append circles (list = "{"(1.0, 1.0, 5.0)",
                         "(2.0, 2.0, 10.0)"}") \\g

* append circles (list = "{"(2.0, 3.0, 15.0)",
                         "(2.0, 2.0, 10.0)"}") \\g

* append circles (list = "{"(2.0, 3.0, 4.0)"}") \\g
.)C
We can now run queries like:
.(C
* retrieve (circles.list[1]) \\g
.)C
which returns the first element of each
.cW list :
.(T
.TS
allbox;
l.
list
(1, 1, 5)
(2, 3, 4)
.TE
.)T
and
.(C
* retrieve (circles.all)
      where circles.list[1] = "(0.0, 0.0, 4.0)" \\g
.)C
which returns:
.(T
.TS
allbox;
l.
list
{"(2, 3, 4)"}
.TE
.)T
Note the
.cW {} s,
indicating that an array has been retrieved, as opposed to a single element.
.\"-----------------
.sh 4 "Defining a New Array Type"
.lp
.(l C
.hl
FIX ME
this is totally wrong now
.hl
.)l
An array may be defined as an element of a class, as shown above, or it may
be defined as a type in and of itself.
This is useful for defining
.i "arrays of arrays" .
.lp
The special built-in functions
.cW array_in
and
.cW array_out
are used by \*(PP to input and output arrays of any existing type.
Here, we define an array of integers:
.(C
* define type int_array
      (element = int4, internallength = variable,
       input = array_in, output = array_out) \\g
.)C
The
.cW element
parameter indicates that this is an array, and setting
.cW internallength
to
.cW variable
indicates that the array is a variable-length attribute.\**
.(f
\** Note that any type using
.cW array_in
and
.cW array_out
.i must
be variable-length.
.)f
.lp
We can use our type defined above to create an array of integer
arrays:
.(C
* define type int_arrays
      (element = int_array, internallength = variable,
       input = array_in, output = array_out) \\g

* create stuff (a = int_arrays) \\g

* append stuff (a = "{{1, 2, 3} , {4, 5}, {6, 7, 8}}") \\g

* append stuff (a = "{{88, 99, 3}}") \\g

* append stuff (a = "{{5, 4, 3} , {2, 2}}") \\g

* retrieve (stuff.a[1])
      where stuff.a[1][1] < stuff.a[1][2] \\g

* retrieve (stuff.a)
      where stuff.a[3][1] < stuff.a[1][2] \\g

* retrieve (s.all) from s in stuff
      where s.a[2][2] = stuff.a[1][1] \\g
.)C
We can also define operators for equality, less than, greater than,
etc., which operate on our new array type as necessary.
.\"-----------------
.sh 4 "Creating an Array Type from Scratch"
.lp
.(l C
.hl
FIX ME
.hl
.)l
There are many situations in which the above scheme for creating an
array type is inappropriate, particularly when it is necessary to
define a fixed-length array.  In this section, we will create an array
of four 
.cW long s
called
.cW quarterly ,
and a variable-length array of 
.cW long s
called
.cW stats .\**
.(f
\** We assume
.cW "sizeof(long) == 4" .
.)f
.lp
The only special things we need to know when writing the input and
output functions for
.cW quarterly
is that \*(PP will pass a
.q simple
(i.e., fixed-length) array of
.cW long s
to the output function and expect a simple array of
.cW long s
in return from the input function.  A simple array suitable for
.cW quarterly
can be declared:
.(C
long quarterly[4];
.)C
For the variable-length array
.cW stats ,
the situation is a little more complicated.  Because \*(PP will not
know in advance how big the array is, \*(PP will expect the length of
the array (in bytes) to be encoded in the first four bytes of the
memory which contains the array.  The expected structure is:
.(C
typedef struct {
    long length;
    unsigned char bytes[1]; /* Force contiguity */
} VAR_LEN_ATTR;
.)C
The input function for the
.cW stats
array will look something like:
.(C
VAR_LEN_ATTR *
stats_in(s)
    char s;
{
    VAR_LEN_ATTR *stats;
    long array_size, *arrayp, nbytes;

    /*
     * nbytes is the total number of bytes in stats,
     * INCLUDING the byte count at the beginning
     */
    nbytes = array_size * sizeof(long)  +  sizeof(long);

    stats = (VAR_LEN_ATTR *) palloc(nbytes);

    stats->length = nbytes;

    arrayp = &(stats->bytes[0]);

    /*
     * put code here that loads interesting stuff into
     * arrayp[0] .. arrayp[array_size]
     */

    return(stats);
}
.)C
The output function for
.cW stats
will get the same
.cW VAR_LEN_ATTR
structure.
.lp
Now, assuming the functions are in
.cW /usr/local/postgres/stats.c
and
.cW /usr/local/postgres/quarterly.c ,
we can define our two arrays.  First we will define the fixed-size
array
.cW quarterly .\**
.(f
\** The assumption that
.cW "internallength == 16"
follows from our assumption about
.cW sizeof(long) .
.)f
.(C
* define function quarterly_in
      (language = "c", returntype = quarterly)
      arg is (any)
      as "/usr/local/postgres/quarterly.o" \\g

* define function quarterly_out
      (language = "c", returntype = any)
      arg is (any)
      as "/usr/local/postgres/quarterly.o" \\g

* define type quarterly
      (element = int4, internallength = 16,
       input = quarterly_in, output = quarterly_out) \\g
.)C
Now we define the
.cW stats
array:
.(C
* define function stats_in
      (language = "c", returntype = stats)
      arg is (any)
      as "/usr/local/postgres/stats.o" \\g

* define function stats_out
      (language = "c", returntype = any)
      arg is (any)
      as "/usr/local/postgres/stats.o" \\g

* define type stats
      (element = int4, internallength = variable,
       input = stats_in, output = stats_out) \\g
.)C
Now we can run some queries:
.(C
* create test (a = quarterly, b = stats) \\g

* append test (a = "1 2 3 4"::quarterly,
               b = "5 6 7"::stats) \\g

* append test (a = "1 3 2 4"::quarterly,
               b = "6 4"::stats) \\g

* append test (a = "7 11 6 9"::quarterly,
               b = "1 2"::stats) \\g

* retrieve (test.all) where test.a[4] = test.b[2] \\g
.)C
which returns:
.(T
.TS
tab(|) allbox;
l l.
a|b
1324|64
.TE
.)T
Note that when you use your own functions to input and output array
types,
.i "your function"
will define how to parse the external (string) representation.  The
braces notation is only a convention used by
.cW array_in
and
.cW array_out
and is
.i not
part of the formal \*(PQ definition.
.\"------------------------------------
.sh 3 "Large Object Types"
.lp
.(l C
.hl
FIX ME
jaquith large objects
external large objects
.hl
.)l
The types discussed to this point are all
.i small
objects \(em that is, they are smaller than 8KB\**
.(f
\** 8 * 1024 == 8192 bytes.  In fact, the type must be considerably
smaller than 8192 bytes, since the \*(PP tuple and page overhead
must also fit into this 8KB limitation.  The actual value that fits
depends on the machine architecture.
.)f
in size.  If you require a larger type for something like a document
retrieval system or for storing bitmaps, you will need to use the
\*(PP
.i "large object"
interface.  The interface to large objects is quite similar to the
\*(UU file system interface.  The particulars are detailed in Section
7 of the \*(PP Reference Manual, which you should have available to
consult as you read the following.
.\"-----------------
.sh 4 "Defining a Large Object"
.lp
Just like any other type, a large object type requires input and
output functions.  For the purposes of this discussion, we assume that
two functions,
.cW large_in
and
.cW large_out
have been written using the large object interface, and that the
compiled functions are in
.cW /usr/local/postgres/large.o .
We also presume that we are using the
.q "file as an ADT"
interface for large objects discussed in the Reference Manual.
.lp
We define a large object which could be used for storing map data:
.(C
* define function large_in
      (language = "c", returntype = map)
      arg is (any)
      as "/usr/local/postgres/large.o" \\g

* define function large_out
      (language = "c", returntype = any)
      arg is (any)
      as "/usr/local/postgres/large.o" \\g

* define type map
      (internallength = variable,
       input = large_in, output = large_out) \\g
.)C
Note that large objects are
.i always
variable-length.
.lp
Now we can use our
.cW map
object:
.(C
* create maps (name = text, a = map) \\g

* append maps (name = "earth",
               a = "/usr/local/postgres/earth") \\g

* append maps (name = "moon",
               a = "/usr/local/postgres/moon") \\g
.)C
Notice that the above queries are identical in syntax to those we have
been using all along to define types and such; the fact that this type
is a large object is completely hidden in the large object interface
and \*(PP storage manager.
.\"-----------------
.sh 4 "Writing Functions and Operators for Large Object Types"
.lp
Like any other \*(PP type, you can define functions and operators for
large object types.  The only caveat is that, like any other functions
which process a large object, they
.i must
use the large object interface described in Section 7 of the \*(PP
Reference Manual.  Possible queries which involve functions on large
objects could include
.(C
* retrieve (emp.name) where beard(emp.picture) = "red" \\g

* retrieve (mountain.name)
      where height(mountain.topomap) > 10000 \\g
.)C
Because all functionality is available to large objects,
.i any
aspect of \*(PP is available for use with them, including index access
methods, if the appropriate operator classes have been defined.
Operator classes for index access methods are discussed in Appendix A.
.\"---------------------------------------------------------------------------
.sh 3 "User-Defined Aggregates"
.lp
.(l C
.hl
FIX ME
.hl
.)l
.\"---------------------------------------------------------------------------
.sh 1 "THE \*(PP RULE SYSTEM"
.lp
Production rule systems are conceptually simple, but there are many
subtle points involved in actually using them.  Consequently, we will
not attempt to explain the actual syntax and operation of the \*(PP
rule system here.  Instead, you should read [STON90b] to understand
some of these points and the theoretical foundations of the \*(PP rule
system before trying to use rules.  The discussion in this section is
intended to provide an overview of the \*(PP rule system and point the
user at helpful references and examples.
.lp
The main point you should understand is that \*(PP actually has two
rule systems, the
.i "instance-level"
rule system and the
.i "query rewrite"
rule system, and that there are tradeoffs in the employment of each.
.lp
The 
.i "instance-level"
rule system uses markers placed in each instance in a class to
.q "trigger"
rules.  Examples of the instance-level rule system are explained and
illustrated in
.cW /usr/local/postgres/src/regress/demo ,
which is included with the \*(PP distribution.  Additional discussion
of the instance-level rule system can be found in the Reference Manual
under
.b "define rule" .
.lp
The 
.q "query rewrite"
rule system modifies queries to take rules into consideration, and
then passes the modified query to the query optimizer for execution.
It is very powerful, and can be used for many things such as query
language procedures, views, and versions.  Examples can be found in
.cW /usr/local/postgres/src/regress/video ,
and further discussion is in the Reference Manual under
.b "define rule" .
The power of this rule system is discussed in [ONG90] as well as
[STON90b].
.lp
Since each rule system is implemented quite differently, they work
best in different situations.  The query rewrite system is best when
rules affect 
.i most
of the instances in a class, while the instance-level system is best
when a rule affects only a
.i few
instances.
.\"---------------------------------------------------------------------------
.sh 1 "ADMINISTERING \*(PP"
.lp
In this section, we will discuss aspects of \*(PP that are of interest
to those who make extensive use of \*(PP, or who are the site
administrator for a group of \*(PP users.
.\"------------------------------------
.sh 2 "Frequent Tasks"
.lp
Here we will briefly discuss some procedures that you should be
familiar with in managing any \*(PP installation.
.\"------------------------------------
.sh 3 "Starting the Postmaster"
.lp
If you did not install \*(PP exactly as described in the installation
instructions, you may have to perform some additional steps before
starting the 
.cW postmaster
process.
.bu
Even if you were not the person who installed \*(PP, you should
understand the installation instructions.  The installation
instructions explain some important issues with respect to where \*(PP
places some important files, proper settings for environment
variables, etc. that may vary from one version of \*(PP to another.
.bu
You should look at the Reference Manual under the heading
.b postmaster
if you wish to use non-default options (e.g., increased security
options, a non-standard installation directory, etc.).
.bu
You 
.i must
start the
.cW postmaster
process with the user-id that owns the installed database files.  In
most cases, if you have followed the installation instructions, this
will be the user
.q postgres .
If you do not start the 
.cW postmaster
with the right user-id, the backend servers that are started by the
.cW postmaster
will not be able to read the data.
.bu
Make sure that 
.cW /usr/local/postgres/bin
is in your shell command path, because the
.cW postmaster
will use your 
.cW PATH
to locate \*(PP commands.
.bu
Remember to set the environment variable
.cW PGDATA
to the directory where the \*(PP databases are installed.  (This
variable is more fully explained in the \*(PP installation
instructions and the Reference Manual.)
.bu
If you do start the 
.cW postmaster
using non-standard options, such as a different TCP port number,
remember to tell all users so that they can set their 
.cW PGPORT
environment variable correctly.
.\"------------------------------------
.sh 3 "Shutting Down the Postmaster"
.lp
If you need to halt the
.cW postmaster
process, you can use the \*(UU
.cW kill (1)
command.  Some people habitually use the 
.cW -9
or
.cW -KILL
option; this should never be necessary and we do not recommend that
you do this, as the
.cW postmaster
will be unable to free its various shared resources, its child
processes will be unable to exit gracefully, etc.
.\"------------------------------------
.sh 3 "Adding and Removing Users"
.lp
The
.cW createuser
and
.cW destroyuser
commands enable and disable access to \*(PP by specific users on the 
host system.  Please read the descriptions of these commands in the
Reference Manual for specific instructions on their use.
.\"------------------------------------
.sh 3 "Periodic Upkeep"
.lp
The
.cW vacuum
command should be run on each database periodically.  This command
processes deleted instances\**
.(f
\** This may mean different things depending on the 
.i "archive mode"
with which each class has been created.  See the Reference Manual
under the heading
.b "create"
for more details.  However, the current implementation of the 
.cW vacuum
command does
.i not
perform any compaction or clustering of data.  Therefore, the \*(UU
files which store each \*(PP class never shrink and the space
.q reclaimed 
by 
.cW vacuum
is never actually reused.
.)f
and, more importantly, updates the system
.i statistics
concerning the size of each class.  If these statistics are permitted
to become out-of-date and inaccurate, the \*(PP query optimizer may
make extremely poor decisions with respect to query evaluation
strategies.  Therefore, we recommend running
.cW vacuum
every night or so (perhaps in a script that is executed by the \*(UU
.cW cron (1)
or
.cW at (1) 
commands).
.\"------------------------------------
.sh 2 "Infrequent Tasks"
.lp
At some time or another, every \*(PP site administrator has to perform
all of the following actions.
.\"------------------------------------
.sh 3 "Cleaning Up After Crashes"
.lp
You may have occasion to run the
.cW ipcclean
command if system errors cause the
.cW postmaster
to crash.
If this happens, you may find (using the \*(UU
.cW ipcs (1)
command) that the
.q postgres
user has shared memory and/or semaphores allocated even though no
.cW postmaster
process is running.  In this case, you should run
.cW ipcclean
as the
.q postgres
user in order to deallocate these resources.  Be warned that 
.i all
such resources owned by the
.q postgres
user will be deallocated.  If you have multiple
.cW postmaster
processes running on the same machine, you should kill all of them
before running
.cW ipcclean 
(otherwise, they will crash on their own when their shared resources
are suddenly deallocated).
.\"------------------------------------
.sh 3 "Moving Database Directories"
.lp
By default,
all \*(PP databases are stored in separate subdirectories under
.cW /usr/local/postgres/data/base .\**
.(f
\** Data for certain classes may stored elsewhere if a non-standard
storage manager was specified when they were created.  Use of
non-standard storage managers is an experimental feature that is not
supported outside of Berkeley.
.)f
At some point, you may find that you wish to move one or more
databases to another location (e.g., to a filesystem with more free
space).
.lp
If you wish to move 
.i all
of your databases to the new location, you can simply:
.bu
Kill the 
.cW postmaster .
.bu
Copy the entire
.cW data
directory to the new location (making sure that the new files are
owned by user
.q postgres ).
.(C
% cp -r /usr/local/postgres/data /new/place/data
.)C
.bu
Reset your
.cW PGDATA
environment variable (as described earlier in this manual and in the
installation instructions).
.(C
# using csh or tcsh...
% setenv PGDATA /new/place/data

# using sh, ksh or bash...
% PGDATA=/new/place/data; export PGDATA
.)C
.bu
Restart the 
.cW postmaster .
.(C
% postmaster &
.)C
.bu
Remove the old 
.cW data
directory.
.(C
% rm -rf /usr/local/postgres/data
.)C
.lp
To install a 
.i single
database in an alternate directory while leaving all other databases
in place, do the following:
.bu
Create the database (if it doesn't already exist) using the
.b createdb
command.  In the following steps we will assume the database is named
.cW foo .
.bu
Kill the 
.cW postmaster .
.bu
Copy the directory
.cW /usr/local/postgres/data/base/foo
and its contents to its ultimate destination.  It should still be
owned by the
.q postgres
user.
.(C
% cp -r /usr/local/postgres/data/base/foo /new/place/foo
.)C
.bu
Remove the directory
.cW /usr/local/postgres/data/base/foo :
.(C
% rm -rf /usr/local/postgres/data/base/foo
.)C
.bu
Make a symbolic link from
.cW /usr/local/postgres/data/base
to the new directory:
.(C
% ln -s /new/place/foo /usr/local/postgres/data/base/foo
.)C
.bu
Restart the 
.cW postmaster .
.\"------------------------------------
.sh 3 "Updating Databases"
.lp
\*(PP is a research system.  In general, \*(PP may not retain the same
binary format for the storage of databases from release to release.
Therefore, when you update your \*(PP software, you will probably have
to modify your databases as well.  This is a common occurrence with
commercial database systems as well; unfortunately, unlike commercial
systems, \*(PP does not come with user-friendly utilities to make your
life easier when these updates occur.
.lp
In general, you must do the following to update your databases to a
new software release:
.bu
.i Extensions
(such as user-defined types, functions, aggregates, etc.) must be
reloaded by re-executing the \*(PQ
.b define
commands.  Notice that as of Version 4.2, the method by which you
generate object code for user-defined functions has changed, so you
may have to modify your old
.cW .o
files.  See Appendix B for more details.
.bu
.i Data
must be dumped from the old classes into ASCII files (using the \*(PQ 
.b copy
command), the new classes created in the new database (using the \*(PQ
.b create
command), and the data reloaded from the ASCII files.
.bu
.i Rules
and
.i views
must also be reloaded by re-executing the various \*(PQ
.b define
commands.
.lp
You should give any new release a 
.q "trial period" ;
in particular, do not delete the old database until you are satisfied
that there are no compatibility problems with the new software.  For
example, you do not want to discover that a bug in a type's
.q input
(conversion from ASCII)
and
.q output
(conversion to ASCII) routines prevents you from reloading your data
after you have destroyed your old databases!  (This should be standard
procedure when updating any software package, but some people try to
economize on disk space without applying enough foresight.)
.\"------------------------------------
.sh 2 "Troubleshooting \*(PP"
.lp
Occasionally, \*(PP will fail with cryptic error messages that are due
to relatively simple problems.  The following are a list of \*(PP
error messages and the likely fix.  These messages are ones you would
likely see in the
.cW monitor
program.
.(C
Message: semget: No space left on device

Explanation and Likely Fix:
.)C
Either the kernel has not been configured for System V shared memory,
or some other program is using it up.  On most machines, the \*(UU
command
.cW ipcs
will show shared memory and semaphore usage.
.lp
To delete all shared memory and semaphores (may be necessary if a
backend fails), run the
.cW ipcclean
command.  Note, however, that
.cW ipcclean
deletes
.i all
semaphores belonging to the user running it, so the user should be
certain that none of his/her non-\*(PP processes are using semaphores
before running this command.
.(C
Message: Unable to get shared buffers

Explanation and Likely Fix:
.)C
This message means that a \*(PP backend was expecting shared memory to
be available and it was not.  Usually this is due to
.cW ipcclean
being run while a
.cW postmaster
was also running.
.(C
Message: Can't connect to the backend (...)

Explanation and Likely Fix:
.)C
This message means that you are running a \*(LP application but it
could not link up with a
.cW postmaster .
If you see this error message, you should see if a
.cW postmaster
is truly running.  If one is running, the problem is likely related to
your network.
.\"------------------------------------
.sh 2 "Database Security"
.lp
Most sites that use \*(PP are educational or research institutions and
do not pay much attention to security in their \*(PP installations.
If desired, one can install \*(PP with additional security features.
Naturally, such features come with additional administrative overhead
that must be dealt with.
.\"------------------------------------
.sh 3 "Kerberos"
.lp
\*(PP can be configured to use the MIT Kerberos network authentication
system.  This prevents outside users from connecting to your databases
over the network without the correct authentication information.  For
more information on Kerberos, see the file
.cW src/doc/kerberos.faq
and the 
.b \*(UU
section of the Reference Manual.
.\"------------------------------------
.sh 3 "Access Control"
.lp
.i "Access control lists"
(ACLs) can be defined on a per-class basis.  These work rather like a
more flexible version of the \*(UU
.cW chmod (1)
command.  See the Reference Manual under the heading
.b "change acl"
for more details.
.\"------------------------------------
.sh 2 "How to Find Out What's in a Database"
.lp
This section explains how you can answer questions such as,
.q "What tables do I have in this database?"
and
.q "What extensions have been added to my database?"
.\"------------------------------------
.sh 3 "About the \*(PP System Catalogs"
.lp
If you are familiar with standard relational systems, you know that
they store information about databases, tables, etc., in what are
commonly known as
.i "system catalogs" .
(Some systems call this the
.i "data dictionary" ).
The catalogs appear to the user as tables, like any other, but the
DBMS stores its internal bookkeeping in them.  One key difference
between \*(PP and standard relational systems is that \*(PP stores
much more information in its catalogs \(em not only information about
tables and attributes, but also information about the types,
procedures, access methods, and so on.  These tables can be modified
by the user, and since \*(PP bases its internal operation on these
tables, this means that \*(PP can be extended by users.  By
comparison, standard relational systems can only be extended by
changing hard-coded procedures within the DBMS.
.lp
The following classes contain information that may be useful to the
end user.  There are many other system catalogs, but there should
never be a reason to query them.
.TS
center tab(|);
cf(C)|c
lf(C)|l.
catalog name|description
=
pg_database|databases
pg_class|class
pg_attribute|attributes
pg_index|indexes

pg_proc|procedures
pg_type|types
pg_operator|operators
pg_aggregate|aggregates

pg_am|access methods
pg_amop|access method operators
pg_amproc|access method support functions
pg_opclass|access method operator classes

pg_user|users
pg_group|user groups
.TE
.\"------------------------------------
.sh 3 "Querying the System Catalogs"
.lp
Before executing any of the queries below, be sure to execute the \*(PP
.cW vacuum
command.  (The queries will run much more quickly that way.)
.lp
This query prints the names of all database adminstrators and the name
of their database(s).
.(C
* retrieve (user_name = u.usename,
            database = d.datname)
      from u in pg_user,
           d in pg_database
      where u.usesysid = int2in(int4out(d.datdba))
      sort by user_name, database
 \\g
.)C
The following query lists all user-defined classes in the database.
.(C
* retrieve (class_name = c.relname)
      from c in pg_class
      where c.relkind = 'r'     /* exclude indexes */
        and c.relname !~ "^pg_"  /* exclude catalogs */
      sort by class_name
 \\g
.)C
The following query prints a report of the user-defined attributes and
their types for all user-defined classes in the database.
.(C
* retrieve (class_name = c.relname, 
            attr_name = a.attname, 
            attr_type = t.typname)
      from c in pg_class,
           a in pg_attribute,
           t in pg_type
      where c.relkind = 'r'    /* no indexes */
        and c.relname !~ "^pg_" /* no catalogs */
        and a.attnum > 0       /* no system att's */
        and a.attrelid = c.oid
        and a.atttypid = t.oid
      sort by class_name, attr_name
 \\g
.)C
This query lists all left-associative (post-fix) operators.
.(C
* retrieve (left_assoc = o.oprname,
            operand = right.typname,
            return_type = result.typname)
      from o in pg_operator,
           right in pg_type,
           result in pg_type
      where o.oprkind = 'l'
        and o.oprright = right.oid
        and o.oprresult = result.oid
      sort by operand
 \\g
.)C
This query lists all right-associative (pre-fix) operators.
.(C
* retrieve (right_assoc = o.oprname,
            operand = left.typname,
            return_type = result.typname)
      from o in pg_operator,
           left in pg_type,
           result in pg_type
      where o.oprkind = 'r'
        and o.oprleft = left.oid
        and o.oprresult = result.oid
      sort by operand
 \\g
.)C
This query lists all binary operators.
.(C
* retrieve (binary_op = o.oprname,
            left_opr = left.typname,
            right_opr = right.typname, 
            return_type = result.typname)
      from o in pg_operator,
           left in pg_type,
           right in pg_type,
           result in pg_type
      where o.oprkind = 'b'
        and o.oprleft = left.oid
        and o.oprright = right.oid
        and o.oprresult = result.oid
      sort by left_opr, right_opr
 \\g
.)C
This query returns the name, number of arguments (parameters) and
return type of all user-defined C functions.  The same query can be
used to find all built-in C functions if you change the
.q C
to 
.q internal ,
or all \*(PQ functions if you change the
.q C
to 
.q postquel .
.(C
* retrieve (p.proname, 
            arguments = p.pronargs,
            returntype = t.typname)
      from p in pg_proc,
           l in pg_language,
           t in pg_type
      where p.prolang = l.oid
        and p.prorettype = t.oid
        and l.lanname = "C"
      sort by proname
 \\g
.)C
This query lists all of the aggregate functions that have been
installed, except for 
.cW count
(which can take any type as its argument).
.(C
* retrieve (a.aggname, t.typname)
      from a in pg_aggregate,
           t in pg_type
      where a.aggbasetype = t.oid
      sort by aggname
 \\g
.)C
.\"---------------------------------------------------------------------------
.sh 1 "REFERENCES"
.\"------------------------------------
.xP [ONG90]
Ong, L. and Goh, J.,
``A Unified Framework for Version Modeling Using Production Rules in a
Database System,"
Electronics Research Laboratory,
University of California,
ERL Technical Memorandum M90/33,
Berkeley, CA,
April 1990.
.\"------------------------------------
.xP [ROWE87]
Rowe, L. and Stonebraker, M.,
``The POSTGRES Data Model,''
Proc. 1987 VLDB Conference,
Brighton, England,
Sept. 1987.
.\"------------------------------------
.xP [STON86]
Stonebraker, M. and Rowe, L.,
``The Design of POSTGRES,''
Proc. 1986 ACM-SIGMOD Conference on Management of Data,
Washington, DC,
May 1986.
.\"------------------------------------
.xP [STON87a]
Stonebraker, M., Hanson, E. and Hong, C.-H.,
``The Design of the POSTGRES Rules System,''
Proc. 1987 IEEE Conference on Data Engineering,
Los Angeles, CA,
Feb. 1987.
.\"------------------------------------
.xP [STON87b]
Stonebraker, M.,
``The POSTGRES Storage System,''
Proc. 1987 VLDB Conference,
Brighton, England,
Sept. 1987.
.\"------------------------------------
.xP [STON89]
Stonebraker, M., Hearst, M., and Potamianos, S.,
``A Commentary on the POSTGRES Rules System,''
SIGMOD Record \fI18\fP(3),
Sept. 1989.
.\"------------------------------------
.xP [STON90a]
Stonebraker, M., Rowe, L. A., and Hirohama, M.,
``The Implementation of POSTGRES,''
IEEE Transactions on Knowledge and Data Engineering \fI2\fP(1),
March 1990.
.\"------------------------------------
.xP [STON90b]
Stonebraker, M. et al.,
``On Rules, Procedures, Caching and Views in Database Systems,''
Proc. 1990 ACM-SIGMOD Conference on Management of Data,
Atlantic City, N.J.,
June 1990.
.\"---------------------------------------------------------------------------
.bp
.lp
.sh 0 "APPENDIX A: User-Defined Types and Indices"
.lp
In this section, we will discuss how to extend \*(PP to use a
user-defined type and associated functions with existing access
methods.  This way, you can define a BTREE or RTREE index on your own
type.  To do this, we will discuss how to define a new operator class
in \*(PP for use with an existing access method.
.lp
Our example will be to add a new operator class to the BTREE access
method.  The new operator class will sort integers in ascending
absolute value order.  This tutorial will describe how to define the
operator class.  If you work the example, you will be able to define
and use indices that sort integer keys by absolute value.
.lp
There are several \*(PP system classes that are important in
understanding how the access methods work.  These will be discussed,
and then a sample procedure for adding a new set of operators to an
existing access method will be shown as an example.
.lp
The
.cW pg_am
class contains one instance for every user-defined access method.
Support for the HEAP access method is built into \*(PP, but every
other access method is described here.  The schema is
.TS
center tab(|);
lf(C)|l.
amname|name of the access method
_
amowner|object id of the owner's instance in pg_user
_
amkind|not used at present, but set to 'o' as a place holder
_
amstrategies|number of strategies for this access method (see below)
_
amsupport|number of support routines for this access method (see below)
_
am*|T{
procedure identifiers for interface routines to the access method.
For example,
.cW regproc
ids for opening, closing, and getting instances from the access method
appear here.
T}
.TE
The object ID of the instance in
.cW pg_am
is used as a foreign key in lots of other classes.  For BTREEs, this
object ID is 403.  You don't need to add a new instance to this class;
all you're interested in is the object ID of the access method
instance you want to extend:
.(C
* retrieve (pg_am.oid) where pg_am.amname = "btree" \\g
.TS
allbox;
l.
oid
403
.TE
.)C
The
.cW amstrategies
attribute exists to standardize comparisons across data types.  For
example, BTREEs impose a strict ordering on keys, less to greater.
Since \*(PP allows the user to define operators, \*(PP cannot in
general look at the name of an operator (eg,
.cW > ,
.cW < )
and tell what kind of comparison it is.  In fact, some access methods
(like RTREEs) don't impose a less-to-greater ordering, but some other
ordering, like containment.  \*(PP needs some consistent way of taking
a scan qualification, looking at the operator, deciding if a usable
index exists, and rewriting the query qualification in order to
improve access speeds.  This implies that \*(PP needs to know, for
example, that
.cW <=
and
.cW >
partition a BTREE.  Strategies is the way that we do this.
.lp
Defining a new set of strategies is beyond the scope of this
discussion, but how the BTREE strategies work will be explained, since
you'll need to know that to add a new operator class.  In the
.cW pg_am
class, the
.cW amstrategies
attribute is the number of strategies defined for this access method.
For BTREES, this number is 5.  These strategies correspond to
.TS
center tab(|);
l|l.
less than|1
_
less than or equal|2
_
equal|3
_
greater than or equal|4
_
greater than|5
.TE
The idea is that you'll add procedures corresponding to the
comparisons above to the
.cW pg_amop
relation (see below).  The access method code can use these numbers,
regardless of data type, to figure out how to partition the BTREE,
compute selectivity, and so on.  Don't worry about the details of
adding procedures yet; just understand that there's a set of these for
.cW int2 ,
.cW int4 ,
.cW oid ,
and every other data type on which a BTREE can operate.
.lp
Strategies are used by all of the \*(PP access methods.  Some access
methods require other support routines in order to work.  For example,
the BTREE access method must be able to compare two keys and determine
whether one is greater than, equal to, or less than the other.
Similarly, the RTREE access method must be able to compute
intersections, unions, and sizes of rectangles.  These operations do
not correspond to user qualifications in \*(PQ queries; they are
administrative routines used by the access methods, internally.
.lp
In order to manage diverse support routines consistently across all
\*(PP access methods,
.cW pg_am
includes a field called
.cW amsupport .
This field records the number of support routines used by an access
method.  For BTREEs, this number is one \(em the routine to take two
keys and return \(mi\^1, 0, or \(pl\^1, depending on whether the first
key is less than, equal to, or greater than the second.\**
.(f
\** Strictly speaking, this routine can return a negative number (<
0), 0, or a non-zero positive number (> 0).
.)f
.lp
The
.cW amstrategies
entry in
.cW pg_am
is just the 
.i number
of strategies defined for the access method in question.  The
procedures for less than, less equal, and so on don't appear in
.cW pg_am .
Similarly,
.cW amsupport
is just the number of support routines required by the access method.
The actual routines are listed elsewhere.
.lp
The next class of interest is
.cW pg_opclass.
This class exists only to associate a name with an
.cW oid .
In
.cW pg_amop ,
every BTREE operator class has a set of procedures, one through five,
above.  Some existing opclasses are
.cW int2_ops ,
.cW int4_ops ,
and
.cW oid_ops .
You need to add an instance with your opclass name (for example,
.cW int4_abs_ops )
to
.cW pg_opclass .
The
.cW oid
of this instance is a foreign key in other classes.
.(C
* append pg_opclass (opcname = "int4_abs_ops") \\g

* retrieve (cl.oid, cl.opcname) from cl in pg_opclass
      where cl.opcname = "int4_abs_ops" \\g
.TS
tab(|) allbox;
l l.
oid|opcname
17314|int4_abs_ops
.TE
.)C
.i NOTE:
The
.cW oid
for your
.cW pg_opclass
instance
.i "may be different!"
You should substitute your value for 17314 wherever it appears in this
discussion.
.lp
So now we have an access method and an operator class.  We still need
a set of operators; the procedure for defining operators was discussed
earlier in this manual.  For the
.cW int4_abs_ops
operator class on BTREEs, the operators we require are:
.(l
absolute value less-than
absolute value less-than-or-equal
absolute value equal
absolute value greater-than-or-equal
absolute value greater-than
.)l
Suppose the code that implements the functions defined is stored in
the file
.cW /usr/local/postgres/int4_abs.c .
The code is
.(C
/*
 * int4_abs.c -- absolute value comparison functions
 *               for int4 data
 */

#include "tmp/c.h"

#define ABS(a) a = ((a < 0) ? -a : a)

/* routines to implement operators */

bool int4_abs_lt(a, b) int32 a, b;
     { ABS(a); ABS(b); return (a < b); }

bool int4_abs_le(a, b) int32 a, b;
     { ABS(a); ABS(b); return (a <= b); }

bool int4_abs_eq(a, b) int32 a, b;
     { ABS(a); ABS(b); return (a == b); }

bool int4_abs_ge(a, b) int32 a, b;
     { ABS(a); ABS(b); return (a >= b); }

bool int4_abs_gt(a, b) int32 a, b;
     { ABS(a); ABS(b); return (a > b); }

/* support (signed comparison) routine */

int int4_abs_cmp(a, b) int32 a, b;
     { ABS(a); ABS(b); return (a - b); }
.)C
There are a couple of important things that are happening below.
First, note that operators for less-than, less-than-or-equal, equal,
greater-than-or-equal, and greater-than for
.cW int4
are being defined.  All of these operators are already defined for
.cW int4
under the names
.cW < ,
.cW <= ,
.cW = ,
.cW >= ,
and
.cW > .
The new operators behave differently, of course.  In order to
guarantee that \*(PP uses these new operators rather than the old
ones, they need to be named differently from the old ones.  This is a
key point: you can overload operators in \*(PP, but only if the
operator isn't already defined for the argument types.
.lp
That is, if you have
.cW <
defined for
.cW int4 , (
.cW int4 ),
you can't define it again.
\*(PP
.i doesn't
check this when you define your operator, so be careful.  To avoid
this problem, odd names will be used for the operators.  If you get
this wrong, the access methods are likely to crash when you try to do
scans.
.lp
The other important point is that all the operator functions return
.i Boolean
values; the access methods rely on this fact.
.lp
The final routine in the file is the 
.q "support routine"
mentioned when we discussed the
.cW amsupport
attribute of the
.cW pg_am
class.  We will use this later on.  For now, ignore it.
.(C
* define function int4_abs_lt
      (language = "c", returntype = bool)
      arg is (int4, int4)
      as "/usr/local/postgres/int4_abs.o" \\g

* define function int4_abs_le
      (language = "c", returntype = bool)
      arg is (int4, int4)
      as "/usr/local/postgres/int4_abs.o" \\g

* define function int4_abs_eq
      (language = "c", returntype = bool)
      arg is (int4, int4)
      as "/usr/local/postgres/int4_abs.o" \\g

* define function int4_abs_ge
      (language = "c", returntype = bool)
      arg is (int4, int4)
      as "/usr/local/postgres/int4_abs.o" \\g

* define function int4_abs_gt
      (language = "c", returntype = bool)
      arg is (int4, int4)
      as "/usr/local/postgres/int4_abs.o" \\g
.)C
Now define the operators that use them.  As noted, the operator names
must be unique for two
.cW int4
operands.  You can do a query on
.cW pg_operator :
.(C
* retrieve (pg_operator.all) \\g
.)C
to see if your name is taken for the types you want.  The important
things here are the procedure (which are the C functions defined
above) and the restriction and join selectivity functions.  You should
just use the ones used below\(emnote that there are different such
functions for the less-than, equal, and greater-than cases.  These
.i must
be supplied, or the access method will crash when it tries to use the
operator.  You should copy the names for
.cW restrict
and
.cW join ,
but use the procedure names you defined in the last step.
.(C
* define operator <<&
      (arg1 = int4, arg2 = int4, procedure=int4_abs_lt,
       associativity = left, restrict = intltsel,
       join = intltjoinsel) \\g

* define operator <=&
      (arg1 = int4, arg2 = int4, procedure = int4_abs_le,
       associativity = left, restrict = intltsel,
       join = intltjoinsel) \\g

* define operator ==&
      (arg1 = int4, arg2 = int4, procedure = int4_abs_eq,
       associativity = left, restrict = eqsel,
       join = eqjoinsel) \\g

* define operator >=&
      (arg1 = int4, arg2 = int4, procedure = int4_abs_ge,
       associativity = left, restrict = intgtsel,
       join = intgtjoinsel) \\g

* define operator >>&
      (arg1 = int4, arg2 = int4, procedure = int4_abs_gt,
       associativity = left, restrict = intgtsel,
       join = intgtjoinsel) \\g
.)C
Notice that five operators corresponding to less, less equal, equal,
greater, and greater equal are defined.
.lp
We're just about finished. the last thing we need to do is to update
the
.cW pg_amop
relation.  To do this, we need the following attributes:
.TS
center tab(|);
lf(C)|l.
amopid|T{
the
.cW oid
of the
.cW pg_am
instance for BTREE (== 403, see above)
T}
_
amopclaid|T{
the
.cW oid
of the
.cW pg_opclass
instance for
.cW int4_abs_ops
(== whatever you got instead of 17314, see above)
T}
_
amopopr|T{
the
.cW oid s
of the operators for the opclass (which we'll get in just a minute)
T}
_
T{
amopselect,
.br
amopnpages
T}|cost functions.
.TE
The cost functions are used by the query optimizer to decide whether
or not to use a given index in a scan.  Fortunately, these already
exist.  The two functions we'll use are
.cW btreesel,
which estimates the selectivity of the BTREE, and
.cW btreenpage,
which estimates the number of pages a search will touch in the tree.
.lp
So we need the
.cW oid s
of the operators we just defined.  We'll look up the names of all the
operators that take two
.cW int4 s,
and pick ours out:
.(C
* retrieve (o.oid, o.oprname)
      from o in pg_operator, t in pg_type
      where o.oprleft = t.oid and o.oprright = t.oid
          and t.typname = "int4" \\g
.)C
which returns:
.(T
.TS
tab(|) allbox;
l l.
oid|oprname
96|\\=
97|<
514|*
518|!=
521|>
523|<=
525|>=
528|/
530|%
551|+
555|-
17321|<<&
17322|<=&
17323|==*
17324|>=&
17325|>>&
.TE
.)T
(Note that your
.cW oid
numbers may be different.)  The operators we are interested in are
those with
.cW oid s
17321 through 17325.  The values you get will probably be different,
and you should substitute them for the values below.  We can look at
the operator names and pick out the ones we just added.  (Of course,
there are lots of other queries we could used to get the oids we
wanted.)
.lp
Now we're ready to update
.cW pg_amop
with our new operator class.  The most important thing in this entire
discussion is that the operators are ordered, from less equal through
greater equal, in
.cW pg_amop .
Recall that the BTREE instance's
.cW oid
is 403 and
.cW int4_abs_ops
is
.cW oid
17314.  Then we add the instances we need:
.(C
* append pg_amop
      (amopid = "403"::oid,          /* btree oid        */
       amopclaid = "17314"::oid,     /* pg_opclass tuple */
       amopopr = "17321"::oid,       /* <<& tup oid      */
       amopstrategy = "1"::int2,     /* 1 is <<&         */
       amopselect = "btreesel"::regproc,
       amopnpages = "btreenpage"::regproc) \\g

* append pg_amop (amopid = "403"::oid,
                  amopclaid = "17314"::oid,
                  amopopr = "17322"::oid,
                  amopstrategy = "2"::int2,
                  amopselect = "btreesel"::regproc,
                  amopnpages = "btreenpage"::regproc) \\g

* append pg_amop (amopid = "403"::oid,
                  amopclaid = "17314"::oid,
                  amopopr = "17323"::oid,
                  amopstrategy = "3"::int2,
                  amopselect = "btreesel"::regproc,
                  amopnpages = "btreenpage"::regproc) \\g

* append pg_amop (amopid = "403"::oid,
                  amopclaid = "17314"::oid,
                  amopopr = "17324"::oid,
                  amopstrategy = "4"::int2,
                  amopselect = "btreesel"::regproc,
                  amopnpages = "btreenpage"::regproc) \\g

* append pg_amop (amopid = "403"::oid,
                  amopclaid = "17314"::oid,
                  amopopr = "17325"::oid,
                  amopstrategy = "5"::int2,
                  amopselect = "btreesel"::regproc,
                  amopnpages = "btreenpage"::regproc) \\g
.)C
NOTE the order:
.q "less than"
is 1,
.q "less than or equal"
is 2,
.q "equal"
is 3,
.q "greater than or equal"
is 4,
and
.q "greater than"
is 5.
.lp
The last step (finally!) is registration of the 
.q "support routine"
previously described in our discussion of
.cW pg_am .
The 
.cW oid
of this support routine is stored in the
.cW pg_amproc
class, keyed by the access method
.cW oid
and the operator class
.cW oid .
First, we need to register the function in \*(PP (recall that we put
the C code that implements this routine in the bottom of the file in
which we implemented the operator routines):
.(C
* define function int4_abs_cmp
      (language = "c", returntype = int)
      arg is (int4, int4)
      as "/usr/local/postgres/int4_abs.o" \\g

* retrieve (p.oid, p.proname)
      from p in pg_proc
      where p.proname = "int4_abs_cmp" \\g
.TS
tab(|) allbox;
l l.
oid|proname
17328|int4_abs_cmp
.TE
.)C
(Again, your
.cW oid
number will probably be different and you should substitute the value
you see for the value below.)  Recalling that the BTREE instance's
.cW oid 
is 403 and that of 
.cW int4_abs_ops
is 17314, we can add the new instance as follows:
.(C
* append pg_amproc
	(amid = "403"::oid,        /* btree oid        */
	 amopclaid = "17314"::oid, /* pg_opclass tuple */
	 amproc = "17328"::oid,    /* new pg_proc oid */
	 amprocnum = "1"::int2) \eg
.)C
.lp
Okay, now it's time to test the new operator class.  First we'll
create and populate a class\**:
.(f
\** In this example, we append only a few instances into the class.
In fact, \*(PP uses a 
.q cost-based
query optimizer that makes the decision whether or not to use an index
based on how much data is touched.  Since this example creates a very
small amount of data, the example will likely not work as advertised
\(em one would have to insert a fair amount of data before using an
index would actually be cheaper than just scanning the underlying HEAP
data structure.
.q "A fair amount"
typically means on the order of several kilobytes.
.)f
.(C
* create pairs (name = char16, number = int4) \\g

* append pairs (name = "mike", number = -10000) \\g

* append pairs (name = "greg", number = 3000) \\g

* append pairs (name = "lay peng", number = 5000) \\g

* append pairs (name = "jeff", number = -2000) \\g

* append pairs (name = "mao", number = 7000) \\g

* append pairs (name = "cimarron", number = -3000) \\g

* retrieve (pairs.all) \\g
.TS
tab(|) allbox;
l l.
name|number
mike|-10000
greg|3000
lay peng|5000
jeff|-2000
mao|7000
cimarron|-3000
.TE
.)C
Okay, looks pretty random.  Define an index using the new opclass:
.(C
* define index pairsind on pairs
      using btree (number int4_abs_ops) \\g
.)C
Now run a query that doesn't use one of our new operators.  What we're
trying to do here is to run a query that
.i won't
use our index, so that we can tell the difference when we see a query
that
.i does
use the index.  This query won't use the index because the operator we
use in the qualification isn't one that appears in the list of
strategies for our index.
.(C
* retrieve (pairs.all) where pairs.number < 9000 \\g
.TS
tab(|) allbox;
l l.
name|number
mike|-10000
greg|3000
lay peng|5000
jeff|-2000
mao|7000
cimarron|-3000
.TE
.)C
Yup, just as random; that didn't use the index.  Okay, let's run a
query that
.i does
use the index:
.(C
* retrieve (pairs.all) where pairs.number <<& 9000 \\g
.TS
tab(|) allbox;
l l.
name|number
jeff|-2000
cimarron|-3000
greg|3000
lay peng|5000
mao|7000
.TE
.)C
Note that the
.cW number
values are in order of increasing absolute value (as they should be,
since the index was used for this scan) and that we got the right
answer \(em the instance for
.cW mike
doesn't appear, because \(mi10000 >=& 9000.
.\"---------------------------------------------------------------------------
.bp
.lp
.sh 0 "Appendix B: Linking Dynamically-Loaded Functions"
.lp
After you have created and registered a user-defined function, your
work is essentially done.  \*(PP, however, must load the 
.i "object code"
(e.g., a
.cW .o 
file, or a shared library) that implements your function.  As
previously mentioned, \*(PP loads your code at run-time, as required.
In order to allow your code to be dynamically loaded, you may have to
compile and link-edit it in a special way.  This section briefly
describes how to perform the compilation and link-editing required
before you can load your user-defined functions into a running \*(PP
server.  Note that
.i "this process has changed as of Version 4.2." \**
.(f
\** The old \*(PP dynamic loading mechanism required in-depth
knowledge in terms of executable format, placement and alignment of
executable instructions within memory, etc. on the part of the person
writing the dynamic loader.  Such loaders tended to be slow and buggy.
As of Version 4.2, the \*(PP dynamic loading mechanism has been
rewritten to use the dynamic loading mechanism provided by the
operating system.  This approach is generally faster, more reliable
and more portable than our previous dynamic loading mechanism.  The
reason for this is that nearly all modern versions of \*(UU use a
dynamic loading mechanism to implement shared libraries and must
therefore provide a fast and reliable mechanism.  On the other hand,
the object file must be post-processed a bit before it can be loaded
into \*(PP.  We hope that the large increase in speed and reliability
will make up for the slight decrease in convenience.
.)f
You should expect to read (and reread,
and re-reread) the manual pages for the C compiler,
.cW cc (1),
and the link editor,
.cW ld (1),
if you have specific questions.
.lp
The following terminology will be used below:
.ip "Dynamic loading"
is what \*(PP does to an object file.  The object file is copied into
the running \*(PP server and the functions and variables within the
file are made available to the functions within the \*(PP process.
\*(PP does this using the dynamic loading mechanism provided by the
operating system.
.ip "Link editing"
is what you do to an object file in order to produce another kind of
object file (e.g., an executable program or a shared library).  You
perform this using the link editing program,
.cW ld (1).
.lp
The following general restrictions and notes also apply to the
discussion below.
.bu
Paths given to the
.b "define function"
command must be absolute paths (i.e., start with \*(lq/\*(rq) that
refer to directories visible on the machine on which the \*(PP server
is running.\**
.(f 
\** Relative paths do in fact work, but are relative to the directory
where the database resides (which is generally invisible to the
frontend application).  Obviously, it makes no sense to make the path
relative to the directory in which the user started the frontend
application, since the server could be running on a completely
different machine!
.)f
.bu
The \*(PP user must be able to traverse the path given to the
.b "define function"
command and be able to read the object file.  This is because the
\*(PP server runs as the \*(PP user, not as the user who starts up the
frontend process.  (Making the file or a higher-level directory
unreadable and/or unexecutable by the 
.q postgres
user is an 
.i extremely
common mistake.)
.bu
Symbol names defined within object files must not conflict with each
other or with symbols defined in \*(PP.
.bu
The GNU C compiler usually does not provide the special options that
are required to use the operating system's dynamic loader interface.
In such cases, the C compiler that comes with the operating system
must be used.
.uh "ULTRIX"
.lp
It is very easy to build dynamically-loaded object files under 
ULTRIX.  ULTRIX does not have any shared-library mechanism and hence
does not place any restrictions on the dynamic loader interface.  On
the other hand, we had to (re)write a non-portable dynamic loader
ourselves and could not use true shared libraries.
.lp
Under ULTRIX, the only restriction is that you must produce each
object file with the option
.cW "-G 0" .
(Notice that that's the numeral
.cW 0 '' ``
and not the letter
.cW O ''). ``
For example,
.(C
	# simple ULTRIX example
	% cc -G 0 -c foo.c
.)C
produces an object file called
.cW "foo.o"
that can then be dynamically-loaded into \*(PP.  No additional loading
or link-editing must be performed.
.uh "Alpha OSF/1 and SunOS 4"
.lp
Both Alpha OSF/1 and SunOS 4 can take any simple object file and
produce a shared object file by running the 
.cW ld
command over it with the correct options.  The commands to do this
under Alpha OSF/1 look like:
.(C
	# simple Alpha OSF/1 example
	% cc -c foo.c
	% ld -shared -expect_unresolved '*' -o foo.so foo.o
.)C
whereas under SunOS 4, the commands look like:
.(C
	# simple SunOS 4 example
	% cc -c foo.c
	% ld -Bdynamic -o foo.so foo.o
.)C
The resulting shared object file can then be loaded into \*(PP.  When
specifying the object file name to the
.b "define function"
command, one must give it the name of the shared object file (ending
in
.cW ".so" )
rather than the simple object file.\**
.(f
\** Actually, \*(PP does not care what you name the file as long as it
is a shared object file.  If you prefer to name your shared object
files with the extension
.cW ".o" ,
this is fine with \*(PP so long as you make sure that the correct
file name is given to the 
.b "define function"
command.  In other words, you must be absolutely consistent.  However,
from a pragmatic point of view, we discourage this practice because
you will undoubtedly confuse yourself with regards to which files have
been made into shared object files and which have not.  For example,
it's very hard to write
.cW Makefile s
to do the link-editing automatically if both the object file and the
shared object file end in
.cW ".o" !
.)f
.uh "HP-UX"
.lp
Under HP-UX, the simple object file must be created by compiling the
source file with special compiler flags
.i and
a shared library must be produced.
Specifically, the
.cW "+z"
flag to the HP-UX C compiler produces so-called 
.q "Position Independent Code"
(PIC) and the 
.cW "+u"
flag removes some alignment restrictions that the PA-RISC architecture
normally enforces.  The object file must be turned into a shared
library using the HP-UX link editor with the
.cW "-b"
option.  This sounds complicated but is actually very simple, since
the commands to do it are just:
.(C
	# simple HP-UX example
	% cc +z +u -c foo.c
	% ld -b -o foo.sl foo.o
.)C
As with the 
.cW ".so"
files mentioned in the last subsection, the 
.b "define function"
command must be told which file is the correct file to load (i.e., you
must give it the location of the shared library, or
.cW ".sl"
file).
.uh "AIX"
.lp
AIX, like SunOS, OSF/1 and HP-UX, requires users to build shared
object files in order to use its built-in dynamic loading mechanism.
No special compiler options must be given to build the simple object
file.  However, AIX provides a very general, flexible and complicated
interface for producing shared object files.  As a result, it is
(relatively) difficult to produce dynamically-loaded object files.
Bear in mind that this only means that it is difficult when compared
to the mechanisms just discussed; it's really not that hard to do.
.lp
AIX allows the user to tell it which program symbols (e.g., function
and global variable names) should be visible to other pieces of code.
This can be convenient in certain cases.  Unfortunately, AIX also
.i requires
the user to tell it which symbols should be visible (i.e., the default
behavior is to disallow sharing).  AIX controls this behavior by using
.i "export files"
and
.i "import files" .
.ip
A symbol may be
.i exported
from the shared object file to the program into which the shared
object file is being loaded.  In other words, the export file
specifies which symbols defined within the shared object file can be
accessed by \*(PP.  We usually want all symbols to be visible to
\*(PP.
.ip
A symbol may be
.i imported
by the shared object file from the program into which the shared
object file is being loaded.  In other words, the import file
specifies which symbols defined with the \*(PP server can be called by
routines defined within the shared object file.  Again, we usually
want all \*(PP symbols to be visible to the user code.
.lp
Hence, in order to load a shared object file, one must have an export
file for the shared object file as well as an import file for the
\*(PP backend server.  This turns out to be easy to do, since export
and import files have the same basic format and may be produced from
the simple object file(s) by running the
.cW mkldexport
command that comes with \*(PP.  The following three steps should work
for most cases:
.(C
	# simple AIX example, using Bourne shell
	% cc -c foo.c
	% mkldexport foo.o `pwd` > foo.exp
	% ld -H512 -T512 -o foo.so -e _nostart \e
		-bI:/usr/local/postgres/lib/postgres.exp \e
		-bE:foo.exp foo.o -lm -lc 2>/dev/null
.)C
The values given for the 
.cW -H ,
.cW -T
and 
.cW -e
flags to 
.cW ld
should simply be taken as voodoo.
The file specified by the 
.cW -bI:
flag is produced when the \*(PP server is compiled and installed.
(The library directory 
.cW /usr/local/postgres/lib
given in the example may differ if you have installed \*(PP in a
different place, of course.)  The file specified by the
.cW -bE:
flag must be produced by hand (using the
.cW mkldexport
command, as shown) before the
.cW .so
shared object file can be produced.
.lp
You are probably asking,
.q "If it's so easy, why not do it all for me?!"
In fact, the magic command lines given above do work in most cases and
so could be embedded within \*(PP and hidden from the user.  However,
there are circumstances in which it will fail.  In these cases, the
user must be able to control the loader flags with which the shared
object file is constructed.  In addition, since the file system
.i locations
of the various object files are hardcoded into the export/import files
(and hence into the shared object file), this fact should also be
visible to the user.  Finally, by putting the export/import files
under user control, the user can do as the designers of AIX intended
and actually edit the files (i.e., control link-editing) as desired.
