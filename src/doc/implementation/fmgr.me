.\" $Header$
.ps 12
.\" The following macros are copied from mao's am.me:
.\" BEGIN MACRO DEFS 
.fo ''%''
.ds PG "\\s-2POSTGRES\\s0
.ds PQ "\\s-2POSTQUEL\\s0
.de RN
\\fC\\$1\\fP\\$2
..
.de (E
.in +0.5i
.sp
.nf
.na
.ft C
.ta 0.5i 1i 1.5i 2i 2.5i 3i 3.5i 4i 4.5i 5i 5.5i
..
.de )E
.in
.sp
.fi
.ad
.ft R
..
.\" END MACRO DEFS
.\"
.uh "The Function Manager"
.sh 1 General
.pp
The abstraction of functions is provided by the Function Manager layer.
A function in \*(PG falls into one of the following categories:
built-in functions, C functions or \*(PQ functions. Each function is
represented by its unique Object ID (also known as a Procedure ID).
.pp
The built-in functions are a set of selected C procedures compiled into
the backend. They are used by built-in operators, access methods, etc.
User-defined functions yield either C functions (when declared with
.RN language="C" )
or \*(PQ functions (when declared with
.RN language="postquel" ).
.pp
This layer is intended to provide uniform access to a function regardless of
its type and bindings (ie. static or dynamic). Unfortunately, invoking \*(PQ
functions requires more sophistication. (Note that function and procedure is
used interchangeably to mean the same thing in this document.) 
.sh 1 "The Internals"
.sh 2 "The System Catalog pg_proc"
.pp
Each function has an entry in the system catalog, 
.RN pg_proc .
The structure and declaration of an entry is as follows:
.(b
.ft C
CATALOG(pg_proc) BOOTSTRAP {
    char16      proname;	/* procedure name */
    oid         proowner;	/* procedure owner */
    oid         prolang;	/* procedure language */
    bool        proisinh;	/* is procedure inheritable? */
    bool        proistrusted;	/* is procedure spawned or called? */
    bool        proiscachable;/* is value precomputable? */
    int2        pronargs;	/* number of arguments */
    bool        proretset;	/* does procedure return set of tuples */
    oid         prorettype;	/* procedure return type */
    oid8        proargtypes;	/* argument types */
    int4        probyte_pct;	/* percentage of size of input */
    int4        properbyte_cpu;	/* cost per byte of operand */
    int4        propercall_cpu;	/* CPU time per call */
    int4        prooutin_ratio; /* ratio of output to input sizes */
    text        prosrc;         /* query string for postquel functions */
    bytea       probin;         /* object file name for C procedures */
} FormData_pg_proc;

typedef FormData_pg_proc	*Form_pg_proc;
.ft
.)b
.pp
The
.RN prolang 
field specifies the category of the function. It contains the Object ID
of the ``language'' the function is written in. Valid values are listed in
the table below.
.TS
center allbox;
cfI cfI
lfC l.
Language	description
INTERNALlanguageId	a built-in function
ClanguageId 	a C function
POSTQUELlanguageId	a \*(PQ function
.TE
.sh 2 "The Function Cache"
.pp
For faster access, information about the functions is cached in  
a function cache. 
.RN lib/fcache.c
contains code which handles the function cache.
.sh 2 "Built-in Functions Table"
.pp
Built-in functions are collected at compile time from the source code to
produce a table of entry points. The table is generated by the shell
script
.RN  utils/Gen_fmgrtab.sh .
It 
generates
.RN fmgrtab.c
and 
.RN fmgr.h
from
.RN catalog/pg_proc.h .
.pp
Each entry in the table contains the following structure (defined in
.RN utils/fmgrtab.h ).
.(E
typedef struct {
        ObjectId        proid;	/* procedure Id */
        uint16          nargs;	/* number of arguments */
        func_ptr        func;		/* entry point */
} FmgrCall;
.)E
The following is an excerpt of the table. For instance, the two entries
specify the Procedure Id's and number of arguments for the
.RN textin 
and 
.RN textout
procedures.
.(E
static FmgrCall fmgr_builtins[] = {
	...
	{ 46, 1, textin },
	{ 47, 1, textout },
	...
}
.)E
.sh 2 "Functions with Dynamic Bindings"
.pp
User-defined functions are dynamically loaded into the backend on demand. The
\*(PQ 
.RN "define function"
command registers the procedure in the system catalog,
.RN pg_proc .
The function is loaded into the running backend when either the \*(PQ
.RN load
command is encountered or the first time the function is invoked.
.pp
The code which handles dynamic loading is in
.RN util/fmgr/dfmgr.c .
Details of dynamic loading is beyond the scope of this section.
.sh 1 "A Raw Interface"
.pp
C Functions are invoked with 
.RN fmgr_c 
(defined in 
.RN utils/fmgr/fmgr.c ). 
Note that you can only have eight arguments for user-defined C functions while
at most nine for internal functions. Its declaration is as follows.
.(E
char *
fmgr_c(user_fn, func_id, n_arguments, values, isNull)
        func_ptr        user_fn;
        ObjectId        func_id;
        int             n_arguments;
        FmgrValues      *values;
        Boolean         *isNull;
.)E
.pp
\*(PQ functions are invoked with 
.RN postquel_function 
(defined in
.RN executor/functions.c ). Its declaration is as follows.
.(E
Datum
postquel_function(funcNode, args, isNull, isDone)
     Func funcNode;
     char *args[];
     bool *isNull;
     bool *isDone;
.)E
.pp
In general, the user should avoid dealing with functions at this level.
This is used primarily by the executor layer (see, for example, 
.RN ExecMakeFunctionResult
in 
.RN executor/ex_qual.c ).
.sh 1 "Usage of the Raw Interface in the Executor"
.pp
To appreciate how the function manager works, one might look at the
the executor. In the executor,
.RN ExecEvalExpr
evaluates operators and function clauses with
.RN ExecEvalOper
and
.RN ExecEvalFunction.
Both of them invokes 
.RN ExecMakeFunctionResult
which in turns invoke
.RN fmgr_c()
and
.RN postquel_function()
accordingly to evaluate the results.
.sh 1 "The C Functions Interface"
.pp
To invoke a C function (including the built-ins), the user should use the 
.RN fmgr() and 
.RN fmgr_info()
interface. It only requires you to identify the function by supplying
its procedure ID. If the function needs to be dynamically loaded into the
backend, it will be done automatically.
.pp
To use the interface, you may need the following include file:
.(E
.ft C
#include "fmgr.h"
.ft
.)E
.pp
.RN Fmgr() 
takes the object ID of a procedure and its arguments. It invokes
the function and returns the result. Its declaration is as follows.
.(E
char *
fmgr(procedureId [, ... ] )
	ObjectId procedureId;
.)E
.pp
For example, the following code segment taken from
.RN catalog/index.c 
illustrates how the text-in procedure,
.RN textin() ,
is invoked through
.RN fmgr() .
.(E
if (predicate != LispNil) {
	predString = lispOut(predicate);
	predText = (text *)fmgr(F_TEXTIN, predString);
	pfree(predString);
} else {
	predText = (text *)fmgr(F_TEXTIN, "");
}
.)E
.pp
You can also obtain information about a function with 
.RN fmgr_info . 
It takes the procedure ID of a function and returns its entry point in
.RN function
and the number of arguments it takes in
.RN nargs .
Its declaration is as follows.
.(E
void
fmgr_info(procedureId, function, nargs)
        ObjectId        procedureId;
        func_ptr        *function;
        int             *nargs;
.)E
.pp
For example, in the following code segment also taken from
.RN catalog/index.c 
illustrates how to obtain the entry point (ie. the function pointer)
of the procedure testing equality of ObjectId's,
.RN oideq(),
through
.RN fmgr_info() .
It stores the entry point in the index key for later use.
.(E
fmgr_info(ObjectIdEqualRegProcedure, 
	&indexKey[0].func, &indexKey[0].nargs);
.)E
