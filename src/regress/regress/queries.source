/*
 * queries.source
 *
 * $Header$
 *
 * The comments that contain sequences of UNIX commands generate the 
 * desired output for the POSTQUEL statement(s).
 */

/*
 * --- operators and target lists ---
 */

/*
 * sanity check - if this fails go insane!
 */
retrieve (one = 1)
\g

/*************testing built-in type bool*********************/

/* check bool type-casting as well as and, or, not in qualifications */

retrieve (true="t"::bool) 
\g
retrieve (false="f"::bool)
\g
retrieve (true="t"::bool or "f"::bool)
\g
retrieve (false="t"::bool and "f"::bool)
\g
retrieve (true = not "f"::bool)
\g
retrieve (false = "t"::bool = "f"::bool)
\g
retrieve (true = "t"::bool != "f"::bool)
\g

create BOOLTBL1 (f1 = bool)
\g
append BOOLTBL1 (f1 = "t"::bool)
\g
append BOOLTBL1 (f1 = "True"::bool)
\g
append BOOLTBL1 (f1 = "true"::bool)
\g

/* BOOLTBL1 should be full of true's at this point */
retrieve (BOOLTBL1.all)
\g

retrieve (BOOLTBL1.all) where BOOLTBL1.f1 = "true"::bool
\g
retrieve (BOOLTBL1.all) where BOOLTBL1.f1 != "false"::bool
\g
retrieve (BOOLTBL1.all) where booleq("false"::bool,BOOLTBL1.f1)
\g
append BOOLTBL1 (f1 = "f"::bool)
\g
retrieve (BOOLTBL1.all) where BOOLTBL1.f1 = "false"::bool
\g

create BOOLTBL2 (f1 = bool)
\g
append BOOLTBL2 (f1 = "f"::bool)
\g
append BOOLTBL2 (f1 = "false"::bool)
\g
append BOOLTBL2 (f1 = "False"::bool)
\g
append BOOLTBL2 (f1 = "XXX"::bool)  /* this evaluates to a false value */
\g

/* BOOLTBL2 should be full of false's at this point */
retrieve (BOOLTBL2.all)
\g

/* BUG---->  this two produce different results,
   the first being erroneous,   bug in hash join??? */
retrieve (BOOLTBL1.all, BOOLTBL2.all) where BOOLTBL2.f1 != BOOLTBL1.f1
\g
retrieve (BOOLTBL1.all, BOOLTBL2.all) where boolne(BOOLTBL2.f1,BOOLTBL1.f1)
\g

retrieve (BOOLTBL1.all, BOOLTBL2.all) where BOOLTBL2.f1 = BOOLTBL1.f1 and BOOLTBL1.f1 = "false"::bool
\g
retrieve (BOOLTBL1.all, BOOLTBL2.all) where BOOLTBL2.f1 = BOOLTBL1.f1 or BOOLTBL1.f1 = "true"::bool
\g

/********testing built-in time types: abstime, reltime, and tinterval *****/

create ABSTIME_TBL (f1 = abstime)
\g
append ABSTIME_TBL (f1 = "Jan 14, 1973 03:14:21")
\g
append ABSTIME_TBL (f1 = "now"::abstime)
\g
append ABSTIME_TBL (f1 = "epoch"::abstime)
\g
append ABSTIME_TBL (f1 = "current"::abstime)
\g
append ABSTIME_TBL (f1 = "infinity"::abstime)
\g
append ABSTIME_TBL (f1 = "-infinity"::abstime)
\g
append ABSTIME_TBL (f1 = "May 10, 1943 23:59:12")
\g

/* what happens if we specify slightly misformatted abstime? */
append ABSTIME_TBL (f1 = "Feb 35, 1946 10:00:00")
\g
append ABSTIME_TBL (f1 = "Feb 28, 1984 25:08:10")
\g

/* badly formatted abstimes:  these should result in invalid abstimes */
append ABSTIME_TBL (f1 = "bad date format")
\g
append ABSTIME_TBL (f1 = "Jun 10, 1843")
\g

create RELTIME_TBL (f1 = reltime)
\g
append RELTIME_TBL (f1 = "@ 1 minute")
\g
append RELTIME_TBL (f1 = "@ 5 hour")
\g
append RELTIME_TBL (f1 = "@ 10 day")
\g
append RELTIME_TBL (f1 = "@ 34 year")
\g
append RELTIME_TBL (f1 = "@ 3 months")
\g
append RELTIME_TBL (f1 = "@ 14 seconds ago")
\g

/* badly formatted reltimes:   */
append RELTIME_TBL (f1 = "badly formatted reltime")
\g
append RELTIME_TBL (f1 = "@ 30 eons ago")
\g

create TINTERVAL_TBL(f1 = tinterval)
\g
append TINTERVAL_TBL(f1 = "['-infinity' 'infinity']")
\g
append TINTERVAL_TBL(f1 = "['May 10, 1943 23:59:12' 'Jan 14, 1973 03:14:21']")
\g
append TINTERVAL_TBL(f1 = "['Sep 4, 1983 23:59:12' 'Oct 4, 1983 23:59:12']")
\g
append TINTERVAL_TBL(f1 = "['epoch' 'now']")
\g
append TINTERVAL_TBL(f1 = "['Feb 15 1990 12:15:03' 'current']")
\g

/* badly formatted tintervals */
append TINTERVAL_TBL(f1 = "['bad time specifications' '']")
\g
append TINTERVAL_TBL(f1 = "['' 'infinity']")
\g

/* test abstime operators */

retrieve (ABSTIME_TBL.all)
\g
retrieve (ABSTIME_TBL.all) where ABSTIME_TBL.f1 < "Jun 30, 2001"::abstime
\g
retrieve (ABSTIME_TBL.all) where ABSTIME_TBL.f1 > "-infinity"::abstime
\g
retrieve (ABSTIME_TBL.all) where "May 10, 1943 23:59:12"::abstime != ABSTIME_TBL.f1
\g
retrieve (ABSTIME_TBL.all) where "current"::abstime = ABSTIME_TBL.f1
\g
retrieve (ABSTIME_TBL.all) where "epoch"::abstime >= ABSTIME_TBL.f1
\g
retrieve (ABSTIME_TBL.all) where ABSTIME_TBL.f1 <= "Jan 14, 1973 03:14:21"::abstime
\g
retrieve (ABSTIME_TBL.all) where ABSTIME_TBL.f1 <?> "['Apr 1 1945 00:00:00' 'Dec 30 1999 23:00:00']"::tinterval 
\g
/* these four queries should return the same answer */
/* the "infinity" and "-infinity" tuples in ABSTIME_TBL cannot be added and */
/* therefore, should not show up in the results. */
retrieve (ABSTIME_TBL.all) where  (ABSTIME_TBL.f1 + "@ 3 year"::reltime) < "Jan 14 14:00:00 1977"::abstime 
\g
retrieve (ABSTIME_TBL.all) where  (ABSTIME_TBL.f1 + "@ 3 year ago"::reltime) < "Jan 14 14:00:00 1971"::abstime 
\g
retrieve (ABSTIME_TBL.all) where  (ABSTIME_TBL.f1 - "@ 3 year"::reltime) < "Jan 14 14:00:00 1971"::abstime 
\g
retrieve (ABSTIME_TBL.all) where  (ABSTIME_TBL.f1 - "@ 3 year ago"::reltime) < "Jan 14 14:00:00 1971"::abstime 
\g
retrieve (ABSTIME_TBL.all, RELTIME_TBL.all) where (ABSTIME_TBL.f1 + RELTIME_TBL.f1) < "Jan 14 14:00:00 1971"::abstime
\g

/* test reltime operators */

retrieve (RELTIME_TBL.all)
\g
retrieve (RELTIME_TBL.all) where RELTIME_TBL.f1 != "@ 10 days"::reltime
\g
retrieve (RELTIME_TBL.all) where RELTIME_TBL.f1 <= "@ 5 hours"::reltime
\g
retrieve (RELTIME_TBL.all) where RELTIME_TBL.f1 < "@ 1 day"::reltime
\g
retrieve (RELTIME_TBL.all) where RELTIME_TBL.f1 = "@ 34 years"::reltime
\g
retrieve (RELTIME_TBL.all) where RELTIME_TBL.f1 >= "@ 1 month"::reltime
\g
retrieve (RELTIME_TBL.all) where RELTIME_TBL.f1 > "@ 3 seconds ago"::reltime
\g
retrieve (r1.all, r2.all) from r1 in RELTIME_TBL, r2 in RELTIME_TBL where r1.f1 > r2.f1
\g

/* test tinterval operators */

retrieve (TINTERVAL_TBL.all)
\g
retrieve (t.all) from t in TINTERVAL_TBL where t.f1 #= "@ 1 months"
\g
retrieve (t.all) from t in TINTERVAL_TBL where t.f1 #!= "@ 1 months"
\g
retrieve (t.all) from t in TINTERVAL_TBL where t.f1 #< "@ 1 month"
\g
retrieve (t.all) from t in TINTERVAL_TBL where t.f1 #<= "@ 1 month"
\g
retrieve (t.all) from t in TINTERVAL_TBL where t.f1 #> "@ 1 year"
\g
retrieve (t.all) from t in TINTERVAL_TBL where t.f1 #>= "@ 3 years"
\g
retrieve (t1.all) from t1 in TINTERVAL_TBL where t1.f1 && "['Aug 15 14:23:19 1983' 'Sep 16 14:23:19 1983']"::tinterval
\g
retrieve (t1.all, t2.all) from t1,t2 in TINTERVAL_TBL
   where t1.f1 && t2.f1 and
	 t1.f1 = t2.f1
\g
retrieve (t1.all, t2.all) from t1,t2 in TINTERVAL_TBL
   where t1.f1 && t2.f1 and 
	not t1.f1 = t2.f1
\g
retrieve (t1.all) from t1 in TINTERVAL_TBL where not t1.f1 << "['Aug 15 14:23:19 1980' 'Sep 16 14:23:19 1990']"::tinterval
\g
retrieve (t1.all) from t1 in TINTERVAL_TBL where t1.f1 &&  ("Aug 15 14:23:19 1983'"::abstime <> "Sep 16 14:23:19 1983"::abstime)
\g

/******************** test built-in type box *********************/

/*
 * box logic
 *
 * 3	  o---o 
 *	  |   |
 * 2	+-+-+ |
 *	| | | |
 * 1	| o-+-o
 *	|   |
 * 0	+---+
 *
 *	0 1 2 3
 */

/* boxes are specified by two points, given by four floats x1,y1,x2,y2

*/

create BOX_TBL(f1=box)
\g
append BOX_TBL(f1 = "(2.0,2.0,0.0,0.0)")
\g
append BOX_TBL(f1 = "(1.0,1.0,3.0,3.0)")
\g
/* degenerate cases where the box is a line or a point */
/* note that lines and points boxes all have zero area */
append BOX_TBL(f1=  "(2.5, 2.5, 2.5,3.5)")
\g
append BOX_TBL(f1 = "(3.0, 3.0,3.0,3.0)")
\g
/* badly formatted box inputs */
append BOX_TBL(f1="(2.3, 4.5)")
\g
append BOX_TBL(f1="asdfasdf(ad")
\g

retrieve (BOX_TBL.all)
\g
/* overlap */
retrieve (b.f1) from b in BOX_TBL where b.f1 && "(2.5,2.5,1.0,1.0)"::box
\g
/* left overlap */
retrieve (b1.all) from b1 in BOX_TBL 
   where b1.f1 &< "(2.0,2.0,2.5,2.5)"::box
\g
/* right overlap */
retrieve (b1.all) from b1 in BOX_TBL 
   where b1.f1 &> "(2.0,2.0,2.5,2.5)"::box
\g
/* left of */
retrieve (b.f1) from b in BOX_TBL where b.f1 << "(3.0,3.0,5.0,5.0)"::box
\g
/* area <= */
retrieve (b.f1) from b in BOX_TBL where b.f1 <= "(3.0,3.0,5.0,5.0)"::box
\g
/* area < */
retrieve (b.f1) from b in BOX_TBL where b.f1 < "(3.0,3.0,5.0,5.0)"::box
\g
/* area = */
retrieve (b.f1) from b in BOX_TBL where b.f1 = "(3.0,3.0,5.0,5.0)"::box
\g
/* area > */
retrieve (b.f1) from b in BOX_TBL where b.f1 > "(3.5,3.0,4.5,3.0)"::box
\g
/* area >= */
retrieve (b.f1) from b in BOX_TBL where b.f1 >= "(3.5,3.0,4.5,3.0)"::box
\g
/* right of */
retrieve (b.f1) from b in BOX_TBL where "(3.0,3.0,5.0,5.0)"::box >> b.f1
\g
/* contained in */
retrieve (b.f1) from b in BOX_TBL where b.f1 @ "(0,0,3,3)"::box
\g
/* contains */
retrieve (b.f1) from b in BOX_TBL where "(0,0,3,3)"::box ~ b.f1
\g
/* box equality */
retrieve (b.f1) from b in BOX_TBL where "(1,1,3,3)"::box ~= b.f1
\g
/* center of box, left unary operator */
retrieve (p = @@(b1.f1)) from b1 in BOX_TBL
\g
retrieve (b1.all, b2.all) from b1, b2 in BOX_TBL
  where b1.f1 ~ b2.f1 and not b1.f1 ~= b2.f1
\g

/******************* test built-in type char ***************/
create CHAR_TBL(f1 = char)
\g
append CHAR_TBL(f1 = "a")
\g
append CHAR_TBL(f1 = "A")
\g
/* any of the following three input formats are acceptable */
append CHAR_TBL(f1 = "1")
\g
append CHAR_TBL(f1 = 2)
\g
append CHAR_TBL(f1 = '3')
\g
/* zero-length char */
append CHAR_TBL(f1 = "")
\g
/* try char's of greater than 1 length */
/* postgres truncates and ignores the rest of the string */
append CHAR_TBL(f1 = "cd")
\g

retrieve (CHAR_TBL.all)
\g
retrieve (c.all) from c in CHAR_TBL where c.f1 != "a"
\g
retrieve (c.all) from c in CHAR_TBL where c.f1 = "a"
\g
retrieve (c.all) from c in CHAR_TBL where c.f1 < "a"
\g
retrieve (c.all) from c in CHAR_TBL where c.f1 <= "a"
\g
retrieve (c.all) from c in CHAR_TBL where c.f1 > "a"
\g
retrieve (c.all) from c in CHAR_TBL where c.f1 >= "a"
\g
retrieve (x= (c.f1 * "3"::char)) from c in CHAR_TBL
\g
retrieve (x= (c.f1 + "3"::char)) from c in CHAR_TBL
\g
retrieve (x= (c.f1 - "3"::char)) from c in CHAR_TBL
\g
retrieve (x= (c.f1 / "3"::char)) from c in CHAR_TBL
\g

/***************** testing built-in type char2 ***************/
create CHAR2_TBL(f1 = char2)
\g
append CHAR2_TBL(f1 = "AB")
\g
append CHAR2_TBL(f1 = "ab")
\g
append CHAR2_TBL(f1 = "ZY")
\g
append CHAR2_TBL(f1 = "34")
\g
append CHAR2_TBL(f1 = "d")
\g
append CHAR2_TBL(f1 = "")
\g
append CHAR2_TBL(f1 = "12345")
\g

retrieve (CHAR2_TBL.all)
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 != "AB"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 = "AB"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 < "AB"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 <= "AB"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 > "AB"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 >= "AB"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 ~ ".*"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 !~ ".*"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 ~ "34"
\g
retrieve (c.f1) from c in CHAR2_TBL where c.f1 ~ "3.*"
\g


/***************** testing built-in type char4 ***************/
create CHAR4_TBL(f1 = char4)
\g
append CHAR4_TBL(f1 = "ABCD")
\g
append CHAR4_TBL(f1 = "abcd")
\g
append CHAR4_TBL(f1 = "ZYWZ")
\g
append CHAR4_TBL(f1 = "343f")
\g
append CHAR4_TBL(f1 = "d34a")
\g
append CHAR4_TBL(f1 = "")
\g
append CHAR4_TBL(f1 = "12345678")
\g

retrieve (CHAR4_TBL.all)
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 != "ABCD"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 = "ABCD"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 < "ABCD"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 <= "ABCD"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 > "ABCD"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 >= "ABCD"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 ~ ".*"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 !~ ".*"
\g
retrieve (c.f1) from c in CHAR4_TBL where c.f1 ~ ".*34.*"
\g

/***************** testing built-in type char8 ***************/
create CHAR8_TBL(f1 = char8)
\g
append CHAR8_TBL(f1 = "ABCDEFGH")
\g
append CHAR8_TBL(f1 = "abcdefgh")
\g
append CHAR8_TBL(f1 = "ZYWZ410-")
\g
append CHAR8_TBL(f1 = "343f%2a")
\g
append CHAR8_TBL(f1 = "d34aas")
\g
append CHAR8_TBL(f1 = "")
\g
append CHAR8_TBL(f1 = "1234567890")
\g

retrieve (CHAR8_TBL.all)
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 != "ABCDEFGH"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 = "ABCDEFGH"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 < "ABCDEFGH"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 <= "ABCDEFGH"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 > "ABCDEFGH"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 >= "ABCDEFGH"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 ~ ".*"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 !~ ".*"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 ~ "[0-9]"
\g
retrieve (c.f1) from c in CHAR8_TBL where c.f1 ~ ".*34.*"
\g


/***************** testing built-in type char16 ***************/
create CHAR16_TBL(f1 = char16)
\g
append CHAR16_TBL(f1 = "ABCDEFGHIJKLMNOP")
\g
append CHAR16_TBL(f1 = "abcdefghijklmnop")
\g
append CHAR16_TBL(f1 = "asdfghjkl;")
\g
append CHAR16_TBL(f1 = "343f%2a")
\g
append CHAR16_TBL(f1 = "d34aaasdf")
\g
append CHAR16_TBL(f1 = "")
\g
append CHAR16_TBL(f1 = "1234567890ABCDEFGHIJKLMNOPQRSTUV")
\g

retrieve (CHAR16_TBL.all)
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 != "ABCDEFGHIJKLMNOP"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 = "ABCDEFGHIJKLMNOP"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 < "ABCDEFGHIJKLMNOP"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 <= "ABCDEFGHIJKLMNOP"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 > "ABCDEFGHIJKLMNOP"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 >= "ABCDEFGHIJKLMNOP"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 ~ ".*"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 !~ ".*"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 ~ "[0-9]"
\g
retrieve (c.f1) from c in CHAR16_TBL where c.f1 ~ ".*asdf.*"
\g

/**************testing built-in type float4 *****************/

create FLOAT4_TBL(f1=float4)
\g
append FLOAT4_TBL(f1="0.0")
\g
append FLOAT4_TBL(f1="1004.30")
\g
append FLOAT4_TBL(f1="-34.84")
\g
append FLOAT4_TBL(f1="1.2345678901234e+20")
\g
append FLOAT4_TBL(f1="1.2345678901234e-20")
\g
/* test for over and under flow */
append FLOAT4_TBL(f1="10e40") 
\g
append FLOAT4_TBL(f1="-10e40")
\g
append FLOAT4_TBL(f1="10e-40")
\g
append FLOAT4_TBL(f1="-10e-40")
\g

retrieve (FLOAT4_TBL.all)
\g
retrieve (f.all) from f in FLOAT4_TBL where f.f1 != "1004.3"
\g
retrieve (f.all) from f in FLOAT4_TBL where f.f1 = "1004.3"
\g
retrieve (f.all) from f in FLOAT4_TBL where "1004.3" > f.f1
\g
retrieve (f.all) from f in FLOAT4_TBL where  f.f1 < "1004.3"
\g
retrieve (f.all) from f in FLOAT4_TBL where "1004.3" >= f.f1
\g
retrieve (f.all) from f in FLOAT4_TBL where  f.f1 <= "1004.3"
\g
retrieve (x= f.f1 * "-10") from f in FLOAT4_TBL where f.f1 > "0.0"
\g
retrieve (x= f.f1 + "-10") from f in FLOAT4_TBL where f.f1 > "0.0"
\g
retrieve (x= f.f1 / "-10") from f in FLOAT4_TBL where f.f1 > "0.0"
\g
retrieve (x= f.f1 - "-10") from f in FLOAT4_TBL where f.f1 > "0.0"
\g
retrieve (FLOAT4_TBL.all)
\g
/* test the unary float4abs operator */
retrieve (x = @f.f1) from f in FLOAT4_TBL
\g
replace FLOAT4_TBL(f1= FLOAT4_TBL.f1 * "-1") where FLOAT4_TBL.f1 > "0.0"
\g
retrieve (FLOAT4_TBL.all)
\g

/**************testing built-in type float8 *****************/

create FLOAT8_TBL(f1=float8)
\g
append FLOAT8_TBL(f1="0.0")
\g
append FLOAT8_TBL(f1="1004.30")
\g
append FLOAT8_TBL(f1="-34.84")
\g
append FLOAT8_TBL(f1="1.2345678901234e+200")
\g
append FLOAT8_TBL(f1="1.2345678901234e-200")
\g
/* test for over and under flow */
/* this causes floating point exceptions right now! */
append FLOAT8_TBL(f1="10e400") 
\g
append FLOAT8_TBL(f1="-10e400")
\g
append FLOAT8_TBL(f1="10e-400")
\g
append FLOAT8_TBL(f1="-10e-400")
\g

retrieve (FLOAT8_TBL.all)
\g
retrieve (f.all) from f in FLOAT8_TBL where f.f1 != "1004.3"
\g
retrieve (f.all) from f in FLOAT8_TBL where f.f1 = "1004.3"
\g
retrieve (f.all) from f in FLOAT8_TBL where "1004.3" > f.f1
\g
retrieve (f.all) from f in FLOAT8_TBL where  f.f1 < "1004.3"
\g
retrieve (f.all) from f in FLOAT8_TBL where "1004.3" >= f.f1
\g
retrieve (f.all) from f in FLOAT8_TBL where  f.f1 <= "1004.3"
\g
retrieve (x= f.f1 * "-10") from f in FLOAT8_TBL where f.f1 > "0.0"
\g
retrieve (x= f.f1 + "-10") from f in FLOAT8_TBL where f.f1 > "0.0"
\g
retrieve (x= f.f1 / "-10") from f in FLOAT8_TBL where f.f1 > "0.0"
\g
retrieve (x= f.f1 - "-10") from f in FLOAT8_TBL where f.f1 > "0.0"
\g
retrieve (x = f.f1 ^ "2.0") from f in FLOAT8_TBL
\g
/* absolute value */
retrieve (x = @f.f1) from f in FLOAT8_TBL
\g
/* truncate */
retrieve (x = %f.f1) from f in FLOAT8_TBL
\g
/* round */
retrieve (x = f.f1 %) from f in FLOAT8_TBL
\g
/* square root */
retrieve (x = |/f.f1) from f in FLOAT8_TBL where f.f1 > "0.0"
\g
/* take exp of ln(f.f1) */
retrieve (x = : ( ; f.f1) ) from f in FLOAT8_TBL where f.f1 > "0.0"
\g
/* cube root */
retrieve (x = ||/f.f1) from f in FLOAT8_TBL
\g

retrieve (FLOAT8_TBL.all)
\g
replace FLOAT8_TBL(f1= FLOAT8_TBL.f1 * "-1") where FLOAT8_TBL.f1 > "0.0"
\g
retrieve (FLOAT8_TBL.all)
\g

/**************testing built-in type int2 *****************/
create INT2_TBL(f1=int2)
\g
append INT2_TBL(f1="0")
\g
append INT2_TBL(f1="1234")
\g
append INT2_TBL(f1="-1234")
\g
/* the digits after the decimal should be ignored */
append INT2_TBL(f1="34.5")
\g
/* largest and smallest values */
append INT2_TBL(f1="32767")
\g
append INT2_TBL(f1="-32767")
\g
/* bad input values -- should give warnings */
append INT2_TBL(f1="100000")
\g
append INT2_TBL(f1="asdf")
\g

retrieve (INT2_TBL.all)
\g
retrieve (i.all) from i in INT2_TBL where i.f1 != "0"::int2
\g
retrieve (i.all) from i in INT2_TBL where i.f1 != "0"::int4
\g
retrieve (i.all) from i in INT2_TBL where i.f1 = "0"::int2
\g
retrieve (i.all) from i in INT2_TBL where i.f1 = "0"::int4
\g
retrieve (i.all) from i in INT2_TBL where i.f1 < "0"::int2
\g
retrieve (i.all) from i in INT2_TBL where i.f1 < "0"::int4
\g
retrieve (i.all) from i in INT2_TBL where i.f1 <= "0"::int2
\g
retrieve (i.all) from i in INT2_TBL where i.f1 <= "0"::int4
\g
retrieve (i.all) from i in INT2_TBL where i.f1 > "0"::int2
\g
retrieve (i.all) from i in INT2_TBL where i.f1 > "0"::int4
\g
retrieve (i.all) from i in INT2_TBL where i.f1 >= "0"::int2
\g
retrieve (i.all) from i in INT2_TBL where i.f1 >= "0"::int4
\g
retrieve (i.all) from i in INT2_TBL where (i.f1 % "2"::int2) = "1"::int2
\g
retrieve (i.all) from i in INT2_TBL where (i.f1 % "2"::int4) = "0"::int2
\g
retrieve (x = i.f1 * "2"::int2) from i in INT2_TBL
\g
retrieve (x = i.f1 * "2"::int4) from i in INT2_TBL
\g
retrieve (x = i.f1 + "2"::int2) from i in INT2_TBL
\g
retrieve (x = i.f1 + "2"::int4) from i in INT2_TBL
\g
retrieve (x = i.f1 - "2"::int2) from i in INT2_TBL
\g
retrieve (x = i.f1 - "2"::int4) from i in INT2_TBL
\g
retrieve (x = i.f1 / "2"::int2) from i in INT2_TBL
\g
retrieve (x = i.f1 / "2"::int4) from i in INT2_TBL
\g


/**************testing built-in type int4 *****************/
create INT4_TBL(f1=int4)
\g
append INT4_TBL(f1="0")
\g
append INT4_TBL(f1="123456")
\g
append INT4_TBL(f1="-123456")
\g
/* the digits after the decimal should be ignored */
append INT4_TBL(f1="34.5")
\g
/* largest and smallest values */
append INT4_TBL(f1="2147483647")
\g
append INT4_TBL(f1="-2147483647")
\g
/* bad input values -- should give warnings */
append INT4_TBL(f1="1000000000000")
\g
append INT4_TBL(f1="asdf")
\g

retrieve (INT4_TBL.all)
\g
retrieve (i.all) from i in INT4_TBL where i.f1 != "0"::int2
\g
retrieve (i.all) from i in INT4_TBL where i.f1 != "0"::int4
\g
retrieve (i.all) from i in INT4_TBL where i.f1 = "0"::int2
\g
retrieve (i.all) from i in INT4_TBL where i.f1 = "0"::int4
\g
retrieve (i.all) from i in INT4_TBL where i.f1 < "0"::int2
\g
retrieve (i.all) from i in INT4_TBL where i.f1 < "0"::int4
\g
retrieve (i.all) from i in INT4_TBL where i.f1 <= "0"::int2
\g
retrieve (i.all) from i in INT4_TBL where i.f1 <= "0"::int4
\g
retrieve (i.all) from i in INT4_TBL where i.f1 > "0"::int2
\g
retrieve (i.all) from i in INT4_TBL where i.f1 > "0"::int4
\g
retrieve (i.all) from i in INT4_TBL where i.f1 >= "0"::int2
\g
retrieve (i.all) from i in INT4_TBL where i.f1 >= "0"::int4
\g
retrieve (i.all) from i in INT4_TBL where (i.f1 % "2"::int2) = "1"::int2
\g
retrieve (i.all) from i in INT4_TBL where (i.f1 % "2"::int4) = "0"::int2
\g
retrieve (x = i.f1 * "2"::int2) from i in INT4_TBL
\g
retrieve (x = i.f1 * "2"::int4) from i in INT4_TBL
\g
retrieve (x = i.f1 + "2"::int2) from i in INT4_TBL
\g
retrieve (x = i.f1 + "2"::int4) from i in INT4_TBL
\g
retrieve (x = i.f1 - "2"::int2) from i in INT4_TBL
\g
retrieve (x = i.f1 - "2"::int4) from i in INT4_TBL
\g
retrieve (x = i.f1 / "2"::int2) from i in INT4_TBL
\g
retrieve (x = i.f1 / "2"::int4) from i in INT4_TBL
\g

/*
 * more complex expressions
 */
retrieve (true = "2"::int2 * "2"::int2 = "16"::int2 / "4"::int2)
\g
retrieve (true = "2"::int4 * "2"::int2 = "16"::int2 / "4"::int4)
\g
retrieve (true = "2"::int2 * "2"::int4 = "16"::int4 / "4"::int2)
\g
retrieve (false = "1000"::int4 < "999"::int4)
\g
retrieve (twenty_four = 4!)
\g
retrieve (six = !!3)
\g
retrieve (ten = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
\g
retrieve (three = 2 + 2 / 2)
\g
retrieve (two = (2 + 2) / 2)
\g
retrieve (eight = dsqrt("64"::float8))
\g
retrieve (eight = |/"64"::float8)
\g
retrieve (three = ||/"27"::float8)
\g


/**************testing built-in type oid *****************/
create OID_TBL(f1=oid)
\g
append OID_TBL(f1="1234")
\g
append OID_TBL(f1="1235")
\g
append OID_TBL(f1="987")
\g
append OID_TBL(f1="-1040")
\g
/* bad inputs */
append OID_TBL(f1="")
\g
append OID_TBL(f1="asdfasd")
\g
retrieve (OID_TBL.all)
\g
retrieve (o.all) from o in OID_TBL where o.f1 = "1234"
\g
retrieve (o.all) from o in OID_TBL where o.f1 != "1234"
\g
retrieve (o.all) from o in OID_TBL where o.f1 <= "1234"
\g
retrieve (o.all) from o in OID_TBL where o.f1 < "1234"
\g
retrieve (o.all) from o in OID_TBL where o.f1 >= "1234"
\g
retrieve (o.all) from o in OID_TBL where o.f1 > "1234"
\g

/**************testing built-in type oidchar16 *****************/
/* oidchar16 is a an adt for multiple key indices involving oid and char16 */
/* probably will not be used directly by most users */

create OIDCHAR16_TBL(f1=oidchar16)
\g
append OIDCHAR16_TBL(f1="1234,abcd")
\g
append OIDCHAR16_TBL(f1="1235,efgh")
\g
append OIDCHAR16_TBL(f1="987,XXXX")
\g
/* no char16 component */
append OIDCHAR16_TBL(f1="123456")
\g
/* char16 component too long */
append OIDCHAR16_TBL(f1="123456,abcdefghijklmnopqrsutvwyz")
\g
/* bad inputs */
append OIDCHAR16_TBL(f1="")
\g
append OIDCHAR16_TBL(f1="asdfasd")
\g
retrieve (OIDCHAR16_TBL.all)
\g
retrieve (o.all) from o in OIDCHAR16_TBL where o.f1 = "1234,abcd"
\g
retrieve (o.all) from o in OIDCHAR16_TBL where o.f1 != "1234,abcd"
\g
retrieve (o.all) from o in OIDCHAR16_TBL where o.f1 <= "1234,abcd"
\g
retrieve (o.all) from o in OIDCHAR16_TBL where o.f1 < "1234,abcd"
\g
retrieve (o.all) from o in OIDCHAR16_TBL where o.f1 >= "1234,abcd"
\g
retrieve (o.all) from o in OIDCHAR16_TBL where o.f1 > "1234,abcd"
\g

/**************testing built-in type oidint2 *****************/
/* oidint2 is a an adt for multiple key indices involving oid and int2 */
/* probably will not be used directly by most users */

create OIDINT2_TBL(f1=oidint2)
\g
append OIDINT2_TBL(f1="1234/9873")
\g
append OIDINT2_TBL(f1="1235/9873")
\g
append OIDINT2_TBL(f1="987/-1234")
\g
/* no int2 component */
append OIDINT2_TBL(f1="123456")
\g
/* int2 component too large */
append OIDINT2_TBL(f1="123456/123456")
\g
/* bad inputs */
append OIDINT2_TBL(f1="")
\g
append OIDINT2_TBL(f1="asdfasd")
\g
retrieve (OIDINT2_TBL.all)
\g
retrieve (o.all) from o in OIDINT2_TBL where o.f1 = "1235/9873"
\g
retrieve (o.all) from o in OIDINT2_TBL where o.f1 != "1235/9873"
\g
retrieve (o.all) from o in OIDINT2_TBL where o.f1 <= "1235/9873"
\g
retrieve (o.all) from o in OIDINT2_TBL where o.f1 < "1235/9873"
\g
retrieve (o.all) from o in OIDINT2_TBL where o.f1 >= "1235/9873"
\g
retrieve (o.all) from o in OIDINT2_TBL where o.f1 > "1235/9873"
\g

/**************testing built-in type oidint4 *****************/
/* oidint4 is a an adt for multiple key indices involving oid and int4 */
/* probably will not be used directly by most users */

create OIDINT4_TBL(f1=oidint4)
\g
append OIDINT4_TBL(f1="1234/9873")
\g
append OIDINT4_TBL(f1="1235/9873")
\g
append OIDINT4_TBL(f1="987/-1234")
\g
/* no int4 component */
append OIDINT4_TBL(f1="123456")
\g
/* int4 component too large */
append OIDINT4_TBL(f1="123456/1234568901234567890")
\g
/* bad inputs */
append OIDINT4_TBL(f1="")
\g
append OIDINT4_TBL(f1="asdfasd")
\g
retrieve (OIDINT4_TBL.all)
\g
retrieve (o.all) from o in OIDINT4_TBL where o.f1 = "1235/9873"
\g
retrieve (o.all) from o in OIDINT4_TBL where o.f1 != "1235/9873"
\g
retrieve (o.all) from o in OIDINT4_TBL where o.f1 <= "1235/9873"
\g
retrieve (o.all) from o in OIDINT4_TBL where o.f1 < "1235/9873"
\g
retrieve (o.all) from o in OIDINT4_TBL where o.f1 >= "1235/9873"
\g
retrieve (o.all) from o in OIDINT4_TBL where o.f1 > "1235/9873"
\g

/**************testing built-in type point *****************/

create POINT_TBL(f1=point)
\g
append POINT_TBL(f1="(0.0,0.0)")
\g
append POINT_TBL(f1="(-10.0,0.0)")
\g
append POINT_TBL(f1="(-3.0,4.0)")
\g
append POINT_TBL(f1="(5.1, 34.5)")
\g
append POINT_TBL(f1="(-5.0,-12.0)")
\g
/* bad format points */
append POINT_TBL(f1="asdfasdf")
\g
append POINT_TBL(f1="10.0,10.0")
\g
append POINT_TBL(f1="(10.0 10.0)")
\g
append POINT_TBL(f1="(10.0,10.0")
\g

retrieve (POINT_TBL.all)
\g
retrieve (p.all) from p in POINT_TBL where p.f1 !< "(0.0, 0.0)"
\g
retrieve (p.all) from p in POINT_TBL where "(0.0,0.0)" !> p.f1
\g
retrieve (p.all) from p in POINT_TBL where "(0.0,0.0)" !^ p.f1
\g
retrieve (p.all) from p in POINT_TBL where p.f1 !| "(0.0, 0.0)"
\g
retrieve (p.all) from p in POINT_TBL where p.f1 =|= "(5.1, 34.5)"
\g
retrieve (p.all) from p in POINT_TBL where p.f1 ---> "(0,0,100,100)"
\g
retrieve (p.all) from p in POINT_TBL where not on_pb(p.f1,"(0,0,100,100)"::box)
\g
retrieve (p.all) from p in POINT_TBL where on_ppath(p.f1,"(0,3,0,0,-10,0,-10,10)"::path)
\g
retrieve (p.f1, dist= p.f1 <---> "(0,0)") from p in POINT_TBL
\g
retrieve (p1.f1, p2.f1) from p1, p2 in POINT_TBL
   where (p1.f1 <---> p2.f1) > 3 and 
	p1.f1 !< p2.f1 and
	p1.f1 !^ p2.f1
\g


/**************testing built-in type polygon *****************/
/*
 * polygon logic
 *
 * 3	      o
 *	      |
 * 2	    + |
 *	   /  |
 * 1	  / o +
 *       /    |
 * 0	+-----o-+
 *
 *	0 1 2 3 4
 */

create POLYGON_TBL(f1=polygon)
\g
append POLYGON_TBL(f1="(2.0,2.0,0.0,0.0,4.0,0.0)")
\g
append POLYGON_TBL(f1="(3.0,3.0,1.0,1.0,3.0,0.0)")
\g
/* degenerate polygons */
append POLYGON_TBL(f1="(0.0,0.0)")
\g
append POLYGON_TBL(f1="(0.0,0.0,1.0,1.0)")
\g
/* bad polygon input strings */
append POLYGON_TBL(f1="0.0")
\g
append POLYGON_TBL(f1="(0.0 0.0")
\g
append POLYGON_TBL(f1="(0,1,2)")
\g
append POLYGON_TBL(f1="(0,1,2,3")
\g
append POLYGON_TBL(f1="asdf")
\g

retrieve (POLYGON_TBL.all)
\g

retrieve (p.all) from p in POLYGON_TBL
  where p.f1 && "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
retrieve (p.all) from p in POLYGON_TBL
  where p.f1 &< "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
retrieve (p.all) from p in POLYGON_TBL
  where p.f1 &> "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
retrieve (p.all) from p in POLYGON_TBL
  where p.f1 << "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
retrieve (p.all) from p in POLYGON_TBL
  where p.f1 >> "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
retrieve (p.all) from p in POLYGON_TBL
  where p.f1 @ "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
retrieve (p.all) from p in POLYGON_TBL
  where p.f1 ~= "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
retrieve (p.all) from p in POLYGON_TBL
  where p.f1 ~ "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g



retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &< "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* right overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* right of */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon >> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* contained in */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon @ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* contains */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* same */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~= "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon && "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g

/**************testing built-in type text  *****************/


/*
 * adt operators in the target list
 */
/* fixed-length by reference */
retrieve (false = "char 16 string"::char16 = "char 16 string "::char16)
\g
/* fixed-length by value */
retrieve (true = "c"::char = "c"::char)
\g
/* variable-length */
retrieve (true = "this is a text string"::text = "this is a text string"::text)
\g
retrieve (false = "this is a text string"::text = "this is a text strin"::text)
\g
/*
 * polygon logic
 *
 * 3	      o
 *	      |
 * 2	    + |
 *	   /  |
 * 1	  / o +
 *       /    |
 * 0	+-----o-+
 *
 *	0 1 2 3 4
 */
/* left of */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon << "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* left overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &< "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* right overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* right of */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon >> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* contained in */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon @ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* contains */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* same */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~= "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon && "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g


/*
 * qualifications
 */

/*
 * from clauses
 */

/*
 * retrieve
 */

/*
 * btree index
 * awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1
 */
retrieve (onek.all) where onek.unique1 < 10
\g
/*
 * awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
 */
retrieve (onek.unique1, onek.stringu1)
    where onek.unique1 < 20 sort by unique1 using >
\g
/*
 * awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
 */
retrieve (onek.unique1, onek.stringu1)
    where onek.unique1 > 980 sort by stringu1 using <
\g	
/*
 * awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
   sort +1d -2 +0nr -1
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 > 980 sort by string4 using <, unique1 using >
\g	
/*
 * awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
   sort +1dr -2 +0n -1
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 > 980 sort by string4 using >, unique1 using <
\g	
/*
 * awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
   sort +0nr -1 +1d -2
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 < 20 sort by unique1 using >, string4 using <
\g
/*
 * awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
   sort +0n -1 +1dr -2
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 < 20 sort by unique1 using <, string4 using >
\g
/*
 * partial btree index
 * awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1
 */
retrieve (onek2.all) where onek2.unique1 < 10
\g
/*
 * partial btree index
 * awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
 */
retrieve (onek2.unique1, onek2.stringu1)
    where onek2.unique1 < 20 sort by unique1 using >
\g
/*
 * awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
 */
retrieve (onek2.unique1, onek2.stringu1)
    where onek2.unique1 > 980 sort by stringu1 using <
\g	
retrieve into temp (onek.two, onek.stringu1, onek.ten, onek.string4)
\g
/*
 * awk '{print $3;}' onek.data | sort -n | uniq
 */
retrieve unique (temp.two) 
\g
/*
 * awk '{print $5;}' onek.data | sort -n | uniq
 */
retrieve unique (temp.ten) 
\g
/*
 * awk '{print $16;}' onek.data | sort -d | uniq
 */
retrieve unique (temp.string4) 
\g
/*
 * awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
   sort +0n -1 +1d -2 +2n -3
 */
retrieve unique (temp.two, temp.string4, temp.ten)
    sort by two using <, string4 using <, ten using <
\g
retrieve into temp1 (temp.all) where onek.unique1 < 2
\g
destroy temp1
\g
retrieve into temp1 (temp.all) where onek2.unique1 < 2
\g
destroy temp1
\g
/*
 * awk '{print $1,$2;}' person.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
   awk 'BEGIN{FS="	";}{if(NF!=2){print $4,$5;}else{print;}}' - stud_emp.data
 */
retrieve (p.name, p.age) from p in person*
\g
/*
 * awk '{print $1,$2;}' person.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
   awk 'BEGIN{FS="	";}{if(NF!=1){print $4,$5;}else{print;}}' - stud_emp.data |
   sort +1nr -2
 */
retrieve (p.name, p.age) from p in person* sort by age using >
\g
/*
 * awk '{print $2;}' person.data |
   awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
   awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
   awk 'BEGIN{FS="	";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
   sort -n -r | uniq
 */
retrieve unique (p.age) from p in person* sort by age using >
\g
/*
 * hash index
 * grep 843938989 hash.data
 */
retrieve (hasham_heap.all) where hasham_heap.random = 843938989
\g
/*
 * hash index
 * grep 66766766 hash.data
 */
retrieve (hasham_heap.all) where hasham_heap.random = 66766766
\g

/*
 * replace
 */
replace onek (unique1 = onek.unique1 + 1)
\g
replace onek (unique1 = onek.unique1 - 1)
\g
replace onek2 (unique1 = onek2.unique1 + 1)
\g
replace onek2 (unique1 = onek2.unique1 - 1)
\g
replace temp (stringu1 = reverse_c16(o.stringu1))
    from o in onek
    where o.stringu1 = "JBAAAA" and
	  o.stringu1 = temp.stringu1
\g
replace temp (stringu1 = reverse_c16(o.stringu1))
    from o in onek2
    where o.stringu1 = "JCAAAA" and
	  o.stringu1 = temp.stringu1
\g
destroy temp
\g
replace p (age = p.age + 1) from p in person*
\g
replace p (age = p.age + 3) from p in person* where p.name = "linda"
\g
replace hasham_heap (random = 1) where hasham_heap.seqno = 1492
\g
retrieve (hasham_heap.all) where hasham_heap.random = 1
\g
replace hasham_heap (seqno = 20000) where hasham_heap.random = 1492795354
\g
retrieve (hasham_heap.all) where hasham_heap.random = 1492795354
\g

/*
 * append
 * 	(is tested in create.source)
 */

/*
 * delete
 */

/*
 * queries to plan and execute each plannode and execnode we have
 */

/*
 * builtin functions
 */

/*
 * copy
 */
copy onek to "_OBJWD_/onek.data"
\g
delete onek
\g
copy onek from "_OBJWD_/onek.data"
\g
retrieve (onek.unique1) where onek.unique1 < 2
\g
delete onek2
\g
copy onek2 from "_OBJWD_/onek.data"
\g
retrieve (onek2.unique1) where onek2.unique1 < 2
\g
copy binary stud_emp to "_OBJWD_/stud_emp.data"
\g
delete stud_emp
\g
copy binary stud_emp from "_OBJWD_/stud_emp.data"
\g
retrieve (stud_emp.all)
\g
copy aggtest from stdin
\g
56	7.8
100	99.097
0	0.09561
42	324.78
.
copy aggtest to stdout
\g

/*
 * transaction blocks
 */
begin
\g
retrieve into xacttest (aggtest.all)
\g
append xacttest (a = 777, b = 777.777)
\g
end
\g
/* should retrieve one value */
retrieve (xacttest.a) where xacttest.a > 100
\g

begin
\g
create disappear (a = int4)
\g
delete aggtest
\g
/* should be empty */
retrieve (aggtest.all)
\g
abort
\g
/* should not exist */
retrieve (pg_class.oid) where pg_class.relname = "disappear"
\g
/* should have members again */
retrieve (aggtest.all)
\g

/*
 * portal manipulation
 */
begin
\g
retrieve portal foo1 (tenk1.all)
\g
retrieve portal foo2 (tenk2.all)
\g
retrieve portal foo3 (tenk1.all)
\g
retrieve portal foo4 (tenk2.all)
\g
retrieve portal foo5 (tenk1.all)
\g
retrieve portal foo6 (tenk2.all)
\g
retrieve portal foo7 (tenk1.all)
\g
retrieve portal foo8 (tenk2.all)
\g
retrieve portal foo9 (tenk1.all)
\g
retrieve portal foo10 (tenk2.all)
\g
retrieve portal foo11 (tenk1.all)
\g
retrieve portal foo12 (tenk2.all)
\g
retrieve portal foo13 (tenk1.all)
\g
retrieve portal foo14 (tenk2.all)
\g
retrieve portal foo15 (tenk1.all)
\g
retrieve portal foo16 (tenk2.all)
\g
retrieve portal foo17 (tenk1.all)
\g
retrieve portal foo18 (tenk2.all)
\g
retrieve portal foo19 (tenk1.all)
\g
retrieve portal foo20 (tenk2.all)
\g
retrieve portal foo21 (tenk1.all)
\g
retrieve portal foo22 (tenk2.all)
\g
retrieve portal foo23 (tenk1.all)
\g
fetch 1 in foo1
\g
fetch 2 in foo2
\g
fetch 3 in foo3
\g
fetch 4 in foo4
\g
fetch 5 in foo5
\g
fetch 6 in foo6
\g
fetch 7 in foo7
\g
fetch 8 in foo8
\g
fetch 9 in foo9
\g
fetch 10 in foo10
\g
fetch 11 in foo11
\g
fetch 12 in foo12
\g
fetch 13 in foo13
\g
fetch 14 in foo14
\g
fetch 15 in foo15
\g
fetch 16 in foo16
\g
fetch 17 in foo17
\g
fetch 18 in foo18
\g
fetch 19 in foo19
\g
fetch 20 in foo20
\g
fetch 21 in foo21
\g
fetch 22 in foo22
\g
fetch 23 in foo23
\g
fetch backward 1 in foo23
\g
fetch backward 2 in foo22
\g
fetch backward 3 in foo21
\g
fetch backward 4 in foo20
\g
fetch backward 5 in foo19
\g
fetch backward 6 in foo18
\g
fetch backward 7 in foo17
\g
fetch backward 8 in foo16
\g
fetch backward 9 in foo15
\g
fetch backward 10 in foo14
\g
fetch backward 11 in foo13
\g
fetch backward 12 in foo12
\g
fetch backward 13 in foo11
\g
fetch backward 14 in foo10
\g
fetch backward 15 in foo9
\g
fetch backward 16 in foo8
\g
fetch backward 17 in foo7
\g
fetch backward 18 in foo6
\g
fetch backward 19 in foo5
\g
fetch backward 20 in foo4
\g
fetch backward 21 in foo3
\g
fetch backward 22 in foo2
\g
fetch backward 23 in foo1
\g
close foo1
\g
close foo2
\g
close foo3
\g
close foo4
\g
close foo5
\g
close foo6
\g
close foo7
\g
close foo8
\g
close foo9
\g
close foo10
\g
close foo11
\g
close foo12
\g
end
\g
extend index onek2_u1_prtl where onek2.unique1 <= 60
\g
begin
\g
retrieve portal foo13 (onek.all) where onek.unique1 = 50
\g
retrieve portal foo14 (onek.all) where onek.unique1 = 51
\g
retrieve portal foo15 (onek.all) where onek.unique1 = 52
\g
retrieve portal foo16 (onek.all) where onek.unique1 = 53
\g
retrieve portal foo17 (onek.all) where onek.unique1 = 54
\g
retrieve portal foo18 (onek.all) where onek.unique1 = 55
\g
retrieve portal foo19 (onek.all) where onek.unique1 = 56
\g
retrieve portal foo20 (onek.all) where onek.unique1 = 57
\g
retrieve portal foo21 (onek.all) where onek.unique1 = 58
\g
retrieve portal foo22 (onek.all) where onek.unique1 = 59
\g
retrieve portal foo23 (onek.all) where onek.unique1 = 60
\g
retrieve portal foo24 (onek2.all) where onek2.unique1 = 50
\g
retrieve portal foo25 (onek2.all) where onek2.unique1 = 60
\g
fetch all in foo13
\g
fetch all in foo14
\g
fetch all in foo15
\g
fetch all in foo16
\g
fetch all in foo17
\g
fetch all in foo18
\g
fetch all in foo19
\g
fetch all in foo20
\g
fetch all in foo21
\g
fetch all in foo22
\g
fetch all in foo23
\g
fetch all in foo24
\g
fetch all in foo25
\g
close foo13
\g
close foo14
\g
close foo15
\g
close foo16
\g
close foo17
\g
close foo18
\g
close foo19
\g
close foo20
\g
close foo21
\g
close foo22
\g
close foo23
\g
close foo24
\g
close foo25
\g
end
\g

/*
 * purge
 */

/*
 * add attribute
 */
create temp (initial = int4)
\g
addattr (a = int4) to temp
\g
addattr
    (b = char16,
     c = text,
     d = float8,
     e = float4,
     f = int2,
     g = polygon,
     h = abstime,
     i = char,
     j = abstime[],
     k = dt,
     l = tid,
     m = xid,
     n = oid8,
     o = lock,
     p = smgr,
     q = point,
     r = lseg,
     s = path,
     t = box,
     u = tinterval,
     v = oidint4,
     w = oidchar16,
     x = float8[],
     y = float4[],
     z = int2[])
to temp
\g
append temp (a=4,
	     b="char16",
	     c="text",
	     d=4.1,
	     e=4.1,
	     f=2,
	     g="(4.1,4.1,3.1,3.1)",
	     h="now",
	     i='c',
	     j="{now, Monday Aug 24 14:43:07 1992 PDT, epoch}",
	     k=314159,
	     l="(1,0,1)",
	     m=512,
	     n="1 2 3 4 5 6 7 8",
	     p="magnetic disk",
	     q="(1.1,1.1)",
	     r="(4.1,4.1,3.1,3.1)",
	     s="(0,2,4.1,4.1,3.1,3.1)",
	     t="(4.1,4.1,3.1,3.1)",
	     u="['current' 'infinity']",
	     v="1/3",
	     w="1,char16",
	     x="{1.0,2.0,3.0,4.0}",
	     y="{1.0,2.0,3.0,4.0}",
	     z="{1,2,3,4}")
\g
retrieve (temp.all)
\g
destroy temp
\g

/*
 * rename -
 *   should preserve indices
 */
rename tenk1 to ten_k
\g
/* 20 values, sorted */
retrieve (ten_k.unique1) where ten_k.unique1 < 20
\g
/* 20 values, sorted */
retrieve (ten_k.unique2) where ten_k.unique2 < 20
\g
/* 100 values, sorted */
retrieve (ten_k.hundred) where ten_k.hundred = 50
\g
rename ten_k to tenk1
\g
/* 5 values, sorted */
retrieve (tenk1.unique1) where tenk1.unique1 < 5
\g

/*
 * AGGREGATES
 */
retrieve (avg_1 = int4ave{onek.four})
\g
retrieve (avg_32 = int2ave{aggtest.a where aggtest.a < 100})
\g
retrieve (avg_107_943 = float4ave{aggtest.b})
\g
retrieve (avg_3_4 = float8ave{student.gpa})
\g

retrieve (sum_1500 = int4sum{onek.four})
\g
retrieve (sum_198 = int2sum{aggtest.a})
\g
retrieve (avg_431_773 = float4sum{aggtest.b})
\g
retrieve (avg_6_8 = float8sum{student.gpa})
\g

retrieve (max_3 = int4max{onek.four})
\g
retrieve (max_100 = int2max{aggtest.a})
\g
retrieve (max_324_78 = float4max{aggtest.b})
\g
retrieve (max_3_7 = float8max{student.gpa})
\g

retrieve (cnt_1000 = count{onek.four})
\g

retrieve (avg_1 = newavg{onek.four})
\g
retrieve (sum_1500 = newsum{onek.four})
\g
retrieve (cnt_1000 = newcnt{onek.four})
\g

/*
 * versions
 */

/*
 * listen,notify - not sure how to do this yet, may need a multi-user
 *                 portion of the regression test.  These commands
 *                 would fall under that category.
 */

/*
 * postquel functions
 */
/*
 * mike does post_hacking,
 * joe and sally play basketball, and
 * everyone else does nothing.
 */
retrieve (p.name, p.hobbies.name) from p in person
\g
/*
 * as above, but jeff also does post_hacking.
 */
retrieve (p.name, p.hobbies.name) from p in person*
\g
/*
 * the next two queries demonstrate how functions generate bogus duplicates.
 * this is a "feature" ..
 */
retrieve unique (hobbies_r.name, hobbies_r.equipment.name)
\g
retrieve (hobbies_r.name, hobbies_r.equipment.name)
\g
/*
 * mike needs advil and peet's coffee,
 * joe and sally need hightops, and
 * everyone else is fine.
 */
retrieve (p.name, p.hobbies.name, p.hobbies.equipment.name) from p in person
\g
/*
 * as above, but jeff needs advil and peet's coffee as well.
 */
retrieve (p.name, p.hobbies.name, p.hobbies.equipment.name) from p in person*
\g
/*
 * just like the last two, but make sure that the target list fixup and
 * unflattening is being done correctly.
 */
retrieve (p.hobbies.equipment.name, p.name, p.hobbies.name) from p in person
\g
retrieve (p.hobbies.equipment.name, p.name, p.hobbies.name) from p in person*
\g
retrieve (p.hobbies.equipment.name, p.hobbies.name, p.name) from p in person
\g
retrieve (p.hobbies.equipment.name, p.hobbies.name, p.name) from p in person*
\g
retrieve (user_relns = user_relns())
\g
retrieve (equip_name =
	    name(equipment(hobby_construct("skywalking"::text, "mer"::text))))
\g

/*
 * functional joins
 */

/*
 * instance rules
 */

/*
 * rewrite rules
 */

/*
 * ARRAYS
 */
retrieve (arrtest.all)
\g
retrieve (arrtest.a[1],
          arrtest.b[1][1][1],
          arrtest.c[1],
          arrtest.d[1][1], 
          arrtest.e[0])
\g
retrieve (arrtest.a[1:3],
          arrtest.b[1:1][1:2][1:2],
          arrtest.c[1:2], 
          arrtest.d[1:1][1:2])
\g
/* returns three different results */
retrieve (x = array_dims(arrtest.b))
\g
/* returns nothing */
retrieve (arrtest.all)
         where arrtest.a[1] < 5 and 
               arrtest.c = "{"foobar"}"::_char16
\g
replace arrtest (a[1:2] = "{16,25}",
                 b[1:1][1:1][1:2] = "{113, 117}", 
                 c[1:1] = "{"new_word"}")
\g
retrieve (arrtest.a[1:3],
          arrtest.b[1:1][1:2][1:2],
          arrtest.c[1:2], 
          arrtest.d[1:1][1:2])
\g

/*
 * expensive functions
 */

/*
 * UNTRUSTED FUNCTIONS
 */
/* 0 arguments */
retrieve (forty_two = ufp0())
\g
/* 1 argument, pass-by-value arguments/return-values */
/* also: multiple functions per file */
retrieve (sixteen = ufp1(15))
\g
/* >1 argument, pass-by-reference fixed-length arguments/return-values */
/* also: linking to C library */
retrieve (postgres = ufp2("post"::char16,"gres"::char16))
\g
/* pass-by-reference variable-length arguments/return-values */
/* also: linking to UFP code */
retrieve (postgres = ufp3("postgres rules ok"::text, " "::char))
\g

/*
 * SECURITY CRUFT
 */
replace pg_class (relacl="{}")
	where pg_class.relname !~ "pg_*"::text
\g
replace pg_user (usesuper="f"::bool) where pg_user.usename = "_USER_"
\g

create myclass0 (a=int4)
\g

/* these should all succeed */
append myclass0 (a=5)
\g
retrieve (myclass0.a)
\g
replace myclass0 (a=6)
\g
append myclass0 (a=10)
\g
append myclass0 (a=20)
\g
replace myclass0 (a=10) where myclass0.a < 10
\g
replace myclass0 (a=myclass0.a+1)
\g
delete myclass0 where myclass0.a > 15
\g
define rule foo is on retrieve to myclass0 do instead nothing
\g
remove rule foo
\g

change acl _USER_-arR myclass0
\g

/* succeeds */
replace myclass0 (a=1)
\g
/* succeeds (we still have write permission) */
append myclass0 (a=100)
\g
