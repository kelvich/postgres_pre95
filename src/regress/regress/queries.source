/*
 * queries.source
 *
 * $Header$
 */

/*
 * --- operators and target lists ---
 */

/*
 * sanity check - if this fails go insane!
 */
retrieve (one = 1)
\g

/*
 * start with some math/logic (who needs bc?)
 */

/*
 * boolean logic
 */
retrieve (true="t"::bool)
\g
retrieve (false="f"::bool)
\g
retrieve (true="t"::bool or "f"::bool)
\g
retrieve (false="t"::bool and "f"::bool)
\g
retrieve (true = not "f"::bool)
\g
retrieve (false = "t"::bool = "f"::bool)
\g
retrieve (true = "t"::bool != "f"::bool)
\g
/*
 * int24 logic 
 */
retrieve (true = "2"::int2 = "2"::int4)
\g
retrieve (false = "1"::int2 = "2"::int4)
\g
retrieve (false = "2"::int2 != "2"::int4)
\g
retrieve (true = "1"::int2 != "2"::int4)
\g
retrieve (true = "2"::int2 <= "2"::int4)
\g
retrieve (true = "1"::int2 <= "2"::int4)
\g
retrieve (false = "2"::int2 < "2"::int4)
\g
retrieve (false = "2"::int2 > "2"::int4)
\g
retrieve (true = "1"::int2 < "2"::int4)
\g
retrieve (true = "3"::int2 > "2"::int4)
\g
retrieve (true = "2"::int2 >= "2"::int4)
\g
retrieve (true = "3"::int2 >= "2"::int4)
\g
retrieve (true = "2"::int2 <= "2"::int4)
\g
retrieve (true = "1"::int2 <= "2"::int4)
\g
/*
 * int42 logic
 */
retrieve (true = "2"::int4 = "2"::int2)
\g
retrieve (false = "1"::int4 = "2"::int2)
\g
retrieve (false = "2"::int4 != "2"::int2)
\g
retrieve (true = "1"::int4 != "2"::int2)
\g
retrieve (true = "2"::int4 <= "2"::int2)
\g
retrieve (true = "1"::int4 <= "2"::int2)
\g
retrieve (false = "2"::int4 < "2"::int2)
\g
retrieve (false = "2"::int4 > "2"::int2)
\g
retrieve (true = "1"::int4 < "2"::int2)
\g
retrieve (true = "3"::int4 > "2"::int2)
\g
retrieve (true = "2"::int4 >= "2"::int2)
\g
retrieve (true = "3"::int4 >= "2"::int2)
\g
retrieve (true = "2"::int4 <= "2"::int2)
\g
retrieve (true = "1"::int4 <= "2"::int2)
\g
/*
 * int4 logic
 */
retrieve (true = "2"::int4 = "2"::int4)
\g
retrieve (false = "1"::int4 = "2"::int4)
\g
retrieve (false = "2"::int4 != "2"::int4)
\g
retrieve (true = "1"::int4 != "2"::int4)
\g
retrieve (true = "2"::int4 <= "2"::int4)
\g
retrieve (true = "1"::int4 <= "2"::int4)
\g
retrieve (false = "2"::int4 < "2"::int4)
\g
retrieve (false = "2"::int4 > "2"::int4)
\g
retrieve (true = "1"::int4 < "2"::int4)
\g
retrieve (true = "3"::int4 > "2"::int4)
\g
retrieve (true = "2"::int4 >= "2"::int4)
\g
retrieve (true = "3"::int4 >= "2"::int4)
\g
retrieve (true = "2"::int4 <= "2"::int4)
\g
retrieve (true = "1"::int4 <= "2"::int4)
\g
/*
 * int2 logic
 */
retrieve (true = "2"::int2 = "2"::int2)
\g
retrieve (false = "1"::int2 = "2"::int2)
\g
retrieve (false = "2"::int2 != "2"::int2)
\g
retrieve (true = "1"::int2 != "2"::int2)
\g
retrieve (false = "2"::int2 < "2"::int2)
\g
retrieve (false = "2"::int2 > "2"::int2)
\g
retrieve (true = "1"::int2 < "2"::int2)
\g
retrieve (true = "3"::int2 > "2"::int2)
\g
retrieve (true = "2"::int2 >= "2"::int2)
\g
retrieve (true = "3"::int2 >= "2"::int2)
\g
retrieve (true = "2"::int2 <= "2"::int2)
\g
retrieve (true = "1"::int2 <= "2"::int2)
\g
/*
 * int42 arithmetic
 */
retrieve (three = "1"::int4 + "2"::int2)
\g
retrieve (neg_one = "1"::int4 - "2"::int2)
\g
retrieve (two = "1"::int4 * "2"::int2)
\g
retrieve (one = "2"::int4 / "2"::int2)
\g
retrieve (zero = "27"::int4 % "3"::int2)
\g
/*
 * int24 arithmetic
 */
retrieve (three = "1"::int2 + "2"::int4)
\g
retrieve (neg_one = "1"::int2 - "2"::int4)
\g
retrieve (two = "1"::int2 * "2"::int4)
\g
retrieve (one = "2"::int2 / "2"::int4)
\g
retrieve (zero = "27"::int2 % "3"::int4)
\g
/*
 * int2 arithmetic
 */
retrieve (three = "1"::int2 + "2"::int2)
\g
retrieve (neg_one = "1"::int2 - "2"::int2)
\g
retrieve (two = "1"::int2 * "2"::int2)
\g
retrieve (one = "2"::int2 / "2"::int2)
\g
retrieve (zero = "27"::int2 % "3"::int2)
\g
retrieve (neg_seven = - "7"::int2)
\g
/*
 * int4 arithmetic
 */
retrieve (three = "1"::int4 + "2"::int4)
\g
retrieve (neg_one = "1"::int4 - "2"::int4)
\g
retrieve (two = "1"::int4 * "2"::int4)
\g
retrieve (one = "2"::int4 / "2"::int4)
\g
retrieve (zero = "27"::int4 % "3"::int4)
\g
retrieve (neg_seven = - "7"::int4)
\g
/*
 * float8 arithmetic
 */
retrieve (three = "1"::float8 + "2"::float8)
\g
retrieve (neg_one = "1"::float8 - "2"::float8)
\g
retrieve (two = "1"::float8 * "2"::float8)
\g
retrieve (one = "2"::float8 / "2"::float8)
\g
retrieve (neg_seven = - "7"::float8)
\g
/*
 * float8 truncation and rounding
 */
retrieve (one = % "1.1"::float8)
\g
retrieve (neg_one = % "-1.1"::float8)
\g
retrieve (one = "0.9"::float8 % )
\g
retrieve (neg_one = "-0.9"::float8 % )
\g
retrieve (pos_3 = @ "-3"::float8)
\g
retrieve (pos_3 = @ "3"::float8)
\g
retrieve (onek = "2.0"::float8 ^ "10.0"::float8)
\g
retrieve (e = : "1.0"::float8)
\g
retrieve (zero = ; "1.0"::float8)
\g
retrieve (one = : (; "1.0"::float8))
\g
retrieve (one = : ; "1.0"::float8)
\g
/*
 * float4 arithmetic
 */
retrieve (three = "1"::float4 + "2"::float4)
\g
retrieve (neg_one = "1"::float4 - "2"::float4)
\g
retrieve (two = "1"::float4 * "2"::float4)
\g
retrieve (one = "2"::float4 / "2"::float4)
\g
retrieve (neg_seven = - "7"::float4)
\g
retrieve (pos_3 = @ "-3"::float4)
\g
retrieve (pos_3 = @ "3"::float4)
\g
/*
 * more complex expressions
 */
retrieve (true = "2"::int2 * "2"::int2 = "16"::int2 / "4"::int2)
\g
retrieve (true = "2"::int4 * "2"::int2 = "16"::int2 / "4"::int4)
\g
retrieve (true = "2"::int2 * "2"::int4 = "16"::int4 / "4"::int2)
\g
retrieve (false = "1000"::int4 < "999"::int4)
\g
retrieve (twenty_four = 4!)
\g
retrieve (six = !!3)
\g
retrieve (ten = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
\g
retrieve (three = 2 + 2 / 2)
\g
retrieve (two = (2 + 2) / 2)
\g
retrieve (eight = dsqrt("64"::float8))
\g
retrieve (eight = |/"64"::float8)
\g
retrieve (three = ||/"27"::float8)
\g

/*
 * adt operators in the target list
 */
retrieve (false = "char 16 string"::char16 = "char 16 string "::char16)
\g
retrieve (true = "c"::char = "c"::char)
\g
retrieve (true = "this is a text string"::char16 = "this is a text string"::char16)
\g
retrieve (false = "this is a text string"::char16 = "this is a text strin"::char16)
\g
/*
 * box logic
 */
retrieve (true = "(2.0,2.0,0.0,0.0)"::box << "(3.0,3.0,1.0,1.0)"::box)
\g
retrieve (true = "(2.0,2.0,0.0,0.0)"::box &< "(3.0,3.0,1.0,1.0)"::box)
\g
retrieve (true = "(2.0,2.0,0.0,0.0)"::box &> "(3.0,3.0,1.0,1.0)"::box)
\g
retrieve (false = "(2.0,2.0,0.0,0.0)"::box >> "(3.0,3.0,1.0,1.0)"::box)
\g
retrieve (false = "(2.0,2.0,0.0,0.0)"::box @ "(3.0,3.0,1.0,1.0)"::box)
\g
retrieve (false = "(2.0,2.0,0.0,0.0)"::box ~ "(3.0,3.0,1.0,1.0)"::box)
\g
retrieve (false = "(2.0,2.0,0.0,0.0)"::box ~= "(3.0,3.0,1.0,1.0)"::box)
\g
retrieve (true = "(2.0,2.0,0.0,0.0)"::box && "(3.0,3.0,1.0,1.0)"::box)
\g
/*
 * polygon logic -  (anemic tests)
 */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon << "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &< "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon >> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon @ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~= "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon && "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/*
 * abstime logic
 */

/*
 * reltime logic
 */


/*
 * qualifications
 */

/*
 * from clauses
 */

/*
 * retrieve
 */
retrieve (onek.all) where onek.unique1 < 10
\g
retrieve (onek.unique1, onek.stringu1)
    where onek.unique1 < 20 sort by unique1 using >
\g
retrieve (onek.unique1, onek.stringu1)
    where onek.unique1 > 980 sort by stringu1 using <
\g	
retrieve (onek.unique1, onek.string4)
    where onek.unique1 > 980 sort by string4 using <, unique1 using >
\g	
retrieve (onek.unique1, onek.string4)
    where onek.unique1 > 980 sort by string4 using >, unique1 using <
\g	
retrieve (onek.unique1, onek.string4)
    where onek.unique1 < 20 sort by unique1 using >, string4 using <
\g
retrieve (onek.unique1, onek.string4)
    where onek.unique1 < 20 sort by unique1 using <, string4 using >
\g
retrieve (onek2.all) where onek2.unique1 < 10
\g
retrieve (onek2.unique1, onek2.stringu1)
    where onek2.unique1 < 20 sort by unique1 using >
\g
retrieve (onek2.unique1, onek2.stringu1)
    where onek2.unique1 > 980 sort by stringu1 using <
\g	
retrieve into temp (onek.two, onek.stringu1, onek.ten, onek.string4)
\g
retrieve unique (temp.two) 
\g
retrieve unique (temp.ten) 
\g
retrieve unique (temp.string4) 
\g
retrieve unique (temp.two, temp.string4, temp.ten)
    sort by two using <, string4 using <, ten using <
\g
retrieve into temp1 (temp.all) where onek.unique1 < 2
\g
destroy temp1
\g
retrieve into temp1 (temp.all) where onek2.unique1 < 2
\g
destroy temp1
\g
retrieve (p.name, p.age) from p in person*
\g
retrieve (p.name, p.age) from p in person* sort by age using >
\g
retrieve unique (p.age) from p in person* sort by age using >
\g

/*
 * replace
 */
replace onek (unique1 = onek.unique1 + 1)
\g
replace onek (unique1 = onek.unique1 - 1)
\g
replace onek2 (unique1 = onek2.unique1 + 1)
\g
replace onek2 (unique1 = onek2.unique1 - 1)
\g
replace temp (stringu1 = reverse_c16(o.stringu1))
    from o in onek
    where o.stringu1 = "JBAAAA" and
	  o.stringu1 = temp.stringu1
\g
replace temp (stringu1 = reverse_c16(o.stringu1))
    from o in onek2
    where o.stringu1 = "JCAAAA" and
	  o.stringu1 = temp.stringu1
\g
destroy temp
\g
replace p (age = p.age + 1) from p in person*
\g
replace p (age = p.age + 3) from p in person* where p.name = "linda"
\g

/*
 * append
 * 	(is tested in create.source)
 */

/*
 * delete
 */

/*
 * queries to plan and execute each plannode and execnode we have
 */

/*
 * builtin functions
 */

/*
 * copy
 */
copy onek to "_CWD_/obj/onek.data"
\g
delete onek
\g
copy onek from "_CWD_/obj/onek.data"
\g
retrieve (onek.unique1) where onek.unique1 < 2
\g
delete onek2
\g
copy onek2 from "_CWD_/obj/onek.data"
\g
retrieve (onek2.unique1) where onek2.unique1 < 2
\g
copy binary stud_emp to "_CWD_/obj/stud_emp.data"
\g
delete stud_emp
\g
copy binary stud_emp from "_CWD_/obj/stud_emp.data"
\g
retrieve (stud_emp.all)
\g

/*
 * transaction blocks
 */
begin
\g
retrieve into xacttest (aggtest.all)
\g
append xacttest (a = 777, b = 777.777)
\g
end
\g
/* should retrieve one value */
retrieve (xacttest.a) where xacttest.a > 100
\g

begin
\g
create disappear (a = int4)
\g
delete aggtest
\g
/* should be empty */
retrieve (aggtest.all)
\g
abort
\g
/* should not exist */
retrieve (pg_class.oid) where pg_class.relname = "disappear"
\g
/* should have members again */
retrieve (aggtest.all)
\g

/*
 * portal manipulation
 */
begin
\g
retrieve portal foo1 (tenk1.all)
\g
retrieve portal foo2 (tenk2.all)
\g
retrieve portal foo3 (tenk1.all)
\g
retrieve portal foo4 (tenk2.all)
\g
retrieve portal foo5 (tenk1.all)
\g
retrieve portal foo6 (tenk2.all)
\g
retrieve portal foo7 (tenk1.all)
\g
retrieve portal foo8 (tenk2.all)
\g
retrieve portal foo9 (tenk1.all)
\g
retrieve portal foo10 (tenk2.all)
\g
retrieve portal foo11 (tenk1.all)
\g
retrieve portal foo12 (tenk2.all)
\g
retrieve portal foo13 (tenk1.all)
\g
retrieve portal foo14 (tenk2.all)
\g
retrieve portal foo15 (tenk1.all)
\g
retrieve portal foo16 (tenk2.all)
\g
retrieve portal foo17 (tenk1.all)
\g
retrieve portal foo18 (tenk2.all)
\g
retrieve portal foo19 (tenk1.all)
\g
retrieve portal foo20 (tenk2.all)
\g
retrieve portal foo21 (tenk1.all)
\g
retrieve portal foo22 (tenk2.all)
\g
retrieve portal foo23 (tenk1.all)
\g
fetch 1 in foo1
\g
fetch 2 in foo2
\g
fetch 3 in foo3
\g
fetch 4 in foo4
\g
fetch 5 in foo5
\g
fetch 6 in foo6
\g
fetch 7 in foo7
\g
fetch 8 in foo8
\g
fetch 9 in foo9
\g
fetch 10 in foo10
\g
fetch 11 in foo11
\g
fetch 12 in foo12
\g
fetch 13 in foo13
\g
fetch 14 in foo14
\g
fetch 15 in foo15
\g
fetch 16 in foo16
\g
fetch 17 in foo17
\g
fetch 18 in foo18
\g
fetch 19 in foo19
\g
fetch 20 in foo20
\g
fetch 21 in foo21
\g
fetch 22 in foo22
\g
fetch 23 in foo23
\g
fetch backward 1 in foo23
\g
fetch backward 2 in foo22
\g
fetch backward 3 in foo21
\g
fetch backward 4 in foo20
\g
fetch backward 5 in foo19
\g
fetch backward 6 in foo18
\g
fetch backward 7 in foo17
\g
fetch backward 8 in foo16
\g
fetch backward 9 in foo15
\g
fetch backward 10 in foo14
\g
fetch backward 11 in foo13
\g
fetch backward 12 in foo12
\g
fetch backward 13 in foo11
\g
fetch backward 14 in foo10
\g
fetch backward 15 in foo9
\g
fetch backward 16 in foo8
\g
fetch backward 17 in foo7
\g
fetch backward 18 in foo6
\g
fetch backward 19 in foo5
\g
fetch backward 20 in foo4
\g
fetch backward 21 in foo3
\g
fetch backward 22 in foo2
\g
fetch backward 23 in foo1
\g
close foo1
\g
close foo2
\g
close foo3
\g
close foo4
\g
close foo5
\g
close foo6
\g
close foo7
\g
close foo8
\g
close foo9
\g
close foo10
\g
close foo11
\g
close foo12
\g
end
\g
extend index onek2_u1_prtl where onek2.unique1 <= 60
\g
begin
\g
retrieve portal foo13 (onek.all) where onek.unique1 = 50
\g
retrieve portal foo14 (onek.all) where onek.unique1 = 51
\g
retrieve portal foo15 (onek.all) where onek.unique1 = 52
\g
retrieve portal foo16 (onek.all) where onek.unique1 = 53
\g
retrieve portal foo17 (onek.all) where onek.unique1 = 54
\g
retrieve portal foo18 (onek.all) where onek.unique1 = 55
\g
retrieve portal foo19 (onek.all) where onek.unique1 = 56
\g
retrieve portal foo20 (onek.all) where onek.unique1 = 57
\g
retrieve portal foo21 (onek.all) where onek.unique1 = 58
\g
retrieve portal foo22 (onek.all) where onek.unique1 = 59
\g
retrieve portal foo23 (onek.all) where onek.unique1 = 60
\g
retrieve portal foo24 (onek2.all) where onek2.unique1 = 50
\g
retrieve portal foo25 (onek2.all) where onek2.unique1 = 60
\g
fetch all in foo13
\g
fetch all in foo14
\g
fetch all in foo15
\g
fetch all in foo16
\g
fetch all in foo17
\g
fetch all in foo18
\g
fetch all in foo19
\g
fetch all in foo20
\g
fetch all in foo21
\g
fetch all in foo22
\g
fetch all in foo23
\g
fetch all in foo24
\g
fetch all in foo25
\g
close foo13
\g
close foo14
\g
close foo15
\g
close foo16
\g
close foo17
\g
close foo18
\g
close foo19
\g
close foo20
\g
close foo21
\g
close foo22
\g
close foo23
\g
close foo24
\g
close foo25
\g
end
\g

/*
 * purge
 */

/*
 * add attribute
 */
create temp (initial = int4)
\g
addattr (a = int4) to temp
\g
addattr
    (b = char16,
     c = text,
     d = float8,
     e = float4,
     f = int2,
     g = polygon,
     h = abstime,
     i = char,
     j = abstime[],
     k = dt,
     l = tid,
     m = xid,
     n = oid8,
     o = lock,
     p = smgr,
     q = point,
     r = lseg,
     s = path,
     t = box,
     u = tinterval,
     v = oidint4,
     w = oidchar16,
     x = float8[],
     y = float4[],
     z = int2[])
to temp
\g
append temp (a=4,
	     b="char16",
	     c="text",
	     d=4.1,
	     e=4.1,
	     f=2,
	     g="(4.1,4.1,3.1,3.1)",
	     h="now",
	     i='c',
	     j="{now, Monday Aug 24 14:43:07 1992 PDT, epoch}",
	     k=314159,
	     l="(1,0,1)",
	     m=512,
	     n="1 2 3 4 5 6 7 8",
	     p="magnetic disk",
	     q="(1.1,1.1)",
	     r="(4.1,4.1,3.1,3.1)",
	     s="(0,2,4.1,4.1,3.1,3.1)",
	     t="(4.1,4.1,3.1,3.1)",
	     u="['current' 'infinity']",
	     v="1/3",
	     w="1,char16",
	     x="{1.0,2.0,3.0,4.0}",
	     y="{1.0,2.0,3.0,4.0}",
	     z="{1,2,3,4}")
\g
retrieve (temp.all)
\g
destroy temp
\g

/*
 * rename -
 *   should preserve indices
 */
rename tenk1 to ten_k
\g
retrieve (ten_k.unique1) where ten_k.unique1 < 20
\g
retrieve (ten_k.unique2) where ten_k.unique2 < 20
\g
retrieve (ten_k.hundred) where ten_k.hundred = 50
\g
rename ten_k to tenk1
\g
retrieve (tenk1.unique1) where tenk1.unique1 < 5
\g

/*
 * AGGREGATES
 */
retrieve (avg_1 = int4ave{onek.four})
\g
retrieve (avg_32 = int2ave{aggtest.a where aggtest.a < 100})
\g
retrieve (avg_107_943 = float4ave{aggtest.b})
\g
retrieve (avg_3_4 = float8ave{student.gpa})
\g

retrieve (sum_1500 = int4sum{onek.four})
\g
retrieve (sum_198 = int2sum{aggtest.a})
\g
retrieve (avg_431_773 = float4sum{aggtest.b})
\g
retrieve (avg_6_8 = float8sum{student.gpa})
\g

retrieve (max_3 = int4max{onek.four})
\g
retrieve (max_100 = int2max{aggtest.a})
\g
retrieve (max_324_78 = float4max{aggtest.b})
\g
retrieve (max_3_7 = float8max{student.gpa})
\g

retrieve (cnt_1000 = count{onek.four})
\g

retrieve (avg_1 = newavg{onek.four})
\g
retrieve (sum_1500 = newsum{onek.four})
\g
retrieve (cnt_1000 = newcnt{onek.four})
\g

/*
 * versions
 */

/*
 * listen,notify - not sure how to do this yet, may need a multi-user
 *                 portion of the regression test.  These commands
 *                 would fall under that category.
 */

/*
 * postquel functions
 */
retrieve (p.name, p.hobbies.name) from p in person
\g
retrieve (p.name, p.hobbies.name) from p in person*
\g
retrieve unique (hobbies_r.name, hobbies_r.equipment.name)
\g
retrieve (hobbies_r.name, hobbies_r.equipment.name)
\g
retrieve (p.name, p.hobbies.name, p.hobbies.equipment.name) from p in person
\g
retrieve (p.name, p.hobbies.name, p.hobbies.equipment.name) from p in person*
\g
retrieve (p.hobbies.equipment.name, p.name, p.hobbies.name) from p in person
\g
retrieve (p.hobbies.equipment.name, p.name, p.hobbies.name) from p in person*
\g
retrieve (p.hobbies.equipment.name, p.hobbies.name, p.name) from p in person
\g
retrieve (p.hobbies.equipment.name, p.hobbies.name, p.name) from p in person*
\g
retrieve (user_relns = user_relns())
\g
retrieve (equip_name =
	    name(equipment(hobby_construct("skywalking"::text, "mer"::text))))
\g

/*
 * functional joins
 */

/*
 * instance rules
 */

/*
 * rewrite rules
 */

/*
 * ARRAYS
 */
retrieve (arrtest.all)
\g
retrieve (arrtest.a[1], arrtest.b[1][1][1], arrtest.c[1], arrtest.d[1][1], 
			arrtest.e[0])
\g
retrieve (arrtest.a[1:3], arrtest.b[1:1][1:2][1:2], arrtest.c[1:2], 
			arrtest.d[1:1][1:2])
\g
retrieve (x = array_dims(arrtest.b))
\g
retrieve (arrtest.all) where arrtest.a[1] < 5 and 
					arrtest.c = "{"foobar"}"::_char16
\g
replace arrtest (a[1:2] = "{16,25}", b[1:1][1:1][1:2] = "{113, 117}", 
				c[1:1] = "{"new_word"}")
\g
retrieve (arrtest.a[1:3], arrtest.b[1:1][1:2][1:2], arrtest.c[1:2], 
			arrtest.d[1:1][1:2])
\g

/*
 * expensive functions
 */

/*
 * UNTRUSTED FUNCTIONS
 */
/* 0 arguments */
retrieve (forty_two = ufp0())
\g
/* 1 argument, pass-by-value arguments/return-values */
/* also: multiple functions per file */
retrieve (sixteen = ufp1(15))
\g
/* >1 argument, pass-by-reference fixed-length arguments/return-values */
/* also: linking to C library */
retrieve (postgres = ufp2("post"::char16,"gres"::char16))
\g
/* pass-by-reference variable-length arguments/return-values */
/* also: linking to UFP code */
retrieve (postgres = ufp3("postgres rules ok"::text, " "::char))
\g

/*
 * SECURITY CRUFT
 */
replace pg_class (relacl="{}")
	where pg_class.relname !~ "pg_*"::char16
\g
replace pg_user (usesuper="f"::bool) where pg_user.usename = "_USER_"
\g

create myclass0 (a=int4)
\g

/* these should all succeed */
append myclass0 (a=5)
\g
retrieve (myclass0.a)
\g
replace myclass0 (a=6)
\g
append myclass0 (a=10)
\g
append myclass0 (a=20)
\g
replace myclass0 (a=10) where myclass0.a < 10
\g
replace myclass0 (a=myclass0.a+1)
\g
delete myclass0 where myclass0.a > 15
\g
define rule foo is on retrieve to myclass0 do instead nothing
\g
remove rule foo
\g

change acl _USER_-arR myclass0
\g

/* succeeds */
replace myclass0 (a=1)
\g
/* succeeds (we still have write permission) */
append myclass0 (a=100)
\g
