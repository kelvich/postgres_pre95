/*
 * queries.source
 *
 * $Header$
 *
 * The comments that contain sequences of UNIX commands generate the 
 * desired output for the POSTQUEL statement(s).
 */

/*
 * --- operators and target lists ---
 */

/*
 * sanity check - if this fails go insane!
 */
retrieve (one = 1)
\g

/*************testing built-in type bool*********************/

/* check bool type-casting as well as and, or, not in qualifications */

retrieve (true="t"::bool) 
\g
retrieve (false="f"::bool)
\g
retrieve (true="t"::bool or "f"::bool)
\g
retrieve (false="t"::bool and "f"::bool)
\g
retrieve (true = not "f"::bool)
\g
retrieve (false = "t"::bool = "f"::bool)
\g
retrieve (true = "t"::bool != "f"::bool)
\g

create BOOLTBL1 (f1 = bool)
\g
append BOOLTBL1 (f1 = "t"::bool)
\g
append BOOLTBL1 (f1 = "True"::bool)
\g
append BOOLTBL1 (f1 = "true"::bool)
\g

/* BOOLTBL1 should be full of true's at this point */
retrieve (t_3 = "", BOOLTBL1.all)
\g

retrieve (t_3 = "", BOOLTBL1.all) where BOOLTBL1.f1 = "true"::bool
\g
retrieve (t_3 = "", BOOLTBL1.all) where BOOLTBL1.f1 != "false"::bool
\g
retrieve (zero = "", BOOLTBL1.all) where booleq("false"::bool,BOOLTBL1.f1)
\g
append BOOLTBL1 (f1 = "f"::bool)
\g
retrieve (f_1 = "", BOOLTBL1.all) where BOOLTBL1.f1 = "false"::bool
\g

create BOOLTBL2 (f1 = bool)
\g
append BOOLTBL2 (f1 = "f"::bool)
\g
append BOOLTBL2 (f1 = "false"::bool)
\g
append BOOLTBL2 (f1 = "False"::bool)
\g
append BOOLTBL2 (f1 = "XXX"::bool)  /* this evaluates to a false value */
\g

/* BOOLTBL2 should be full of false's at this point */
retrieve (f_4 = "", BOOLTBL2.all)
\g

retrieve (tf_12 = "", BOOLTBL1.all, BOOLTBL2.all)
	where BOOLTBL2.f1 != BOOLTBL1.f1
\g
retrieve (tf_12 = "", BOOLTBL1.all, BOOLTBL2.all)
	where boolne(BOOLTBL2.f1,BOOLTBL1.f1)
\g

retrieve (ff_4 = "", BOOLTBL1.all, BOOLTBL2.all)
	where BOOLTBL2.f1 = BOOLTBL1.f1 and BOOLTBL1.f1 = "false"::bool
\g
retrieve (tf_12_ff_4 = "", BOOLTBL1.all, BOOLTBL2.all)
	where BOOLTBL2.f1 = BOOLTBL1.f1 or BOOLTBL1.f1 = "true"::bool
\g

/********testing built-in time types: abstime, reltime, and tinterval *****/

/*
 * timezones may vary based not only on location but the operating
 * system.  the main correctness issue is that the OS may not get 
 * DST right for times prior to unix epoch (jan 1 1970).
 */

create ABSTIME_TBL (f1 = abstime)
\g
append ABSTIME_TBL (f1 = "Jan 14, 1973 03:14:21")
\g
append ABSTIME_TBL (f1 = "now"::abstime)
\g
append ABSTIME_TBL (f1 = "epoch"::abstime)
\g
append ABSTIME_TBL (f1 = "current"::abstime)
\g
append ABSTIME_TBL (f1 = "infinity"::abstime)
\g
append ABSTIME_TBL (f1 = "-infinity"::abstime)
\g
append ABSTIME_TBL (f1 = "May 10, 1943 23:59:12")
\g

/* what happens if we specify slightly misformatted abstime? */
append ABSTIME_TBL (f1 = "Feb 35, 1946 10:00:00")
\g
append ABSTIME_TBL (f1 = "Feb 28, 1984 25:08:10")
\g

/* badly formatted abstimes:  these should result in invalid abstimes */
append ABSTIME_TBL (f1 = "bad date format")
\g
append ABSTIME_TBL (f1 = "Jun 10, 1843")
\g

create RELTIME_TBL (f1 = reltime)
\g
append RELTIME_TBL (f1 = "@ 1 minute")
\g
append RELTIME_TBL (f1 = "@ 5 hour")
\g
append RELTIME_TBL (f1 = "@ 10 day")
\g
append RELTIME_TBL (f1 = "@ 34 year")
\g
append RELTIME_TBL (f1 = "@ 3 months")
\g
append RELTIME_TBL (f1 = "@ 14 seconds ago")
\g

/* badly formatted reltimes:   */
append RELTIME_TBL (f1 = "badly formatted reltime")
\g
append RELTIME_TBL (f1 = "@ 30 eons ago")
\g

create TINTERVAL_TBL(f1 = tinterval)
\g
append TINTERVAL_TBL(f1 = "['-infinity' 'infinity']")
\g
append TINTERVAL_TBL(f1 = "['May 10, 1943 23:59:12' 'Jan 14, 1973 03:14:21']")
\g
append TINTERVAL_TBL(f1 = "['Sep 4, 1983 23:59:12' 'Oct 4, 1983 23:59:12']")
\g
append TINTERVAL_TBL(f1 = "['epoch' 'now']")
\g
append TINTERVAL_TBL(f1 = "['Feb 15 1990 12:15:03' 'current']")
\g

/* badly formatted tintervals */
append TINTERVAL_TBL(f1 = "['bad time specifications' '']")
\g
append TINTERVAL_TBL(f1 = "['' 'infinity']")
\g

/* test abstime operators */

retrieve (eleven = "", ABSTIME_TBL.all)
\g
retrieve (eight = "", ABSTIME_TBL.all)
	where ABSTIME_TBL.f1 < "Jun 30, 2001"::abstime
\g
retrieve (eight = "", ABSTIME_TBL.all)
	where ABSTIME_TBL.f1 > "-infinity"::abstime
\g
retrieve (eight = "", ABSTIME_TBL.all)
	where "May 10, 1943 23:59:12"::abstime != ABSTIME_TBL.f1
\g
retrieve (one = "", ABSTIME_TBL.all)
	where "current"::abstime = ABSTIME_TBL.f1
\g
retrieve (five = "", ABSTIME_TBL.all)
	where "epoch"::abstime >= ABSTIME_TBL.f1
\g
retrieve (six = "", ABSTIME_TBL.all)
	where ABSTIME_TBL.f1 <= "Jan 14, 1973 03:14:21"::abstime
\g
retrieve (six = "", ABSTIME_TBL.all)
	where ABSTIME_TBL.f1 <?>
		"['Apr 1 1945 00:00:00' 'Dec 30 1999 23:00:00']"::tinterval 
\g
/* these four queries should return the same answer */
/* the "infinity" and "-infinity" tuples in ABSTIME_TBL cannot be added and */
/* therefore, should not show up in the results. */
retrieve (five = "", ABSTIME_TBL.all)
	where  (ABSTIME_TBL.f1 + "@ 3 year"::reltime)     /* +3 years */
		< "Jan 14 14:00:00 1977"::abstime 
\g
retrieve (five = "", ABSTIME_TBL.all)
	where  (ABSTIME_TBL.f1 + "@ 3 year ago"::reltime) /* -3 years */
		< "Jan 14 14:00:00 1971"::abstime 
\g
retrieve (five = "", ABSTIME_TBL.all)
	where  (ABSTIME_TBL.f1 - "@ 3 year"::reltime)     /* -(+3) years */
		< "Jan 14 14:00:00 1971"::abstime 
\g
retrieve (five = "", ABSTIME_TBL.all)
	where  (ABSTIME_TBL.f1 - "@ 3 year ago"::reltime) /* -(-3) years */
		< "Jan 14 14:00:00 1977"::abstime 
\g

retrieve (twenty = "", ABSTIME_TBL.all, RELTIME_TBL.all)
	where (ABSTIME_TBL.f1 + RELTIME_TBL.f1)
		< "Jan 14 14:00:00 1971"::abstime
\g

/* test reltime operators */

retrieve (eight = "", RELTIME_TBL.all)
\g
retrieve (five = "", RELTIME_TBL.all)
	where RELTIME_TBL.f1 != "@ 10 days"::reltime
\g
retrieve (three = "", RELTIME_TBL.all)
	where RELTIME_TBL.f1 <= "@ 5 hours"::reltime
\g
retrieve (three = "", RELTIME_TBL.all)
	where RELTIME_TBL.f1 < "@ 1 day"::reltime
\g
retrieve (one = "", RELTIME_TBL.all)
	where RELTIME_TBL.f1 = "@ 34 years"::reltime
\g
retrieve (two = "", RELTIME_TBL.all)
	where RELTIME_TBL.f1 >= "@ 1 month"::reltime
\g
retrieve (five = "", RELTIME_TBL.all)
	where RELTIME_TBL.f1 > "@ 3 seconds ago"::reltime
\g
retrieve (fifteen = "", r1.all, r2.all)
	from r1 in RELTIME_TBL, r2 in RELTIME_TBL
	where r1.f1 > r2.f1
\g

/* test tinterval operators */

retrieve (seven = "", TINTERVAL_TBL.all)
\g
/* length == */
retrieve (one = "", t.all) from t in TINTERVAL_TBL
	where t.f1 #= "@ 1 months"
\g
/* length != */
retrieve (three = "", t.all) from t in TINTERVAL_TBL
	where t.f1 #!= "@ 1 months"
\g
/* length < */
retrieve (zero = "", t.all) from t in TINTERVAL_TBL
	where t.f1 #< "@ 1 month"
\g
/* length <= */
retrieve (one = "", t.all) from t in TINTERVAL_TBL
	where t.f1 #<= "@ 1 month"
\g
/* length > */
retrieve (three = "", t.all) from t in TINTERVAL_TBL
	where t.f1 #> "@ 1 year"
\g
/* length >= */
retrieve (three = "", t.all) from t in TINTERVAL_TBL
	where t.f1 #>= "@ 3 years"
\g
/* overlaps */
retrieve (three = "", t1.all) from t1 in TINTERVAL_TBL
	where t1.f1 &&
	"['Aug 15 14:23:19 1983' 'Sep 16 14:23:19 1983']"::tinterval
\g
retrieve (five = "", t1.all, t2.all) from t1,t2 in TINTERVAL_TBL
   where t1.f1 && t2.f1 and
	 t1.f1 = t2.f1
\g
retrieve (fourteen = "", t1.all, t2.all) from t1,t2 in TINTERVAL_TBL
   where t1.f1 && t2.f1 and 
	not t1.f1 = t2.f1
\g
/* contains */
retrieve (five = "", t1.all) from t1 in TINTERVAL_TBL
	where not t1.f1 <<
		"['Aug 15 14:23:19 1980' 'Sep 16 14:23:19 1990']"::tinterval
\g
/* make time interval */
retrieve (three = "", t1.all) from t1 in TINTERVAL_TBL
	where t1.f1 && 
		("Aug 15 14:23:19 1983'"::abstime <> 
		 "Sep 16 14:23:19 1983"::abstime)
\g

/******************** test built-in type box *********************/

/*
 * box logic
 *	     o
 * 3	  o--|X
 *	  |  o|
 * 2	+-+-+ |
 *	| | | |
 * 1	| o-+-o
 *	|   |
 * 0	+---+
 *
 *	0 1 2 3
 */

/* boxes are specified by two points, given by four floats x1,y1,x2,y2

*/

create BOX_TBL(f1=box)
\g
append BOX_TBL(f1 = "(2.0,2.0,0.0,0.0)")
\g
append BOX_TBL(f1 = "(1.0,1.0,3.0,3.0)")
\g
/* degenerate cases where the box is a line or a point */
/* note that lines and points boxes all have zero area */
append BOX_TBL(f1=  "(2.5, 2.5, 2.5,3.5)")
\g
append BOX_TBL(f1 = "(3.0, 3.0,3.0,3.0)")
\g
/* badly formatted box inputs */
append BOX_TBL(f1="(2.3, 4.5)")		/* bad */
\g
append BOX_TBL(f1="asdfasdf(ad")	/* bad */
\g

retrieve (four = "", BOX_TBL.all)
\g
retrieve (four = "", b.all, barea = box_area(b.f1))
\g
/* overlap */
retrieve (three = "", b.f1) from b in BOX_TBL
	where b.f1 && "(2.5,2.5,1.0,1.0)"::box
\g
/* left-or-overlap (x only) */
retrieve (two = "", b1.all) from b1 in BOX_TBL 
	where b1.f1 &< "(2.0,2.0,2.5,2.5)"::box
\g
/* right-or-overlap (x only) */
retrieve (two = "", b1.all) from b1 in BOX_TBL 
	where b1.f1 &> "(2.0,2.0,2.5,2.5)"::box
\g
/* left of */
retrieve (two = "", b.f1) from b in BOX_TBL
	where b.f1 << "(3.0,3.0,5.0,5.0)"::box
\g
/* area <= */
retrieve (four = "", b.f1) from b in BOX_TBL
	where b.f1 <= "(3.0,3.0,5.0,5.0)"::box
\g
/* area < */
retrieve (two = "", b.f1) from b in BOX_TBL
	where b.f1 < "(3.0,3.0,5.0,5.0)"::box
\g
/* area = */
retrieve (two = "", b.f1) from b in BOX_TBL
	where b.f1 = "(3.0,3.0,5.0,5.0)"::box
\g
/* area > */
retrieve (two = "", b.f1) from b in BOX_TBL
	where b.f1 > "(3.5,3.0,4.5,3.0)"::box	/* zero area */
\g
/* area >= */
retrieve (four = "", b.f1) from b in BOX_TBL
	where b.f1 >= "(3.5,3.0,4.5,3.0)"::box	/* zero area */
\g
/* right of */
retrieve (two = "", b.f1) from b in BOX_TBL
	where "(3.0,3.0,5.0,5.0)"::box >> b.f1
\g
/* contained in */
retrieve (three = "", b.f1) from b in BOX_TBL
	where b.f1 @ "(0,0,3,3)"::box
\g
/* contains */
retrieve (three = "", b.f1) from b in BOX_TBL
	where "(0,0,3,3)"::box ~ b.f1
\g
/* box equality */
retrieve (one = "", b.f1) from b in BOX_TBL
	where "(1,1,3,3)"::box ~= b.f1
\g
/* center of box, left unary operator */
retrieve (four = "", p = @@(b1.f1)) from b1 in BOX_TBL
\g
/* wholly-contained */
retrieve (one = "", b1.all, b2.all) from b1, b2 in BOX_TBL
  where b1.f1 ~ b2.f1 and not b1.f1 ~= b2.f1
\g

/******************* test built-in type char ***************/
/*
 * all inputs are SILENTLY truncated at 1 character
 */

create CHAR_TBL(f1 = char)
\g
append CHAR_TBL(f1 = "a")
\g
append CHAR_TBL(f1 = "A")
\g
/* any of the following three input formats are acceptable */
append CHAR_TBL(f1 = "1")
\g
append CHAR_TBL(f1 = 2)
\g
append CHAR_TBL(f1 = '3')
\g
/* zero-length char */
append CHAR_TBL(f1 = "")
\g
/* try char's of greater than 1 length */
append CHAR_TBL(f1 = "cd")
\g

retrieve (seven = "", CHAR_TBL.all)
\g
retrieve (six = "", c.all) from c in CHAR_TBL where c.f1 != "a"
\g
retrieve (one = "", c.all) from c in CHAR_TBL where c.f1 = "a"
\g
retrieve (five = "", c.all) from c in CHAR_TBL where c.f1 < "a"
\g
retrieve (six = "", c.all) from c in CHAR_TBL where c.f1 <= "a"
\g
retrieve (one = "", c.all) from c in CHAR_TBL where c.f1 > "a"
\g
retrieve (two = "", c.all) from c in CHAR_TBL where c.f1 >= "a"
\g
/*
 * char		* '3'	+ '3'	- '3'	/ 'S'
 * -----------------------------------------------
 * a	141	123 S	224	056 .	001 ^A
 * A	101	363	164 t	016 ^N	001 ^A
 * 1	061	303	144 d	376	000
 * 2	062	366	145 e	377	000
 * 3	063	051 )	146 f	000	001 ^A
 * NUL	000	000	063 3	315	000
 * c	143	271	226	060 0	001 ^A
 * -----------------------------------------------
 * 3	063
 * -----------------------------------------------
 */
retrieve (x= (c.f1 * "3"::char)) from c in CHAR_TBL
\g
retrieve (x= (c.f1 + "3"::char)) from c in CHAR_TBL
\g
retrieve (x= (c.f1 - "3"::char)) from c in CHAR_TBL
\g
retrieve (x= (c.f1 / "3"::char)) from c in CHAR_TBL
\g

/***************** testing built-in type char2 ***************/
/*
 * all inputs are silently truncated at 2 characters
 */

create CHAR2_TBL(f1 = char2)
\g
append CHAR2_TBL(f1 = "AB")
\g
append CHAR2_TBL(f1 = "ab")
\g
append CHAR2_TBL(f1 = "ZY")
\g
append CHAR2_TBL(f1 = "34")
\g
append CHAR2_TBL(f1 = "d")
\g
append CHAR2_TBL(f1 = "")
\g
append CHAR2_TBL(f1 = "12345")
\g

retrieve (seven = "", CHAR2_TBL.all)
\g
retrieve (six = "", c.f1) from c in CHAR2_TBL where c.f1 != "AB"
\g
retrieve (one = "", c.f1) from c in CHAR2_TBL where c.f1 = "AB"
\g
retrieve (three = "", c.f1) from c in CHAR2_TBL where c.f1 < "AB"
\g
retrieve (four = "", c.f1) from c in CHAR2_TBL where c.f1 <= "AB"
\g
retrieve (three = "", c.f1) from c in CHAR2_TBL where c.f1 > "AB"
\g
retrieve (four = "", c.f1) from c in CHAR2_TBL where c.f1 >= "AB"
\g
retrieve (seven = "", c.f1) from c in CHAR2_TBL where c.f1 ~ ".*"
\g
retrieve (zero = "", c.f1) from c in CHAR2_TBL where c.f1 !~ ".*"
\g
retrieve (one = "", c.f1) from c in CHAR2_TBL where c.f1 ~ "34"
\g
retrieve (one = "", c.f1) from c in CHAR2_TBL where c.f1 ~ "3.*"
\g


/***************** testing built-in type char4 ***************/
/*
 * all inputs are silently truncated at 4 characters
 */

create CHAR4_TBL(f1 = char4)
\g
append CHAR4_TBL(f1 = "ABCD")
\g
append CHAR4_TBL(f1 = "abcd")
\g
append CHAR4_TBL(f1 = "ZYWZ")
\g
append CHAR4_TBL(f1 = "343f")
\g
append CHAR4_TBL(f1 = "d34a")
\g
append CHAR4_TBL(f1 = "")
\g
append CHAR4_TBL(f1 = "12345678")
\g

retrieve (seven = "", CHAR4_TBL.all)
\g
retrieve (six = "", c.f1) from c in CHAR4_TBL where c.f1 != "ABCD"
\g
retrieve (one = "", c.f1) from c in CHAR4_TBL where c.f1 = "ABCD"
\g
retrieve (three = "", c.f1) from c in CHAR4_TBL where c.f1 < "ABCD"
\g
retrieve (four = "", c.f1) from c in CHAR4_TBL where c.f1 <= "ABCD"
\g
retrieve (three = "", c.f1) from c in CHAR4_TBL where c.f1 > "ABCD"
\g
retrieve (four = "", c.f1) from c in CHAR4_TBL where c.f1 >= "ABCD"
\g
retrieve (seven = "", c.f1) from c in CHAR4_TBL where c.f1 ~ ".*"
\g
retrieve (zero = "", c.f1) from c in CHAR4_TBL where c.f1 !~ ".*"
\g
retrieve (three = "", c.f1) from c in CHAR4_TBL where c.f1 ~ ".*34.*"
\g

/***************** testing built-in type char8 ***************/
/*
 * all inputs are silently truncated at 8 characters
 */

create CHAR8_TBL(f1 = char8)
\g
append CHAR8_TBL(f1 = "ABCDEFGH")
\g
append CHAR8_TBL(f1 = "abcdefgh")
\g
append CHAR8_TBL(f1 = "ZYWZ410-")
\g
append CHAR8_TBL(f1 = "343f%2a")
\g
append CHAR8_TBL(f1 = "d34aas")
\g
append CHAR8_TBL(f1 = "")
\g
append CHAR8_TBL(f1 = "1234567890")
\g

retrieve (seven = "", CHAR8_TBL.all)
\g
retrieve (six = "", c.f1) from c in CHAR8_TBL where c.f1 != "ABCDEFGH"
\g
retrieve (one = "", c.f1) from c in CHAR8_TBL where c.f1 = "ABCDEFGH"
\g
retrieve (three = "", c.f1) from c in CHAR8_TBL where c.f1 < "ABCDEFGH"
\g
retrieve (four = "", c.f1) from c in CHAR8_TBL where c.f1 <= "ABCDEFGH"
\g
retrieve (three = "", c.f1) from c in CHAR8_TBL where c.f1 > "ABCDEFGH"
\g
retrieve (four = "", c.f1) from c in CHAR8_TBL where c.f1 >= "ABCDEFGH"
\g
retrieve (seven = "", c.f1) from c in CHAR8_TBL where c.f1 ~ ".*"
\g
retrieve (zero = "", c.f1) from c in CHAR8_TBL where c.f1 !~ ".*"
\g
retrieve (four = "", c.f1) from c in CHAR8_TBL where c.f1 ~ "[0-9]"
\g
retrieve (three = "", c.f1) from c in CHAR8_TBL where c.f1 ~ ".*34.*"
\g


/***************** testing built-in type char16 ***************/
/*
 * all inputs are silently truncated at 16 characters
 */

create CHAR16_TBL(f1 = char16)
\g
append CHAR16_TBL(f1 = "ABCDEFGHIJKLMNOP")
\g
append CHAR16_TBL(f1 = "abcdefghijklmnop")
\g
append CHAR16_TBL(f1 = "asdfghjkl;")
\g
append CHAR16_TBL(f1 = "343f%2a")
\g
append CHAR16_TBL(f1 = "d34aaasdf")
\g
append CHAR16_TBL(f1 = "")
\g
append CHAR16_TBL(f1 = "1234567890ABCDEFGHIJKLMNOPQRSTUV")
\g

retrieve (seven = "", CHAR16_TBL.all)
\g
retrieve (six = "", c.f1) from c in CHAR16_TBL where c.f1 != "ABCDEFGHIJKLMNOP"
\g
retrieve (one = "", c.f1) from c in CHAR16_TBL where c.f1 = "ABCDEFGHIJKLMNOP"
\g
retrieve (three = "", c.f1) from c in CHAR16_TBL where c.f1 < "ABCDEFGHIJKLMNOP"
\g
retrieve (four = "", c.f1) from c in CHAR16_TBL where c.f1 <= "ABCDEFGHIJKLMNOP"
\g
retrieve (three = "", c.f1) from c in CHAR16_TBL where c.f1 > "ABCDEFGHIJKLMNOP"
\g
retrieve (four = "", c.f1) from c in CHAR16_TBL where c.f1 >= "ABCDEFGHIJKLMNOP"
\g
retrieve (seven = "", c.f1) from c in CHAR16_TBL where c.f1 ~ ".*"
\g
retrieve (zero = "", c.f1) from c in CHAR16_TBL where c.f1 !~ ".*"
\g
retrieve (three = "", c.f1) from c in CHAR16_TBL where c.f1 ~ "[0-9]"
\g
retrieve (two = "", c.f1) from c in CHAR16_TBL where c.f1 ~ ".*asdf.*"
\g

/**************testing built-in type float4 *****************/

create FLOAT4_TBL(f1=float4)
\g
append FLOAT4_TBL(f1="0.0")
\g
append FLOAT4_TBL(f1="1004.30")
\g
append FLOAT4_TBL(f1="-34.84")
\g
append FLOAT4_TBL(f1="1.2345678901234e+20")
\g
append FLOAT4_TBL(f1="1.2345678901234e-20")
\g
/* test for over and under flow */
append FLOAT4_TBL(f1="10e40")	/* bad */
\g
append FLOAT4_TBL(f1="-10e40")	/* bad */
\g
append FLOAT4_TBL(f1="10e-40")	/* bad */
\g
append FLOAT4_TBL(f1="-10e-40")	/* ok (negative zero) */
\g

retrieve (six = "", FLOAT4_TBL.all)
\g
retrieve (five = "", f.all) from f in FLOAT4_TBL where f.f1 != "1004.3"
\g
retrieve (one = "", f.all) from f in FLOAT4_TBL where f.f1 = "1004.3"
\g
retrieve (four = "", f.all) from f in FLOAT4_TBL where "1004.3" > f.f1
\g
retrieve (four = "", f.all) from f in FLOAT4_TBL where  f.f1 < "1004.3"
\g
retrieve (five = "", f.all) from f in FLOAT4_TBL where "1004.3" >= f.f1
\g
retrieve (five = "", f.all) from f in FLOAT4_TBL where  f.f1 <= "1004.3"
\g
retrieve (three = "", f.f1, x= f.f1 * "-10") from f in FLOAT4_TBL
	where f.f1 > "0.0"
\g
retrieve (three = "", f.f1, x= f.f1 + "-10") from f in FLOAT4_TBL
	where f.f1 > "0.0"
\g
retrieve (three = "", f.f1, x= f.f1 / "-10") from f in FLOAT4_TBL
	where f.f1 > "0.0"
\g
retrieve (three = "", f.f1, x= f.f1 - "-10") from f in FLOAT4_TBL
	where f.f1 > "0.0"
\g
retrieve (six = "", FLOAT4_TBL.all)
\g
/* test the unary float4abs operator */
retrieve (six = "", f.f1, abs_f1 = @f.f1) from f in FLOAT4_TBL
\g
replace FLOAT4_TBL(f1= FLOAT4_TBL.f1 * "-1") where FLOAT4_TBL.f1 > "0.0"
\g
retrieve (six = "", FLOAT4_TBL.all)
\g

/**************testing built-in type float8 *****************/

create FLOAT8_TBL(f1=float8)
\g
append FLOAT8_TBL(f1="0.0")
\g
append FLOAT8_TBL(f1="1004.30")
\g
append FLOAT8_TBL(f1="-34.84")
\g
append FLOAT8_TBL(f1="1.2345678901234e+200")
\g
append FLOAT8_TBL(f1="1.2345678901234e-200")
\g
/* test for over and under flow */
append FLOAT8_TBL(f1="10e400")		/* bad */
\g
append FLOAT8_TBL(f1="-10e400")		/* bad */
\g
append FLOAT8_TBL(f1="10e-400")		/* bad */
\g
append FLOAT8_TBL(f1="-10e-400")	/* bad */
\g

retrieve (five = "", FLOAT8_TBL.all)
\g
retrieve (four = "", f.all) from f in FLOAT8_TBL where f.f1 != "1004.3"
\g
retrieve (one = "", f.all) from f in FLOAT8_TBL where f.f1 = "1004.3"
\g
retrieve (three = "", f.all) from f in FLOAT8_TBL where "1004.3" > f.f1
\g
retrieve (three = "", f.all) from f in FLOAT8_TBL where  f.f1 < "1004.3"
\g
retrieve (four = "", f.all) from f in FLOAT8_TBL where "1004.3" >= f.f1
\g
retrieve (four = "", f.all) from f in FLOAT8_TBL where  f.f1 <= "1004.3"
\g
retrieve (three = "", f.f1, x= f.f1 * "-10") from f in FLOAT8_TBL
	where f.f1 > "0.0"
\g
retrieve (three = "", f.f1, x= f.f1 + "-10") from f in FLOAT8_TBL
	where f.f1 > "0.0"
\g
retrieve (three = "", f.f1, x= f.f1 / "-10") from f in FLOAT8_TBL
	where f.f1 > "0.0"
\g
retrieve (three = "", f.f1, x= f.f1 - "-10") from f in FLOAT8_TBL
	where f.f1 > "0.0"
\g
retrieve (five = "", square_f1 = f.f1 ^ "2.0") from f in FLOAT8_TBL
\g
/* absolute value */
retrieve (five = "", f.f1, abs_f1 = @f.f1) from f in FLOAT8_TBL
\g
/* truncate */
retrieve (five = "", f.f1, trunc_f1 = %f.f1) from f in FLOAT8_TBL
\g
/* round */
retrieve (five = "", f.f1, round_f1 = f.f1 %) from f in FLOAT8_TBL
\g
/* square root */
retrieve (three = "", f.f1, sqrt_f1 = |/f.f1) from f in FLOAT8_TBL
	where f.f1 > "0.0"
\g
/* take exp of ln(f.f1) */
retrieve (three = "", f.f1, exp_ln_f1 = : ( ; f.f1) ) from f in FLOAT8_TBL
	where f.f1 > "0.0"
\g
/* cube root */
retrieve (five = "", f.f1, cbrt_f1 = ||/f.f1) from f in FLOAT8_TBL
\g

retrieve (five = "", FLOAT8_TBL.all)
\g
replace FLOAT8_TBL(f1= FLOAT8_TBL.f1 * "-1") where FLOAT8_TBL.f1 > "0.0"
\g
retrieve (five = "", FLOAT8_TBL.all)
\g

/**************testing built-in type int2 *****************/
/*
 * NOTE: int2 operators never check for over/underflow!
 * Some of these answers are consequently numerically incorrect.
 */

create INT2_TBL(f1=int2)
\g
append INT2_TBL(f1="0")
\g
append INT2_TBL(f1="1234")
\g
append INT2_TBL(f1="-1234")
\g
append INT2_TBL(f1="34.5")	/* bad */
\g
/* largest and smallest values */
append INT2_TBL(f1="32767")
\g
append INT2_TBL(f1="-32767")
\g
/* bad input values -- should give warnings */
append INT2_TBL(f1="100000")	/* bad */
\g
append INT2_TBL(f1="asdf")	/* bad */
\g

retrieve (five = "", INT2_TBL.all)
\g
retrieve (four = "", i.all) from i in INT2_TBL where i.f1 != "0"::int2
\g
retrieve (four = "", i.all) from i in INT2_TBL where i.f1 != "0"::int4
\g
retrieve (one = "", i.all) from i in INT2_TBL where i.f1 = "0"::int2
\g
retrieve (one = "", i.all) from i in INT2_TBL where i.f1 = "0"::int4
\g
retrieve (two = "", i.all) from i in INT2_TBL where i.f1 < "0"::int2
\g
retrieve (two = "", i.all) from i in INT2_TBL where i.f1 < "0"::int4
\g
retrieve (three = "", i.all) from i in INT2_TBL where i.f1 <= "0"::int2
\g
retrieve (three = "", i.all) from i in INT2_TBL where i.f1 <= "0"::int4
\g
retrieve (two = "", i.all) from i in INT2_TBL where i.f1 > "0"::int2
\g
retrieve (two = "", i.all) from i in INT2_TBL where i.f1 > "0"::int4
\g
retrieve (three = "", i.all) from i in INT2_TBL where i.f1 >= "0"::int2
\g
retrieve (three = "", i.all) from i in INT2_TBL where i.f1 >= "0"::int4
\g
/* positive odds */
retrieve (one = "", i.all) from i in INT2_TBL where (i.f1 % "2"::int2) = "1"::int2
\g
/* any evens */
retrieve (three = "", i.all) from i in INT2_TBL where (i.f1 % "2"::int4) = "0"::int2
\g
retrieve (five = "", i.f1, x = i.f1 * "2"::int2) from i in INT2_TBL
\g
retrieve (five = "", i.f1, x = i.f1 * "2"::int4) from i in INT2_TBL
\g
retrieve (five = "", i.f1, x = i.f1 + "2"::int2) from i in INT2_TBL
\g
retrieve (five = "", i.f1, x = i.f1 + "2"::int4) from i in INT2_TBL
\g
retrieve (five = "", i.f1, x = i.f1 - "2"::int2) from i in INT2_TBL
\g
retrieve (five = "", i.f1, x = i.f1 - "2"::int4) from i in INT2_TBL
\g
retrieve (five = "", i.f1, x = i.f1 / "2"::int2) from i in INT2_TBL
\g
retrieve (five = "", i.f1, x = i.f1 / "2"::int4) from i in INT2_TBL
\g


/**************testing built-in type int4 *****************/
/*
 * WARNING: int4 operators never check for over/underflow!
 * Some of these answers are consequently numerically incorrect.
 */

create INT4_TBL(f1=int4)
\g
append INT4_TBL(f1="0")
\g
append INT4_TBL(f1="123456")
\g
append INT4_TBL(f1="-123456")
\g
append INT4_TBL(f1="34.5")		/* bad */
\g
/* largest and smallest values */
append INT4_TBL(f1="2147483647")
\g
append INT4_TBL(f1="-2147483647")
\g
/* bad input values -- should give warnings */
append INT4_TBL(f1="1000000000000")	/* bad */
\g
append INT4_TBL(f1="asdf")		/* bad */
\g

retrieve (five = "", INT4_TBL.all)
\g
retrieve (four = "", i.all) from i in INT4_TBL where i.f1 != "0"::int2
\g
retrieve (four = "", i.all) from i in INT4_TBL where i.f1 != "0"::int4
\g
retrieve (one = "", i.all) from i in INT4_TBL where i.f1 = "0"::int2
\g
retrieve (one = "", i.all) from i in INT4_TBL where i.f1 = "0"::int4
\g
retrieve (two = "", i.all) from i in INT4_TBL where i.f1 < "0"::int2
\g
retrieve (two = "", i.all) from i in INT4_TBL where i.f1 < "0"::int4
\g
retrieve (three = "", i.all) from i in INT4_TBL where i.f1 <= "0"::int2
\g
retrieve (three = "", i.all) from i in INT4_TBL where i.f1 <= "0"::int4
\g
retrieve (two = "", i.all) from i in INT4_TBL where i.f1 > "0"::int2
\g
retrieve (two = "", i.all) from i in INT4_TBL where i.f1 > "0"::int4
\g
retrieve (three = "", i.all) from i in INT4_TBL where i.f1 >= "0"::int2
\g
retrieve (three = "", i.all) from i in INT4_TBL where i.f1 >= "0"::int4
\g
/* positive odds */
retrieve (one = "", i.all) from i in INT4_TBL where (i.f1 % "2"::int2) = "1"::int2
\g
/* any evens */
retrieve (three = "", i.all) from i in INT4_TBL where (i.f1 % "2"::int4) = "0"::int2
\g
retrieve (five = "", i.f1, x = i.f1 * "2"::int2) from i in INT4_TBL
\g
retrieve (five = "", i.f1, x = i.f1 * "2"::int4) from i in INT4_TBL
\g
retrieve (five = "", i.f1, x = i.f1 + "2"::int2) from i in INT4_TBL
\g
retrieve (five = "", i.f1, x = i.f1 + "2"::int4) from i in INT4_TBL
\g
retrieve (five = "", i.f1, x = i.f1 - "2"::int2) from i in INT4_TBL
\g
retrieve (five = "", i.f1, x = i.f1 - "2"::int4) from i in INT4_TBL
\g
retrieve (five = "", i.f1, x = i.f1 / "2"::int2) from i in INT4_TBL
\g
retrieve (five = "", i.f1, x = i.f1 / "2"::int4) from i in INT4_TBL
\g

/*
 * more complex expressions
 */
retrieve (true = "2"::int2 * "2"::int2 = "16"::int2 / "4"::int2)
\g
retrieve (true = "2"::int4 * "2"::int2 = "16"::int2 / "4"::int4)
\g
retrieve (true = "2"::int2 * "2"::int4 = "16"::int4 / "4"::int2)
\g
retrieve (false = "1000"::int4 < "999"::int4)
\g
retrieve (twenty_four = 4!)
\g
retrieve (six = !!3)
\g
retrieve (ten = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)
\g
retrieve (three = 2 + 2 / 2)
\g
retrieve (two = (2 + 2) / 2)
\g
retrieve (eight = dsqrt("64"::float8))
\g
retrieve (eight = |/"64"::float8)
\g
retrieve (three = ||/"27"::float8)
\g


/**************testing built-in type oid *****************/
create OID_TBL(f1=oid)
\g
append OID_TBL(f1="1234")
\g
append OID_TBL(f1="1235")
\g
append OID_TBL(f1="987")
\g
append OID_TBL(f1="-1040")
\g
append OID_TBL(f1="")
\g
/* bad inputs */
append OID_TBL(f1="asdfasd")	/* bad */
\g
retrieve (five = "", OID_TBL.all)
\g
retrieve (one = "", o.all) from o in OID_TBL where o.f1 = "1234"
\g
retrieve (four = "", o.all) from o in OID_TBL where o.f1 != "1234"
\g
retrieve (four = "", o.all) from o in OID_TBL where o.f1 <= "1234"
\g
retrieve (three = "", o.all) from o in OID_TBL where o.f1 < "1234"
\g
retrieve (two = "", o.all) from o in OID_TBL where o.f1 >= "1234"
\g
retrieve (one = "", o.all) from o in OID_TBL where o.f1 > "1234"
\g

/**************testing built-in type oidchar16 *****************/
/* oidchar16 is a an adt for multiple key indices involving oid and char16 */
/* probably will not be used directly by most users */

create OIDCHAR16_TBL(f1=oidchar16)
\g
append OIDCHAR16_TBL(f1="1234,abcd")
\g
append OIDCHAR16_TBL(f1="1235,efgh")
\g
append OIDCHAR16_TBL(f1="987,XXXX")
\g
/* no char16 component */
append OIDCHAR16_TBL(f1="123456")	/* bad */
\g
/* char16 component too long */
append OIDCHAR16_TBL(f1="123456,abcdefghijklmnopqrsutvwyz")
\g
/* bad inputs */
append OIDCHAR16_TBL(f1="")		/* bad */
\g
append OIDCHAR16_TBL(f1="asdfasd")	/* bad */
\g
retrieve (four = "", OIDCHAR16_TBL.all)
\g
retrieve (one = "", o.all) from o in OIDCHAR16_TBL where o.f1 = "1234,abcd"
\g
retrieve (three = "", o.all) from o in OIDCHAR16_TBL where o.f1 != "1234,abcd"
\g
retrieve (two = "", o.all) from o in OIDCHAR16_TBL where o.f1 <= "1234,abcd"
\g
retrieve (one = "", o.all) from o in OIDCHAR16_TBL where o.f1 < "1234,abcd"
\g
retrieve (three = "", o.all) from o in OIDCHAR16_TBL where o.f1 >= "1234,abcd"
\g
retrieve (two = "", o.all) from o in OIDCHAR16_TBL where o.f1 > "1234,abcd"
\g

/**************testing built-in type oidint2 *****************/
/* oidint2 is a an adt for multiple key indices involving oid and int2 */
/* probably will not be used directly by most users */

create OIDINT2_TBL(f1=oidint2)
\g
append OIDINT2_TBL(f1="1234/9873")
\g
append OIDINT2_TBL(f1="1235/9873")
\g
append OIDINT2_TBL(f1="987/-1234")
\g
/* no int2 component */
/*
 * this is defined as good in the code -- I don't know what will break
 * if we disallow it.
 */
append OIDINT2_TBL(f1="123456")
\g
/* int2 component too large */
append OIDINT2_TBL(f1="123456/123456")	/* bad */
\g
/*
 * this is defined as good in the code -- I don't know what will break
 * if we disallow it.
 */
append OIDINT2_TBL(f1="")
\g
/* bad inputs */
append OIDINT2_TBL(f1="asdfasd")	/* bad */
\g
retrieve (five = "", OIDINT2_TBL.all)
\g
retrieve (one = "", o.all) from o in OIDINT2_TBL where o.f1 = "1235/9873"
\g
retrieve (four = "", o.all) from o in OIDINT2_TBL where o.f1 != "1235/9873"
\g
retrieve (four = "", o.all) from o in OIDINT2_TBL where o.f1 <= "1235/9873"
\g
retrieve (three = "", o.all) from o in OIDINT2_TBL where o.f1 < "1235/9873"
\g
retrieve (two = "", o.all) from o in OIDINT2_TBL where o.f1 >= "1235/9873"
\g
retrieve (one = "", o.all) from o in OIDINT2_TBL where o.f1 > "1235/9873"
\g

/**************testing built-in type oidint4 *****************/
/* oidint4 is a an adt for multiple key indices involving oid and int4 */
/* probably will not be used directly by most users */

create OIDINT4_TBL(f1=oidint4)
\g
append OIDINT4_TBL(f1="1234/9873")
\g
append OIDINT4_TBL(f1="1235/9873")
\g
append OIDINT4_TBL(f1="987/-1234")
\g
/* no int4 component */
/*
 * this is defined as good in the code -- I don't know what will break
 * if we disallow it.
 */
append OIDINT4_TBL(f1="123456")
\g
/* int4 component too large */
append OIDINT4_TBL(f1="123456/1234568901234567890")	/* bad */
\g
/*
 * this is defined as good in the code -- I don't know what will break
 * if we disallow it.
 */
append OIDINT4_TBL(f1="")				/* bad */
\g
/* bad inputs */
append OIDINT4_TBL(f1="asdfasd")			/* bad */
\g
retrieve (five = "", OIDINT4_TBL.all)
\g
retrieve (one = "", o.all) from o in OIDINT4_TBL where o.f1 = "1235/9873"
\g
retrieve (four = "", o.all) from o in OIDINT4_TBL where o.f1 != "1235/9873"
\g
retrieve (four = "", o.all) from o in OIDINT4_TBL where o.f1 <= "1235/9873"
\g
retrieve (three = "", o.all) from o in OIDINT4_TBL where o.f1 < "1235/9873"
\g
retrieve (two = "", o.all) from o in OIDINT4_TBL where o.f1 >= "1235/9873"
\g
retrieve (one = "", o.all) from o in OIDINT4_TBL where o.f1 > "1235/9873"
\g

/**************testing built-in type point *****************/

create POINT_TBL(f1=point)
\g
append POINT_TBL(f1="(0.0,0.0)")
\g
append POINT_TBL(f1="(-10.0,0.0)")
\g
append POINT_TBL(f1="(-3.0,4.0)")
\g
append POINT_TBL(f1="(5.1, 34.5)")
\g
append POINT_TBL(f1="(-5.0,-12.0)")
\g
/* bad format points */
append POINT_TBL(f1="asdfasdf")		/* bad */
\g
append POINT_TBL(f1="10.0,10.0")	/* bad */
\g
append POINT_TBL(f1="(10.0 10.0)")	/* bad */
\g
append POINT_TBL(f1="(10.0,10.0")	/* bad */
\g

retrieve (five = "", POINT_TBL.all)
\g
/* left of */
retrieve (three = "", p.all) from p in POINT_TBL where p.f1 !< "(0.0, 0.0)"
\g
/* right of */
retrieve (three = "", p.all) from p in POINT_TBL where "(0.0,0.0)" !> p.f1
\g
/* above */
retrieve (one = "", p.all) from p in POINT_TBL where "(0.0,0.0)" !^ p.f1
\g
/* below */
retrieve (one = "", p.all) from p in POINT_TBL where p.f1 !| "(0.0, 0.0)"
\g
/* equal */
retrieve (one = "", p.all) from p in POINT_TBL where p.f1 =|= "(5.1, 34.5)"
\g
/* point in box */
retrieve (two = "", p.all) from p in POINT_TBL
	where p.f1 ---> "(0,0,100,100)"
\g
retrieve (three = "", p.all) from p in POINT_TBL
	where not on_pb(p.f1,"(0,0,100,100)"::box)
\g
retrieve (two = "", p.all) from p in POINT_TBL
	where on_ppath(p.f1,"(0,3,0,0,-10,0,-10,10)"::path)
\g
retrieve (five = "", p.f1, dist= p.f1 <---> "(0,0)") from p in POINT_TBL
\g
retrieve (twentyfive = "", p1.f1, p2.f1, dist = p1.f1 <---> p2.f1)
	from p1, p2 in POINT_TBL
\g
retrieve (twenty = "", p1.f1, p2.f1) from p1, p2 in POINT_TBL
   where (p1.f1 <---> p2.f1) > 3
\g
retrieve (ten = "", p1.f1, p2.f1) from p1, p2 in POINT_TBL
   where (p1.f1 <---> p2.f1) > 3 and 
	p1.f1 !< p2.f1
\g
retrieve (two = "", p1.f1, p2.f1) from p1, p2 in POINT_TBL
   where (p1.f1 <---> p2.f1) > 3 and 
	p1.f1 !< p2.f1 and
	p1.f1 !^ p2.f1
\g


/**************testing built-in type polygon *****************/
/*
 * polygon logic
 *
 * 3	      o
 *	      |
 * 2	    + |
 *	   /  |
 * 1	  # o +
 *       /    |
 * 0	#-----o-+
 *
 *	0 1 2 3 4
 */

create POLYGON_TBL(f1=polygon)
\g
append POLYGON_TBL(f1="(2.0,2.0,0.0,0.0,4.0,0.0)")
\g
append POLYGON_TBL(f1="(3.0,3.0,1.0,1.0,3.0,0.0)")
\g
/* degenerate polygons */
append POLYGON_TBL(f1="(0.0,0.0)")
\g
append POLYGON_TBL(f1="(0.0,0.0,1.0,1.0)")
\g
/* bad polygon input strings */
append POLYGON_TBL(f1="0.0")		/* bad */
\g
append POLYGON_TBL(f1="(0.0 0.0")	/* bad */
\g
append POLYGON_TBL(f1="(0,1,2)")	/* bad */
\g
append POLYGON_TBL(f1="(0,1,2,3")	/* bad */
\g
append POLYGON_TBL(f1="asdf")		/* bad */
\g

retrieve (four = "", POLYGON_TBL.all)
\g
/* overlap */
retrieve (three = "", p.all) from p in POLYGON_TBL
  where p.f1 && "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
/* left overlap */
retrieve (four = "", p.all) from p in POLYGON_TBL
  where p.f1 &< "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
/* right overlap */
retrieve (two = "", p.all) from p in POLYGON_TBL
  where p.f1 &> "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
/* left of */
retrieve (one = "", p.all) from p in POLYGON_TBL
  where p.f1 << "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
/* right of */
retrieve (zero = "", p.all) from p in POLYGON_TBL
  where p.f1 >> "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
/* contained */
retrieve (one = "", p.all) from p in POLYGON_TBL
  where p.f1 @ "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
/* same */
retrieve (one = "", p.all) from p in POLYGON_TBL
  where p.f1 ~= "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g
/* contains */
retrieve (one = "", p.all) from p in POLYGON_TBL
  where p.f1 ~ "(3.0,3.0,1.0,1.0,3.0,0.0)"
\g


/**************testing built-in type text  *****************/


/*
 * adt operators in the target list
 */
/* fixed-length by reference */
retrieve (false = "char 16 string"::char16 = "char 16 string "::char16)
\g
/* fixed-length by value */
retrieve (true = "c"::char = "c"::char)
\g
/* variable-length */
retrieve (true = "this is a text string"::text = "this is a text string"::text)
\g
retrieve (false = "this is a text string"::text = "this is a text strin"::text)
\g
/*
 * polygon logic
 *
 * 3	      o
 *	      |
 * 2	    + |
 *	   /  |
 * 1	  / o +
 *       /    |
 * 0	+-----o-+
 *
 *	0 1 2 3 4
 */
/* left of */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon << "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* left overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &< "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* right overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon &> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* right of */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon >> "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* contained in */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon @ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* contains */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~ "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* same */
retrieve (false = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon ~= "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g
/* overlap */
retrieve (true = "(2.0,2.0,0.0,0.0,4.0,0.0)"::polygon && "(3.0,3.0,1.0,1.0,3.0,0.0)"::polygon)
\g


/*
 * qualifications
 */

/*
 * from clauses
 */

/*
 * retrieve
 */

/*
 * btree index
 * awk '{if($1<10){print;}else{next;}}' onek.data | sort +0n -1
 */
retrieve (onek.all) where onek.unique1 < 10
\g
/*
 * awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
 */
retrieve (onek.unique1, onek.stringu1)
    where onek.unique1 < 20 sort by unique1 using >
\g
/*
 * awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
 */
retrieve (onek.unique1, onek.stringu1)
    where onek.unique1 > 980 sort by stringu1 using <
\g	
/*
 * awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
   sort +1d -2 +0nr -1
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 > 980 sort by string4 using <, unique1 using >
\g	
/*
 * awk '{if($1>980){print $1,$16;}else{next;}}' onek.data |
   sort +1dr -2 +0n -1
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 > 980 sort by string4 using >, unique1 using <
\g	
/*
 * awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
   sort +0nr -1 +1d -2
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 < 20 sort by unique1 using >, string4 using <
\g
/*
 * awk '{if($1<20){print $1,$16;}else{next;}}' onek.data |
   sort +0n -1 +1dr -2
 */
retrieve (onek.unique1, onek.string4)
    where onek.unique1 < 20 sort by unique1 using <, string4 using >
\g
/*
 * partial btree index
 * awk '{if($1<10){print $0;}else{next;}}' onek.data | sort +0n -1
 */
retrieve (onek2.all) where onek2.unique1 < 10
\g
/*
 * partial btree index
 * awk '{if($1<20){print $1,$14;}else{next;}}' onek.data | sort +0nr -1
 */
retrieve (onek2.unique1, onek2.stringu1)
    where onek2.unique1 < 20 sort by unique1 using >
\g
/*
 * awk '{if($1>980){print $1,$14;}else{next;}}' onek.data | sort +1d -2
 */
retrieve (onek2.unique1, onek2.stringu1)
    where onek2.unique1 > 980 sort by stringu1 using <
\g	
retrieve into temp (onek.two, onek.stringu1, onek.ten, onek.string4)
\g
/*
 * awk '{print $3;}' onek.data | sort -n | uniq
 */
retrieve unique (temp.two) 
\g
/*
 * awk '{print $5;}' onek.data | sort -n | uniq
 */
retrieve unique (temp.ten) 
\g
/*
 * awk '{print $16;}' onek.data | sort -d | uniq
 */
retrieve unique (temp.string4) 
\g
/*
 * awk '{print $3,$16,$5;}' onek.data | sort -d | uniq |
   sort +0n -1 +1d -2 +2n -3
 */
retrieve unique (temp.two, temp.string4, temp.ten)
    sort by two using <, string4 using <, ten using <
\g
retrieve into temp1 (temp.all) where onek.unique1 < 2
\g
destroy temp1
\g
retrieve into temp1 (temp.all) where onek2.unique1 < 2
\g
destroy temp1
\g
/*
 * awk '{print $1,$2;}' person.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
   awk 'BEGIN{FS="	";}{if(NF!=2){print $4,$5;}else{print;}}' - stud_emp.data
 */
retrieve (p.name, p.age) from p in person*
\g
/*
 * awk '{print $1,$2;}' person.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - emp.data |
   awk '{if(NF!=2){print $3,$2;}else{print;}}' - student.data |
   awk 'BEGIN{FS="	";}{if(NF!=1){print $4,$5;}else{print;}}' - stud_emp.data |
   sort +1nr -2
 */
retrieve (p.name, p.age) from p in person* sort by age using >
\g
/*
 * awk '{print $2;}' person.data |
   awk '{if(NF!=1){print $2;}else{print;}}' - emp.data |
   awk '{if(NF!=1){print $2;}else{print;}}' - student.data |
   awk 'BEGIN{FS="	";}{if(NF!=1){print $5;}else{print;}}' - stud_emp.data |
   sort -n -r | uniq
 */
retrieve unique (p.age) from p in person* sort by age using >
\g
/*
 * hash index
 * grep 843938989 hash.data
 */
retrieve (hash_i4_heap.all)
	where hash_i4_heap.random = 843938989
\g
/*
 * hash index
 * grep 66766766 hash.data
 */
retrieve (hash_i4_heap.all)
	where hash_i4_heap.random = 66766766
\g
/*
 * hash index
 * grep 1505703298 hash.data
 */
retrieve (hash_c16_heap.all)
	where hash_c16_heap.random = "1505703298"::char16
\g
/*
 * hash index
 * grep 7777777 hash.data
 */
retrieve (hash_c16_heap.all)
	where hash_c16_heap.random = "7777777"::char16
\g
/*
 * hash index
 * grep 1351610853 hash.data
 */
retrieve (hash_txt_heap.all)
	where hash_txt_heap.random = "1351610853"::text
\g
/*
 * hash index
 * grep 111111112222222233333333 hash.data
 */
retrieve (hash_txt_heap.all)
	where hash_txt_heap.random = "111111112222222233333333"::text
\g
/*
 * hash index
 * grep 444705537 hash.data
 */
retrieve (hash_f8_heap.all)
	where hash_f8_heap.random = "444705537"::float8
\g
/*
 * hash index
 * grep 88888888 hash.data
 */
retrieve (hash_f8_heap.all)
	where hash_f8_heap.random = "88888888"::float8
\g
/*
 * btree index
 * test retrieval of min/max keys for each
 */
retrieve (b.all)
	from b in bt_i4_heap
	where b.seqno < 1
\g
retrieve (b.all)
	from b in bt_i4_heap
	where b.seqno >= 9999
\g
retrieve (b.all)
	from b in bt_i4_heap
	where b.seqno = 4500
\g
retrieve (b.all)
	from b in bt_c16_heap
	where b.seqno < "1"::char16
\g
retrieve (b.all)
	from b in bt_c16_heap
	where b.seqno >= "9999"::char16
\g
retrieve (b.all)
	from b in bt_c16_heap
	where b.seqno = "4500"::char16
\g
retrieve (b.all)
	from b in bt_txt_heap
	where b.seqno < "1"::text
\g
retrieve (b.all)
	from b in bt_txt_heap
	where b.seqno >= "9999"::text
\g
retrieve (b.all)
	from b in bt_txt_heap
	where b.seqno = "4500"::text
\g
retrieve (b.all)
	from b in bt_f8_heap
	where b.seqno < "1"::float8
\g
retrieve (b.all)
	from b in bt_f8_heap
	where b.seqno >= "9999"::float8
\g
retrieve (b.all)
	from b in bt_f8_heap
	where b.seqno = "4500"::float8
\g

/*
 * replace
 */
/*
 * BTREE
 */
replace onek (unique1 = onek.unique1 + 1)
\g
replace onek (unique1 = onek.unique1 - 1)
\g
/*
 * BTREE partial
 */
replace onek2 (unique1 = onek2.unique1 + 1)
\g
replace onek2 (unique1 = onek2.unique1 - 1)
\g
/*
 * BTREE shutting out non-functional updates
 */
replace temp (stringu1 = reverse_c16(o.stringu1))
    from o in onek
    where o.stringu1 = "JBAAAA" and
	  o.stringu1 = temp.stringu1
\g
replace temp (stringu1 = reverse_c16(o.stringu1))
    from o in onek2
    where o.stringu1 = "JCAAAA" and
	  o.stringu1 = temp.stringu1
\g
destroy temp
\g
replace p (age = p.age + 1) from p in person*
\g
replace p (age = p.age + 3) from p in person* where p.name = "linda"
\g

/*
 * HASH
 */
replace hash_i4_heap (random = 1)
	where hash_i4_heap.seqno = 1492
\g
retrieve (i1492 = h.seqno, i1 = h.random)
	from h in hash_i4_heap
	where h.random = 1
\g
replace hash_i4_heap (seqno = 20000) 
	where hash_i4_heap.random = 1492795354
\g
retrieve (i20000 = h.seqno)
	from h in hash_i4_heap
	where h.random = 1492795354
\g
replace hash_c16_heap (random = "0123456789abcdef"::char16)
	where hash_c16_heap.seqno = 6543
\g
retrieve (i6543 = h.seqno, c0_to_f = h.random)
	from h in hash_c16_heap
	where h.random = "0123456789abcdef"::char16
\g
replace hash_c16_heap (seqno = 20000)
	where hash_c16_heap.random = "76652222"::char16
\g
/*
 * XXX broken, index scan returns zero rows instead of one 
 */
retrieve (c20000 = h.seqno)
	from h in hash_c16_heap
	where h.random = "76652222"::char16
\g
replace hash_txt_heap (random = "0123456789abcdefghijklmnop"::text)
	where hash_txt_heap.seqno = 4002
\g
retrieve (i4002 = h.seqno, c0_to_p = h.random)
	from h in hash_txt_heap
	where h.random = "0123456789abcdefghijklmnop"::text
\g
replace hash_txt_heap (seqno = 20000)
	where hash_txt_heap.random = "959363399"::text
\g
retrieve (t20000 = h.seqno)
	from h in hash_txt_heap
	where h.random = "959363399"::text
\g
replace hash_f8_heap (random = "-1234.1234"::float8)
	where hash_f8_heap.seqno = 8906
\g
retrieve (i8096 = h.seqno, f1234_1234 = h.random)
	from h in hash_f8_heap
	where h.random = "-1234.1234"::float8
\g
replace hash_f8_heap (seqno = 20000)
	where hash_f8_heap.random = "488912369"::float8
\g
retrieve (f20000 = h.seqno)
	from h in hash_f8_heap
	where h.random = "488912369"::float8
\g

/*
 * append
 * 	(is tested in create.source)
 */

/*
 * queries to plan and execute each plannode and execnode we have
 */

/*
 * builtin functions
 */

/*
 * copy
 */
copy onek to "_OBJWD_/onek.data"
\g
delete onek
\g
copy onek from "_OBJWD_/onek.data"
\g
retrieve (onek.unique1) where onek.unique1 < 2
\g
delete onek2
\g
copy onek2 from "_OBJWD_/onek.data"
\g
retrieve (onek2.unique1) where onek2.unique1 < 2
\g
copy binary stud_emp to "_OBJWD_/stud_emp.data"
\g
delete stud_emp
\g
copy binary stud_emp from "_OBJWD_/stud_emp.data"
\g
retrieve (stud_emp.all)
\g
copy aggtest from stdin
\g
56	7.8
100	99.097
0	0.09561
42	324.78
.
copy aggtest to stdout
\g

/*
 * transaction blocks
 */
begin
\g
retrieve into xacttest (aggtest.all)
\g
append xacttest (a = 777, b = 777.777)
\g
end
\g
/* should retrieve one value */
retrieve (xacttest.a) where xacttest.a > 100
\g

begin
\g
create disappear (a = int4)
\g
delete aggtest
\g
/* should be empty */
retrieve (aggtest.all)
\g
abort
\g
/* should not exist */
retrieve (pg_class.oid) where pg_class.relname = "disappear"
\g
/* should have members again */
retrieve (aggtest.all)
\g

/*
 * portal manipulation
 */
begin
\g
retrieve portal foo1 (tenk1.all)
\g
retrieve portal foo2 (tenk2.all)
\g
retrieve portal foo3 (tenk1.all)
\g
retrieve portal foo4 (tenk2.all)
\g
retrieve portal foo5 (tenk1.all)
\g
retrieve portal foo6 (tenk2.all)
\g
retrieve portal foo7 (tenk1.all)
\g
retrieve portal foo8 (tenk2.all)
\g
retrieve portal foo9 (tenk1.all)
\g
retrieve portal foo10 (tenk2.all)
\g
retrieve portal foo11 (tenk1.all)
\g
retrieve portal foo12 (tenk2.all)
\g
retrieve portal foo13 (tenk1.all)
\g
retrieve portal foo14 (tenk2.all)
\g
retrieve portal foo15 (tenk1.all)
\g
retrieve portal foo16 (tenk2.all)
\g
retrieve portal foo17 (tenk1.all)
\g
retrieve portal foo18 (tenk2.all)
\g
retrieve portal foo19 (tenk1.all)
\g
retrieve portal foo20 (tenk2.all)
\g
retrieve portal foo21 (tenk1.all)
\g
retrieve portal foo22 (tenk2.all)
\g
retrieve portal foo23 (tenk1.all)
\g
fetch 1 in foo1
\g
fetch 2 in foo2
\g
fetch 3 in foo3
\g
fetch 4 in foo4
\g
fetch 5 in foo5
\g
fetch 6 in foo6
\g
fetch 7 in foo7
\g
fetch 8 in foo8
\g
fetch 9 in foo9
\g
fetch 10 in foo10
\g
fetch 11 in foo11
\g
fetch 12 in foo12
\g
fetch 13 in foo13
\g
fetch 14 in foo14
\g
fetch 15 in foo15
\g
fetch 16 in foo16
\g
fetch 17 in foo17
\g
fetch 18 in foo18
\g
fetch 19 in foo19
\g
fetch 20 in foo20
\g
fetch 21 in foo21
\g
fetch 22 in foo22
\g
fetch 23 in foo23
\g
fetch backward 1 in foo23
\g
fetch backward 2 in foo22
\g
fetch backward 3 in foo21
\g
fetch backward 4 in foo20
\g
fetch backward 5 in foo19
\g
fetch backward 6 in foo18
\g
fetch backward 7 in foo17
\g
fetch backward 8 in foo16
\g
fetch backward 9 in foo15
\g
fetch backward 10 in foo14
\g
fetch backward 11 in foo13
\g
fetch backward 12 in foo12
\g
fetch backward 13 in foo11
\g
fetch backward 14 in foo10
\g
fetch backward 15 in foo9
\g
fetch backward 16 in foo8
\g
fetch backward 17 in foo7
\g
fetch backward 18 in foo6
\g
fetch backward 19 in foo5
\g
fetch backward 20 in foo4
\g
fetch backward 21 in foo3
\g
fetch backward 22 in foo2
\g
fetch backward 23 in foo1
\g
close foo1
\g
close foo2
\g
close foo3
\g
close foo4
\g
close foo5
\g
close foo6
\g
close foo7
\g
close foo8
\g
close foo9
\g
close foo10
\g
close foo11
\g
close foo12
\g
end
\g
extend index onek2_u1_prtl where onek2.unique1 <= 60
\g
begin
\g
retrieve portal foo13 (onek.all) where onek.unique1 = 50
\g
retrieve portal foo14 (onek.all) where onek.unique1 = 51
\g
retrieve portal foo15 (onek.all) where onek.unique1 = 52
\g
retrieve portal foo16 (onek.all) where onek.unique1 = 53
\g
retrieve portal foo17 (onek.all) where onek.unique1 = 54
\g
retrieve portal foo18 (onek.all) where onek.unique1 = 55
\g
retrieve portal foo19 (onek.all) where onek.unique1 = 56
\g
retrieve portal foo20 (onek.all) where onek.unique1 = 57
\g
retrieve portal foo21 (onek.all) where onek.unique1 = 58
\g
retrieve portal foo22 (onek.all) where onek.unique1 = 59
\g
retrieve portal foo23 (onek.all) where onek.unique1 = 60
\g
retrieve portal foo24 (onek2.all) where onek2.unique1 = 50
\g
retrieve portal foo25 (onek2.all) where onek2.unique1 = 60
\g
fetch all in foo13
\g
fetch all in foo14
\g
fetch all in foo15
\g
fetch all in foo16
\g
fetch all in foo17
\g
fetch all in foo18
\g
fetch all in foo19
\g
fetch all in foo20
\g
fetch all in foo21
\g
fetch all in foo22
\g
fetch all in foo23
\g
fetch all in foo24
\g
fetch all in foo25
\g
close foo13
\g
close foo14
\g
close foo15
\g
close foo16
\g
close foo17
\g
close foo18
\g
close foo19
\g
close foo20
\g
close foo21
\g
close foo22
\g
close foo23
\g
close foo24
\g
close foo25
\g
end
\g

/*
 * purge
 */
/* hash index was getting trashed - pma 02/14/94 */
/*
purge hash_f8_heap before "now"
\\g
retrieve (has10001 = count{h.seqno}) from h in hash_f8_heap[,]
\\g
vacuum
\\g
retrieve (has10000 = count{h.seqno}) from h in hash_f8_heap[,]
\\g
purge hash_i4_heap after "@ 1 second ago"
\\g
retrieve (has10001 = count{h.seqno}) from h in hash_i4_heap[,]
\\g
vacuum
\\g
retrieve (has10000 = count{h.seqno}) from h in hash_i4_heap[,]
\\g
*/

/*
 * add attribute
 */
create temp (initial = int4)
\g
addattr (a = int4) to temp
\g
addattr
    (b = char16,
     c = text,
     d = float8,
     e = float4,
     f = int2,
     g = polygon,
     h = abstime,
     i = char,
     j = abstime[],
     k = dt,
     l = tid,
     m = xid,
     n = oid8,
     o = lock,
     p = smgr,
     q = point,
     r = lseg,
     s = path,
     t = box,
     u = tinterval,
     v = oidint4,
     w = oidchar16,
     x = float8[],
     y = float4[],
     z = int2[])
to temp
\g
append temp (a=4,
	     b="char16",
	     c="text",
	     d=4.1,
	     e=4.1,
	     f=2,
	     g="(4.1,4.1,3.1,3.1)",
	     h="now",
	     i='c',
	     j="{now, Monday Aug 24 14:43:07 1992 PDT, epoch}",
	     k=314159,
	     l="(1,0,1)",
	     m=512,
	     n="1 2 3 4 5 6 7 8",
	     p="magnetic disk",
	     q="(1.1,1.1)",
	     r="(4.1,4.1,3.1,3.1)",
	     s="(0,2,4.1,4.1,3.1,3.1)",
	     t="(4.1,4.1,3.1,3.1)",
	     u="['current' 'infinity']",
	     v="1/3",
	     w="1,char16",
	     x="{1.0,2.0,3.0,4.0}",
	     y="{1.0,2.0,3.0,4.0}",
	     z="{1,2,3,4}")
\g
retrieve (temp.all)
\g
destroy temp
\g
/* the wolf bug - schema mods caused inconsistent row descriptors */
create temp (initial = int4) archive = light
\g
addattr (a = int4) to temp
\g
addattr
    (b = char16,
     c = text,
     d = float8,
     e = float4,
     f = int2,
     g = polygon,
     h = abstime,
     i = char,
     j = abstime[],
     k = dt,
     l = tid,
     m = xid,
     n = oid8,
     o = lock,
     p = smgr,
     q = point,
     r = lseg,
     s = path,
     t = box,
     u = tinterval,
     v = oidint4,
     w = oidchar16,
     x = float8[],
     y = float4[],
     z = int2[])
to temp
\g
append temp (a=4,
	     b="char16",
	     c="text",
	     d=4.1,
	     e=4.1,
	     f=2,
	     g="(4.1,4.1,3.1,3.1)",
	     h="now",
	     i='c',
	     j="{now, Monday Aug 24 14:43:07 1992 PDT, epoch}",
	     k=314159,
	     l="(1,0,1)",
	     m=512,
	     n="1 2 3 4 5 6 7 8",
	     p="magnetic disk",
	     q="(1.1,1.1)",
	     r="(4.1,4.1,3.1,3.1)",
	     s="(0,2,4.1,4.1,3.1,3.1)",
	     t="(4.1,4.1,3.1,3.1)",
	     u="['current' 'infinity']",
	     v="1/3",
	     w="1,char16",
	     x="{1.0,2.0,3.0,4.0}",
	     y="{1.0,2.0,3.0,4.0}",
	     z="{1,2,3,4}")
\g
retrieve (t.all) from t in temp[,]
\g
destroy temp
\g

/*
 * rename -
 *   should preserve indices
 */
rename tenk1 to ten_k
\g
/* 20 values, sorted */
retrieve (ten_k.unique1) where ten_k.unique1 < 20
\g
/* 20 values, sorted */
retrieve (ten_k.unique2) where ten_k.unique2 < 20
\g
/* 100 values, sorted */
retrieve (ten_k.hundred) where ten_k.hundred = 50
\g
rename ten_k to tenk1
\g
/* 5 values, sorted */
retrieve (tenk1.unique1) where tenk1.unique1 < 5
\g

/*
 * AGGREGATES
 */
retrieve (avg_1 = int4ave{onek.four})
\g
retrieve (avg_32 = int2ave{aggtest.a where aggtest.a < 100})
\g
retrieve (avg_107_943 = float4ave{aggtest.b})
\g
retrieve (avg_3_4 = float8ave{student.gpa})
\g

retrieve (sum_1500 = int4sum{onek.four})
\g
retrieve (sum_198 = int2sum{aggtest.a})
\g
retrieve (avg_431_773 = float4sum{aggtest.b})
\g
retrieve (avg_6_8 = float8sum{student.gpa})
\g

retrieve (max_3 = int4max{onek.four})
\g
retrieve (max_100 = int2max{aggtest.a})
\g
retrieve (max_324_78 = float4max{aggtest.b})
\g
retrieve (max_3_7 = float8max{student.gpa})
\g

retrieve (cnt_1000 = count{onek.four})
\g

retrieve (avg_1 = newavg{onek.four})
\g
retrieve (sum_1500 = newsum{onek.four})
\g
retrieve (cnt_1000 = newcnt{onek.four})
\g

/*
 * inheritance stress test
 */
retrieve (x.all) from x in a_star*
\g
retrieve (x.all) from x in b_star*
        where x.b = "bumble"::text or x.a < 3
\g
retrieve (x.class, x.a) from x in c_star* where x.c ~ "hi"::text
\g
retrieve (x.class, x.b, x.c) from x in d_star* where x.a < 100
\g
retrieve (x.class, x.c) from x in e_star* where x.c NOTNULL
\g
retrieve (x.all) from x in f_star* where x.c ISNULL
\g
rename f in f_star to ff
\g
rename e in e_star* to ee
\g
rename d in d_star* to dd
\g
rename c in c_star* to cc
\g
rename b in b_star* to bb
\g
rename a in a_star* to aa
\g
retrieve (x.class, x.aa) from x in a_star* where x.aa ISNULL
\g
rename aa in a_star to foo
\g
retrieve (x.class, x.foo) from x in a_star where x.foo >= 2
\g
rename foo in a_star to aa
\g
retrieve (x.all) from x in a_star* where x.aa < 1000
\g
addattr (f = int4) to f_star
\g
replace f_star (f = 10)
\g
addattr (e = int4) to e_star*
\g
replace x (e = 42) from x in e_star*
\g
retrieve (x.all) from x in e_star*
\g
addattr (a = text) to a_star*
\g
replace x (a = "gazpacho"::text) from x in b_star* where x.aa > 4
\g
retrieve (x.class, x.aa, x.a) from x in a_star*
\g

/*
 * versions
 */

/*
 * postquel functions
 */
/*
 * mike does post_hacking,
 * joe and sally play basketball, and
 * everyone else does nothing.
 */
retrieve (p.name, p.hobbies.name) from p in person
\g
/*
 * as above, but jeff also does post_hacking.
 */
retrieve (p.name, p.hobbies.name) from p in person*
\g
/*
 * the next two queries demonstrate how functions generate bogus duplicates.
 * this is a "feature" ..
 */
retrieve unique (hobbies_r.name, hobbies_r.equipment.name)
\g
retrieve (hobbies_r.name, hobbies_r.equipment.name)
\g
/*
 * mike needs advil and peet's coffee,
 * joe and sally need hightops, and
 * everyone else is fine.
 */
retrieve (p.name, p.hobbies.name, p.hobbies.equipment.name) from p in person
\g
/*
 * as above, but jeff needs advil and peet's coffee as well.
 */
retrieve (p.name, p.hobbies.name, p.hobbies.equipment.name) from p in person*
\g
/*
 * just like the last two, but make sure that the target list fixup and
 * unflattening is being done correctly.
 */
retrieve (p.hobbies.equipment.name, p.name, p.hobbies.name) from p in person
\g
retrieve (p.hobbies.equipment.name, p.name, p.hobbies.name) from p in person*
\g
retrieve (p.hobbies.equipment.name, p.hobbies.name, p.name) from p in person
\g
retrieve (p.hobbies.equipment.name, p.hobbies.name, p.name) from p in person*
\g
retrieve (user_relns = user_relns())
    sort by user_relns
\g
retrieve (equip_name =
	    name(equipment(hobby_construct("skywalking"::text, "mer"::text))))
\g

/*
 * functional joins
 */

/*
 * instance rules
 */

/*
 * rewrite rules
 */

/*
 * ARRAYS
 */
retrieve (arrtest.all)
\g
retrieve (arrtest.a[1],
          arrtest.b[1][1][1],
          arrtest.c[1],
          arrtest.d[1][1], 
          arrtest.e[0])
\g
retrieve (arrtest.a[1:3],
          arrtest.b[1:1][1:2][1:2],
          arrtest.c[1:2], 
          arrtest.d[1:1][1:2])
\g
/* returns three different results */
retrieve (x = array_dims(arrtest.b))
\g
/* returns nothing */
retrieve (arrtest.all)
         where arrtest.a[1] < 5 and 
               arrtest.c = "{"foobar"}"::_char16
\g
replace arrtest (a[1:2] = "{16,25}",
                 b[1:1][1:1][1:2] = "{113, 117}", 
                 c[1:1] = "{"new_word"}")
\g
retrieve (arrtest.a[1:3],
          arrtest.b[1:1][1:2][1:2],
          arrtest.c[1:2], 
          arrtest.d[1:1][1:2])
\g

/*
 * expensive functions
 */

/*
 * UNTRUSTED FUNCTIONS
 */
/* 0 arguments */
retrieve (forty_two = ufp0())
\g
/* 1 argument, pass-by-value arguments/return-values */
/* also: multiple functions per file */
retrieve (sixteen = ufp1(15))
\g
/* >1 argument, pass-by-reference fixed-length arguments/return-values */
/* also: linking to C library */
retrieve (postgres = ufp2("post"::char16,"gres"::char16))
\g
/* pass-by-reference variable-length arguments/return-values */
/* also: linking to UFP code */
retrieve (postgres = ufp3("postgres rules ok"::text, " "::char))
\g

/*
 * SECURITY CRUFT
 */
replace pg_class (relacl="{}")
	where pg_class.relname !~ "pg_*"::text
\g
replace pg_user (usesuper="f"::bool) where pg_user.usename = "_USER_"
\g

create myclass0 (a=int4)
\g

/* these should all succeed */
append myclass0 (a=5)
\g
retrieve (myclass0.a)
\g
replace myclass0 (a=6)
\g
append myclass0 (a=10)
\g
append myclass0 (a=20)
\g
replace myclass0 (a=10) where myclass0.a < 10
\g
replace myclass0 (a=myclass0.a+1)
\g
delete myclass0 where myclass0.a > 15
\g
define rule foo is on retrieve to myclass0 do instead nothing
\g
remove rule foo
\g

change acl _USER_-arR myclass0
\g

/* succeeds */
replace myclass0 (a=1)
\g
/* succeeds (we still have write permission) */
append myclass0 (a=100)
\g
