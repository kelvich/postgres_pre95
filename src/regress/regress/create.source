/*
 * create.source
 *
 * $Header$
 */

/*
 * ABSTRACT DATA TYPE DEFINITIONS
 */

define function circle_in ( language = "c",
			    returntype = circle )
       arg is (wildcard)
       as "_CWD_/obj/regress.o"
\g

define function circle_out ( language = "c", 
			     returntype = wildcard )
       arg is (wildcard)
       as "_CWD_/obj/regress.o"
\g

define type circle ( internallength = 24, 
		     input = circle_in,
		     output = circle_out )
\g

define type city_budget ( internallength = 16, 
			  input = int44in, 
			  output = int44out, 
			  element = int4 )
\g

/*
 * CLASS DEFINITIONS
 */
create hobbies_r (name = text, person = text)
\g
create equipment_r (name = text, hobby = text)
\g
create onek(unique1=int4,
	    unique2=int4,
	    two=int4,
	    four=int4,
	    ten=int4,
	    twenty=int4,
	    hundred=int4,
	    thousand=int4,
	    twothousand=int4,
	    fivethous=int4,
	    tenthous=int4,
	    odd=int4,
	    even=int4,
	    stringu1=char16,
	    stringu2=char16,
	    string4=char16)
\g
create tenk1 (unique1=int4,
	      unique2=int4,
	      two=int4,
	      four=int4,
	      ten=int4,
	      twenty=int4,
	      hundred=int4,
	      thousand=int4,
	      twothousand=int4,
	      fivethous=int4,
	      tenthous=int4,
	      odd=int4,
	      even=int4,
	      stringu1=char16,
	      stringu2=char16,
	      string4=char16)
\g
create tenk2 (unique1 = int4,
	      unique2 = int4,
	      two = int4,
	      four = int4,
	      ten=int4,
	      twenty = int4,
	      hundred = int4,
	      thousand = int4,
	      twothousand = int4,
	      fivethous = int4,
	      tenthous=int4,
	      odd=int4,
	      even=int4,
	      stringu1=char16,
	      stringu2=char16,
	      string4=char16)
\g

create person (name = text, age = int4, location = point)
\g
create emp (salary = int4, manager = char16)
       inherits (person)
\g
create student (gpa = float8)
       inherits (person)
\g
create stud_emp (percent = int4)
       inherits (emp, student)
\g
create city (name = char16, location = box, budget = city_budget)
\g
create dept (dname = char16, mgrname = text)
\g
create slow_emp4000 (home_base = box)
\g
create fast_emp4000 (home_base = box)
\g
create road (name = text, thepath = path)
\g
create ihighway () inherits (road)
\g
create shighway (surface = text)
       inherits (road)
\g
create real_city (pop = int4, cname = text, outline = path)
\g
create aggtest (a = int2, b = float4)
\g
create arrtest (a = int2[], b = int4[], c = char16[], d = text[])
\g

/*
 * FUNCTION DEFINITIONS
 */
define function hobbies ( language = "postquel",
			  returntype = setof hobbies_r )
       arg is (person)
       as "retrieve (hobbies_r.all) where hobbies_r.person = $1.name"
\g
define function hobby_construct ( language = "postquel",
				  returntype = hobbies_r )
       arg is (text, text)
       as "retrieve (name = $1, hobby = $2)"
\g
define function equipment ( language = "postquel",
			    returntype = setof equipment_r )
       arg is (hobbies_r)
       as "retrieve (equipment_r.all) where equipment_r.hobby = $1.name"
\g
define function user_relns ( language = "postquel",
			     returntype = setof char16 )
       as "retrieve (pg_class.relname)
       where pg_class.relname !~ \\"pg_.*\\" and
	     pg_class.relkind != 'i' "
\g
define function pt_in_circle ( language = "c",
			       returntype = int4 )
       arg is (point, circle)
       as "_CWD_/obj/regress.o"
\g

define function overpaid ( language = "c",
			   returntype = bool ) 
       arg is (emp)
       as "_CWD_/obj/regress.o"
\g

define function boxarea ( language = "c", 
			  returntype = int4 )
       arg is (box)
       as "_CWD_/obj/regress.o"
\g

define function interpt_pp ( language = "c",
			     returntype = point )
       arg is (path, path)
       as "_CWD_/obj/regress.o"
\g

define function reverse_c16 ( language = "c",
			      returntype = char16 )
       arg is (char16)
       as "_CWD_/obj/regress.o"
\g

/* untrusted functions */
define function ufp0 ( language = "c",
		       returntype = int4 )
       arg is ( )
       as "_CWD_/obj/ufp1.o"
\g
replace pg_proc ( proistrusted = "f"::bool,
		  pronargs = 0 )
	where pg_proc.proname = "ufp0"
\g
define function ufp1 ( language = "c",
		       returntype = int4 )
       arg is (int4)
       as "_CWD_/obj/ufp1.o"
\g
replace pg_proc ( proistrusted = "f"::bool )
	where pg_proc.proname = "ufp1"
\g
define function ufp2 ( language = "c",
		       returntype = char16 )
       arg is (char16, char16)
       as "_CWD_/obj/ufp2.o"
\g
replace pg_proc ( proistrusted = "f"::bool )
	where pg_proc.proname = "ufp2"
\g
define function ufp3 ( language = "c",
		       returntype = text )
       arg is (text, char)
       as "_CWD_/obj/ufp3.o"
\g
replace pg_proc ( proistrusted = "f"::bool )
	where pg_proc.proname = "ufp3"
\g

/*
 * FUNCTION DYNAMIC LOADING
 */
load "_CWD_/obj/regress.o"
\g

/*
 * CLASS POPULATION
 *	(any resemblance to real life is purely coincidental)
 */
copy onek from "_CWD_/../data/onek.data"
\g
copy tenk1 from "_CWD_/../data/tenk.data"
\g
append tenk2 (tenk1.all)
\g

copy slow_emp4000 from "_CWD_/../data/rect.data"
\g
append fast_emp4000 (slow_emp4000.all)
\g

copy person from "_CWD_/../data/person.data"
\g
copy emp from "_CWD_/../data/emp.data"
\g
copy student from "_CWD_/../data/student.data"
\g
copy stud_emp from "_CWD_/../data/stud_emp.data"
\g
retrieve into Bprime (t.all) from t in tenk1 where t.unique2 < 1000
\g
append hobbies_r (name = "posthacking", person = p.name) from p in person*
       where p.name = "mike" or p.name = "jeff"
\g
append hobbies_r (name = "basketball", person = person.name)
       where person.name = "joe" or person.name = "sally"
\g
append hobbies_r (name = "skywalking")
\g
append equipment_r (name = "advil", hobby = "posthacking")
\g
append equipment_r (name = "peet's coffee", hobby = "posthacking")
\g
append equipment_r (name = "hightops", hobby = "basketball")
\g
append equipment_r (name = "guts", hobby = "skywalking")
\g

copy road from "_CWD_/../data/streets.data"
\g
copy real_city from "_CWD_/../data/real_city.data"
\g
retrieve into ramp (road.all) where road.name ~ ".*Ramp"
\g
append ihighway (road.all) where road.name ~ "I- .*"
\g
append shighway (road.all) where road.name ~ "State Hwy.*"
\g
replace shighway (surface = "asphalt")
\g

append aggtest (a = 56, b = 7.8)
\g
append aggtest (a = 100, b = 99.097)
\g
append aggtest (a = 0, b = 0.09561)
\g
append aggtest (a = 42, b = 324.78)
\g

append arrtest (a = "{}", b = "{}", c = "{}", d = "{}")
\g
append arrtest (a = "{"1"}", b = "{"1"}", c = "{"foobar"}", d = "{"barfoo"}")
\g
append arrtest (a = "{1,2}", b = "{3,4}", c = "{foo,bar}", d = "{bar,foo}")
\g

create iportaltest (i = int4, d = float4, p = polygon)
\g
append iportaltest (i = 1, d = 3.567, p = "(3.0,4.0,1.0,2.0)"::polygon)
\g
append iportaltest (i = 2, d = 89.05, p = "(4.0,3.0,2.0,1.0)"::polygon)
\g

/*
 * Define ancillary data structures (i.e. indices)
 */
define index onek_unique1 on onek using btree(unique1 int4_ops)
\g
define index onek_unique2 on onek using btree(unique2 int4_ops)
\g
define index onek_hundred on onek using btree(hundred int4_ops)
\g
define index onek_stringu1 on onek using btree(stringu1 char16_ops)
\g
define index tenk1_unique1 on tenk1 using btree(unique1 int4_ops)
\g
define index tenk1_unique2 on tenk1 using btree(unique2 int4_ops)
\g
define index tenk1_hundred on tenk1 using btree(hundred int4_ops)
\g
define index tenk2_unique1 on tenk2 using btree(unique1 int4_ops)
\g
define index tenk2_unique2 on tenk2 using btree(unique2 int4_ops)
\g
define index tenk2_hundred on tenk2 using btree(hundred int4_ops)
\g
define index rect2ind on fast_emp4000 using rtree (home_base bigbox_ops)
\g
define index rix on road using btree (name text_ops)
\g
define index iix on ihighway using btree (name text_ops)
\g
define index six on shighway using btree (name text_ops)
\g

/*
 * OPERATOR DEFINITIONS
 */
define operator ## ( arg1 = path,
		     arg2 = path,
		     procedure = path_inter,
		     commutator = ## )
\g

define operator <% ( arg1 = point,
		     arg2 = circle,
		     procedure = pt_in_circle,
		     associativity = left,
		     commutator = >=% )
\g

/*
 * VIRTUAL CLASS DEFINITIONS
 *	(this also tests the query rewrite system)
 */
define view street ( road.name,
		     road.thepath,
		     cname = real_city.cname )
       where real_city.outline ## road.thepath
\g

define view iexit ( ihighway.name,
		    ihighway.thepath, 
		    exit = interpt_pp(ihighway.thepath, ramp.thepath) )
       where ihighway.thepath ## ramp.thepath
\g

define view toyemp ( emp.name,
		     emp.age,
		     emp.location,
		     annualsal = 12*emp.salary )
\g

/*
 * AGGREGATE DEFINITIONS
 */
/* all functions defined */
define aggregate newavg (sfunc1 = int4pl,
			 basetype = int4,
			 stype1 = int4,
			 sfunc2 = int4inc,
			 stype2 = int4,
			 finalfunc = int4div,
			 initcond1 = "0",
			 initcond2 = "0")
\g
/* sfunc1 (value-dependent) only */
define aggregate newsum (sfunc1 = int4pl, basetype = int4, 
			 stype1 = int4, initcond1 = "0")
\g
/* sfunc2 (value-independent) only */
define aggregate newcnt (sfunc2 = int4inc, stype2 = int4, initcond2 = "0")
\g

vacuum
\g

/*
 * sanity check, if we don't have indices the test will take years to
 * complete.
 */
retrieve ( pg_class.relname, pg_class.relhasindex )
	   where pg_class.relhasindex
\g
